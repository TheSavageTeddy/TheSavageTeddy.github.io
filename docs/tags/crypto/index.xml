<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Crypto on teddyctf</title>
    <link>https://TheSavageTeddy.github.io/tags/crypto/</link>
    <description>Recent content in Crypto on teddyctf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>teddyctf</copyright>
    <lastBuildDate>Sat, 28 Sep 2024 17:53:20 +1000</lastBuildDate><atom:link href="https://TheSavageTeddy.github.io/tags/crypto/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Crypto Writeups - BSides Canberra CTF 2024</title>
      <link>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/</link>
      <pubDate>Sat, 28 Sep 2024 17:53:20 +1000</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Last week I went to BSides Canberra 2024 to see the amazing talks, meet people, and of course, play CTF. After 2 days of solving interesting challenges, my team &lt;a href=&#34;https://x.com/EmuExploit&#34;&gt;Emu Exploit&lt;/a&gt; managed to get 2nd place overall!&lt;/p&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;I was basically the only person in the team who was willing to do crypto :&amp;lt; so I decided to write up the crypto challenges I solved. Enjoy!&lt;/p&gt;
&lt;h1 id=&#34;challenges-overview&#34;&gt;Challenges Overview&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;43&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#psionic---10-solves&#34;&gt;Psionic&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;10&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#public-service---8-solves&#34;&gt;Public Service&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#arpeeceethree---3-solves&#34;&gt;arpeeceethree&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm - 43 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You enter a room. On the wall is a large tapestry showing two people exchanging gifts. What could it mean?&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Last week I went to BSides Canberra 2024 to see the amazing talks, meet people, and of course, play CTF. After 2 days of solving interesting challenges, my team &lt;a href=&#34;https://x.com/EmuExploit&#34;&gt;Emu Exploit&lt;/a&gt; managed to get 2nd place overall!&lt;/p&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;I was basically the only person in the team who was willing to do crypto :&amp;lt; so I decided to write up the crypto challenges I solved. Enjoy!&lt;/p&gt;
&lt;h1 id=&#34;challenges-overview&#34;&gt;Challenges Overview&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;43&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#psionic---10-solves&#34;&gt;Psionic&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;10&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#public-service---8-solves&#34;&gt;Public Service&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#arpeeceethree---3-solves&#34;&gt;arpeeceethree&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm - 43 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You enter a room. On the wall is a large tapestry showing two people exchanging gifts. What could it mean?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are provided with two files, &lt;code&gt;discreteAddarithm.py&lt;/code&gt; and &lt;code&gt;out.txt&lt;/code&gt;&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;discreteAddarithm.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Util.number import getPrime, getRandomInteger, getRandomRange
from Crypto.Protocol.KDF import HKDF
import Crypto.Hash.SHA512 as sha512
import Crypto.Cipher.AES as aes
from Crypto.Util.Padding import pad, unpad
from binascii import * 
from cybearssecrets import flag

def generateParameters(bitlen=1024):
	p = getPrime(bitlen)
	gen = getRandomRange(2,p-1)
	return gen, p

def generateKeyPair(p, gen):
	privateKey = getRandomRange(2,p-1)
	publicKey = privateKey*gen % p
	return privateKey, publicKey

def generateSharedSecret(p, recipientPrivateKey, senderPublicKey):
	sharedSecret = recipientPrivateKey*senderPublicKey % p
	return sharedSecret

## Init
gen, p = generateParameters()
print(&amp;#34;gen = {}&amp;#34;.format(gen))
print(&amp;#34;p = {}&amp;#34;.format(p))

## A: Alice generates her pub/priv key pair
aPrivateKey, aPublicKey = generateKeyPair(p, gen)

## B: Bob generates his pub/priv key pair
bPrivateKey, bPublicKey = generateKeyPair(p, gen)

## A: Alice sends Bob her public key
print(&amp;#34;aPublicKey = {}&amp;#34;.format(aPublicKey))

## B: Bob sends Alice his public key
print(&amp;#34;bPublicKey = {}&amp;#34;.format(bPublicKey))

## A: Alice caluculates the shared secret
aSharedSecret = generateSharedSecret(p, aPrivateKey, bPublicKey)

## B: Bob caluculates the shared secret
bSharedSecret = generateSharedSecret(p, bPrivateKey, aPublicKey)

## Prove that they match
assert(aSharedSecret == bSharedSecret)

## A: Alice encrypts a message to Bob
aSessionKey, aIV = HKDF(long_to_bytes(aSharedSecret), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
a = aes.new(aSessionKey, aes.MODE_CBC, iv=aIV)
aCipher = a.encrypt(pad(flag,16))

print(&amp;#34;aCipher = {}&amp;#34;.format(hexlify(aCipher)))

## B: Bob decrypts the message
bSessionKey, bIV = HKDF(long_to_bytes(bSharedSecret), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
b = aes.new(bSessionKey, aes.MODE_CBC, iv=bIV)
bPlain = unpad(b.decrypt(aCipher), 16)

if (bPlain == flag):
	print(&amp;#34;Successful decryption!&amp;#34;) 
else:
	print(&amp;#34;Error - something went wrong&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;485136927&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;485136927&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;text&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;out.txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-text&#34; &gt;&lt;code&gt;
gen = 107665309954437515284050955368964848368303288172119448977068684165707548536106035934408882308704533335892101447750709116199826328820028967921540045634698373851938861013761725712688725891129665455073194344098566187055873775659411023106521425479072045658166413360399757570409372209072730576562842193768242314124
p = 154305601419430130125267211117098923915333624355567046250094074039674228187186943601303157833374662739969026864299363336407319080223107540886546467388611809417774875857578639486137855088896821184616399750557477866148643263803196632154429856293530179926011705130915364080130059881980341409627009701357523451267
aPublicKey = 80354936104370249925868492705190743680652231716704224547570074631753287352078443184923555333860525866848256788314156023903492043171511797029693297228294483818872563765707539175061570839714448005871291987391648926205060807957012526950116361633119573934316064444374124669861697695772912934202842834007697535925
bPublicKey = 42387482047117421466928118692687568439415997629141048723182072767997284324764640343272008345119819287526375581385721174494274510726524360731480638585425669685247170958054446797249761744238847427213615385731375648168698821769635116850680245545304663686514311913787022427877096835277158288159213482962236809739
aCipher = b&amp;#39;618fa12c3a6a6956a47a91bec13f9e1fe2d1031ba2f40a42b4f4d1d9757d0195ea6215fd694c2b99cf9a00be97b46791&amp;#39;
Successful decryption!
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It is essentially &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&#34;&gt;Diffie Hellman key exchange&lt;/a&gt;, but with multiplication instead of exponentiation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p$ is a random 1024-bit prime&lt;/li&gt;
&lt;li&gt;$g$ (&lt;code&gt;gen&lt;/code&gt;) is a random integer from $2$ to $p-1$&lt;/li&gt;
&lt;li&gt;Alice generates her private key $a$ and computes her public key $A = a \times g \bmod{p}$&lt;/li&gt;
&lt;li&gt;Bob generates his public key $b$ and computers his public key $B = b \times g \bmod{p}$&lt;/li&gt;
&lt;li&gt;We are given $p$, $g$, $A$ and $B$&lt;/li&gt;
&lt;li&gt;The shared secret $s$ is calculated such that $s = A \times b = a \times g \times b = B \times a \bmod{p}$, and used as an AES key to encrypt the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Diffie Hellman leverages the discrete logarithm problem to make retrieving the private key from the public key difficult. However, in this challenge, multiplication is used instead of exponentiation to compute the public key, as $A = a \times g \bmod{p}$ instead of $A = a^g \bmod{p}$.&lt;/p&gt;
&lt;p&gt;Therefore, we can simply rearrange for the private key $a = A \times g^{-1} \bmod{p}$, then calculate the shared secret $s = a \times B \bmod{p}$, and decrypt the flag using the shared secret as the AES key.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Protocol.KDF import HKDF
import Crypto.Hash.SHA512 as sha512
import Crypto.Cipher.AES as aes

# values
g = 107665309954437515284050955368964848368303288172119448977068684165707548536106035934408882308704533335892101447750709116199826328820028967921540045634698373851938861013761725712688725891129665455073194344098566187055873775659411023106521425479072045658166413360399757570409372209072730576562842193768242314124
p = 154305601419430130125267211117098923915333624355567046250094074039674228187186943601303157833374662739969026864299363336407319080223107540886546467388611809417774875857578639486137855088896821184616399750557477866148643263803196632154429856293530179926011705130915364080130059881980341409627009701357523451267
A = 80354936104370249925868492705190743680652231716704224547570074631753287352078443184923555333860525866848256788314156023903492043171511797029693297228294483818872563765707539175061570839714448005871291987391648926205060807957012526950116361633119573934316064444374124669861697695772912934202842834007697535925
B = 42387482047117421466928118692687568439415997629141048723182072767997284324764640343272008345119819287526375581385721174494274510726524360731480638585425669685247170958054446797249761744238847427213615385731375648168698821769635116850680245545304663686514311913787022427877096835277158288159213482962236809739
enc =  bytes.fromhex(&amp;#39;618fa12c3a6a6956a47a91bec13f9e1fe2d1031ba2f40a42b4f4d1d9757d0195ea6215fd694c2b99cf9a00be97b46791&amp;#39;)

# solve
a = (A * pow(g, -1, p)) % p
s = (a * B) % p

aSessionKey, aIV = HKDF(long_to_bytes(s), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
a = aes.new(aSessionKey, aes.MODE_CBC, iv=aIV)
flag = a.decrypt(enc)
print(f&amp;#34;{flag = }&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Flag: &lt;code&gt;cybears{C3rt41nly_ADDS_s0m3_pr0bl3ms}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;psionic---10-solves&#34;&gt;Psionic - 10 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The cybears face a door with a large wooden face carved into it. Surprisingly, the face starts moving and speaking! &amp;ldquo;Speak the password to enter&amp;rdquo; booms the door&amp;hellip; the cybears consider their options..&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nc psionic.chal.cybears.io 2323&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This was a really weird challenge. We are given server code and an instance to connect to:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;219574638&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;219574638&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

from hashlib import sha1
from Crypto.Util.number import bytes_to_long, long_to_bytes, getRandomInteger, getPrime
import ast
import sys
import json

# This cybears.py file is not included in the handout.
# If you&amp;#39;d like to test locally, create a cybears.py file and put sensible variables in there
from cybears import secret_password, secret_password_chars, flag

# Server-client authentication protocol, but utilising Private-Set-Intersection
# Based on https://csrc.nist.gov/CSRC/media//Projects/pec/documents/stppa-02-PSI-rosulek.pdf

# Client ------------- Server
# 1. {H(p1)^a, H(p2)^a ... } -&amp;gt; 
# 2.               &amp;lt;- {H(s1)^b, H(s2)^b, ..., H(p1)^a^b, H(p2)^a^b... }
# 3. {H(s1)^b^a, H(s2)^b^a, ...} 
# 4. Client checks whether any of the H(s_i)^b^a == H(p_j)^a^b
# 5. Server does same
# 6. If all p_i == s_j, allow client to submit H(nonce || password) for flag! 


def validate_client(client1): 
    result = False
    output = {}

    # parse input 
    try:
        c = ast.literal_eval(client1)
    except Exception as e: 
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        return result, output    

    # Check that we have a set
    if type(c) != list: 
        return result, output

    # Check that all elements in the list are integers
    if all(list(map(lambda x: type(x) == int, c))) != True: 
        return result, output

    result = True
    output = c
    return result, output 


if __name__ == &amp;#34;__main__&amp;#34;:

    # Generate ephemeral server public/private keys
    generator = 2
    public_prime = getPrime(1024)
    server_private = getRandomInteger(1024)
    server_public = pow( 2, server_private, public_prime)
    params = { &amp;#34;prime&amp;#34; : public_prime, &amp;#34;generator&amp;#34;: generator, &amp;#34;server_public&amp;#34; : server_public } 
    


    print(&amp;#34;Welcome to the psionic login server!&amp;#34;)
    print(&amp;#34;params = {}&amp;#34;.format(json.dumps(params)))
    print(&amp;#34;Please enter your set of passwords and we will confirm there is a match:&amp;#34;)

    # 1. client to send commitment
    client1 = input() #expect single string of len(password) entries as a list
    
    result, output = validate_client(client1)
    if result == False: 
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        sys.exit(-1)
    
    if len(output) != len(secret_password):
        print(&amp;#34;Incorrect length - must same length as password&amp;#34;)
        sys.exit(-1)
        
    # 2. server to send commitment
    server_response1 = list(map(lambda x : pow(x, server_private, public_prime), output))
    server_response2 = list(map(lambda x : pow(bytes_to_long(sha1(x.encode()).digest()), server_private, public_prime), secret_password_chars))
    print(&amp;#34;{}&amp;#34;.format(server_response1 &amp;#43; server_response2))

    # 3. client to send verification
    client2 = input() #expect single string of len(password) entries as a list

    result2, output2 = validate_client(client2)
    if result2 == False:
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        sys.exit(-1)

    if len(output2) != len(secret_password):
        print(&amp;#34;Incorrect length - must same length as password&amp;#34;)
        print(&amp;#34;DEBUG: {} / {}&amp;#34;.format( len(output), len(secret_password)))
        sys.exit(-1)

    # 5. Server validation - confirm that { H(p_i)^b^a } == {H(s_i)^a^b}
    # Client could just replay, but we don&amp;#39;t just accept this as proof of knowing the password! 
    print(&amp;#34;checking...&amp;#34;)
    
    if (set(output2) == set(server_response1)): 
        print(&amp;#34;Sets are a match! You must know the password!&amp;#34;) 
        print(&amp;#34;Send it through&amp;#34;) # TODO, hash with a nonce? 
        
        client_password = input()
        if(client_password == secret_password): 
            print(&amp;#34;Correct! Here is your flag: {}&amp;#34;.format(flag))
            sys.exit(0)
        else: 
            print(&amp;#34;Incorrect password&amp;#34;)
            sys.exit(-1)
    else:
        print(&amp;#34;Set mismatch. You don&amp;#39;t know the password!&amp;#34;)
        sys.exit(-1)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It&amp;rsquo;s supposedly some sort of &amp;ldquo;Private Set Intersection&amp;rdquo; (PSI), where we need to provide integers (being characters of the password), and it will tell us how many of those are part of the password, and we provide the full password to get the flag.&lt;/p&gt;
&lt;p&gt;Lets step through the server code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, we&amp;rsquo;re provided with some parameters, a prime $p$, generator $g$ and server public value $v = g^y \bmod{p}$ where $y$ is the server private value (These turn out to be useless, so we can kind of just ignore this).&lt;/li&gt;
&lt;li&gt;Next, it prompts us for a list of integers $X = \{x_0, x_1, &amp;hellip;, x_n\}$, and the list must be the same length as the password&lt;/li&gt;
&lt;li&gt;It then loops through the list of integers $X$ and computes $H_X = x_n^y \bmod{p}$ for each item $x_n$ in our list $X$, where H(x) is the SHA1 hash function.&lt;/li&gt;
&lt;li&gt;It does a similar operation for the password chars, computing $H_Z = H(z_n)^y \bmod{p}$ for each character $z_n$ in the password $Z$.&lt;/li&gt;
&lt;li&gt;It sends us both $H_X$ and $H_Z$, which are &amp;ldquo;hidden&amp;rdquo;, hashed values used to compute the private set intersection.&lt;/li&gt;
&lt;li&gt;We are prompted again to provide another list of integers, and the server will check if this list is equal to $H_X$. This step doesn&amp;rsquo;t really make sense since the server sends us $H_X$, so all we have to do is repeat it back.&lt;/li&gt;
&lt;li&gt;If equal, we will be prompted to enter the password as a string, and if the password is correct, we get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code really confused me as I wasn&amp;rsquo;t sure what the challenge was here. I looked at the &lt;a href=&#34;https://csrc.nist.gov/CSRC/media//Projects/pec/documents/stppa-02-PSI-rosulek.pdf&#34;&gt;link provided in the code&lt;/a&gt; which was an overview on Private Set Intersection, and saw that just hashing elements of the set was bad for PSI.&lt;/p&gt;

  &lt;img src=&#34;./img/bad_psi.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;This is because the point of a private set intersection is for two parties, each with their own private set of data, to compute the intersection between the two sets, &lt;strong&gt;without&lt;/strong&gt; either party learning about the whole private set of the other.&lt;/p&gt;
&lt;p&gt;One (bad) way to do this is for you to hash all elements of your set, and the other party does the same. Then you can compare hashed elements - as identical elements hash to the same digest, you can perform PSI by computing the intersection between sets containing the hashed elements. But the link mentions this is a bad way to do it, because you can use a dictionary attack, hashing all possible values of elements in the set, and comparing it to the hash digest of the other party, learning about their elements if hash digests match.&lt;/p&gt;
&lt;p&gt;However, the server seems to mitigate this - recall that our &amp;ldquo;hidden&amp;rdquo; set is $H_X = x_n^y \bmod{p}$, and we don&amp;rsquo;t know the server private value $y$, so we cannot compute this ourselves. But almost the same method is used to generate the password, $H_Z = H(z_n)^y \bmod{p}$, and the server sends us both these sets. Therefore, we can send $X = \{H(&amp;ldquo;a&amp;rdquo;), H(&amp;ldquo;b&amp;rdquo;), &amp;hellip;\}$ and the server will compute $H_X = x_n^y \bmod{p}$ which will be $\{H(&amp;ldquo;a&amp;rdquo;)^y, H(&amp;ldquo;b&amp;rdquo;)^y, &amp;hellip;\}$, and we can compute this set to the password set which will be $\{H(z_0)^y, H(z_1)^y, &amp;hellip;, H(z_n)^y\}$ and intersect these two sets. An element in both these sets reveals a character of the password.&lt;/p&gt;
&lt;p&gt;The server imports the secret password and password chars:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# This cybears.py file is not included in the handout.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# If you&amp;#39;d like to test locally, create a cybears.py file and put sensible variables in there&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; cybears &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; secret_password, secret_password_chars, flag
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I assumed &lt;code&gt;cybears.py&lt;/code&gt; would look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1234567890!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(secret_password)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cybears&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{testing}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But after my solve script worked local but not on remote, I asked the challenge author if &lt;code&gt;secret_password&lt;/code&gt; and &lt;code&gt;secret_password_chars&lt;/code&gt; were constnat on the server. As it turns out, while &lt;code&gt;secret_password&lt;/code&gt; is constant, &lt;code&gt;secret_password_chars&lt;/code&gt; is not - it&amp;rsquo;s scrambled! Which means &lt;code&gt;cybears.py&lt;/code&gt; probably looks something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1234567890!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;shuffle(list(secret_password))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cybears&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{testing}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Knowing this, I came up with the solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Brute force a little bit to get the password length (server will error if provided integer list not same length as password), which turned out to be 11&lt;/li&gt;
&lt;li&gt;Check what characters were in the password, by sending integers from 0 to 255, 11 at a time, and intersecting the sets returned from the server. Technically, the sets returned by the server were lists, so we can note the indexes of elements that intersected to know which character is in the password.&lt;/li&gt;
&lt;li&gt;Attempt to unscramble the characters to form a password, such as by using an anagram solver.&lt;/li&gt;
&lt;li&gt;Submit password and get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I found it really weird that I had to unscramble the password, it didn&amp;rsquo;t seem to make sense that &lt;code&gt;secret_password_chars&lt;/code&gt; was scrambled, as otherwise, you could easily correlate the indexes of intersecting elements to know what character is in what position. My best guess for why it was scrambled would be that the challenge author wanted to simulate the unordered nature of sets. If anyone knows why, please let me know!&lt;/p&gt;
&lt;p&gt;After running a script to get all the chars, we get characters &lt;code&gt;[&#39;!&#39;, &#39;1&#39;, &#39;A&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;l&#39;, &#39;m&#39;, &#39;o&#39;, &#39;r&#39;, &#39;t&#39;]&lt;/code&gt;. Convering some from l33t c0d3 and putting it in an anagram solver, we get &lt;code&gt;Algorithm&lt;/code&gt; as a potential word. Then we can start to guess passwords, and the correct one turns out to be &lt;code&gt;Algorithm1!&lt;/code&gt;, which gets us the flag.&lt;/p&gt;
&lt;p&gt;Solve scripts:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;615783429&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;615783429&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;get_pw_chars.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *
from Crypto.Util.number import *
import json
import string
from hashlib import sha1

pw_chars = []

step = 11
for i in range(0, 256, step):
    r = remote(&amp;#34;psionic.chal.cybears.io&amp;#34;, 2323)
    # r = remote(&amp;#34;localhost&amp;#34;, 1111)

    r.recvline()
    r.recvuntil(b&amp;#34;params = &amp;#34;)
    params = json.loads(r.recvline().strip().decode()) # unused
    r.recvuntil(b&amp;#34; match:&amp;#34;)
    
    arr_raw = [chr(v) for v in range(i, i&amp;#43;step)]
    arr = [bytes_to_long(sha1(v.encode()).digest()) for v in arr_raw]

    r.sendline(str(arr).encode())
    r.recvline()

    resp = eval(r.recvline().strip().decode())
    H_X, H_Y = resp[:11], resp[11:]

    for xi, x in enumerate(H_X):
        for yi, y in enumerate(H_Y):
            if x == y:
                pw_chars.append(arr_raw[xi])

print(f&amp;#34;{pw_chars = }&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;593621748&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;593621748&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;get_flag.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *
from Crypto.Util.number import *
import json
import string
from hashlib import sha1

pw_chars = []
r = remote(&amp;#34;psionic.chal.cybears.io&amp;#34;, 2323)
# r = remote(&amp;#34;localhost&amp;#34;, 1111)

r.recvline()
r.recvuntil(b&amp;#34;params = &amp;#34;)
params = json.loads(r.recvline().strip().decode()) # unused
r.recvuntil(b&amp;#34; match:&amp;#34;)

arr_raw = [chr(v) for v in range(0, 11)]
arr = [bytes_to_long(sha1(v.encode()).digest()) for v in arr_raw]

r.sendline(str(arr).encode())
r.recvline()

resp = eval(r.recvline().strip().decode())
H_X, H_Y = resp[:11], resp[11:]

r.sendline(str(H_X).encode())

r.sendline(b&amp;#34;Algorithm1!&amp;#34;)
r.interactive()

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Flag: &lt;code&gt;cybears{n0t_s0_pr1v@t3_int3rs3ct10n}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This was a unique challenge, different to most crypto chals, but I didn&amp;rsquo;t really like having to guess the password from a set of characters - I thought that was a bit guessy and I was lucky to have guessed it.&lt;/p&gt;
&lt;h1 id=&#34;public-service---8-solves&#34;&gt;Public Service - 8 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You find a parchment filled with ancient writings. At the bottom are a number of ornate calligraphic signatures&amp;hellip;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This was a nice challenge. We&amp;rsquo;re given two files, &lt;code&gt;generate_signatures.py&lt;/code&gt; and &lt;code&gt;out.json&lt;/code&gt;:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;873692415&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;873692415&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;generate_signatures.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import Crypto.Signature.DSS as dss
import Crypto.PublicKey.ECC as ecc
import Crypto.Hash.SHA256 as sha256
import Crypto.PublicKey.RSA as rsa
import Crypto.Signature.PKCS1_v1_5 as pkcs
import Crypto.Cipher.PKCS1_OAEP as oaep
from Crypto.Util.number import inverse, getPrime, isPrime, long_to_bytes, bytes_to_long
from binascii import hexlify
import json

from cybearssecrets import FLAG

MESSAGE1 = b&amp;#39;If a new source of energy is not found, no one is going to win this war&amp;#39;
MESSAGE2 = b&amp;#39;Bah weep gragnah weep nini bong&amp;#39;
MESSAGE3 = b&amp;#39;Freedom is the right of all sentient beings&amp;#39;

## Generate Elliptic Curve parameters
ec = ecc.generate(curve = &amp;#34;p256&amp;#34;)
ec_signer = dss.new(ec, &amp;#39;fips-186-3&amp;#39;)

## Generate Elliptic Curve Signature
ec_hasher = sha256.new(MESSAGE1)
ec_sig = ec_signer.sign(ec_hasher)

## Generate RSA parameters
def generate_special_prime(b):
    t = bytes_to_long(b)
    while not(isPrime(t)):
        t &amp;#43;= 1
    return t

rsa_p = generate_special_prime(long_to_bytes(ec.pointQ.x)&amp;#43;long_to_bytes(ec.pointQ.y))
rsa_q = getPrime(512) 

rsa_n = rsa_p*rsa_q
rsa_e = 65537
rsa_d = inverse(rsa_e, (rsa_p-1)*(rsa_q-1))

r = rsa.construct((rsa_n,rsa_e,rsa_d))

## Generate RSA Signatures
rsa_signer = pkcs.new(r)

rsa_hasher1 = sha256.new(MESSAGE2)
rsa_hasher2 = sha256.new(MESSAGE3)

rsa_sig1 = rsa_signer.sign(rsa_hasher1)
rsa_sig2 = rsa_signer.sign(rsa_hasher2)

## Encrypt Flag
encrypter = oaep.new(r)
cipher = encrypter.encrypt(FLAG)

j = {}
j[&amp;#39;ec_sig&amp;#39;] = hexlify(ec_sig).decode()
j[&amp;#39;rsa_sig1&amp;#39;] = hexlify(rsa_sig1).decode()
j[&amp;#39;rsa_sig2&amp;#39;] = hexlify(rsa_sig2).decode()
j[&amp;#39;cipher&amp;#39;] = hexlify(cipher).decode()

with open(&amp;#34;out.json&amp;#34;, &amp;#34;w&amp;#34;) as g: 
    g.write(json.dumps(j))

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;827964531&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;827964531&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;json&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;out.json&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-json&#34; &gt;&lt;code&gt;
{&amp;#34;ec_sig&amp;#34;: &amp;#34;8d32a95ab9b4d92f6ff307d9721451707822d2eae3e07c5c605f0d5979a2e2210b5149487c4d1bedafa96628fcc3579b4842abfa156a963d7db0c15d8da32cc9&amp;#34;, &amp;#34;rsa_sig1&amp;#34;: &amp;#34;45e225f7532b25aa283f80b5166de185cff8b46fb3c9de982083b1ed4a7621c14d0ab541e945c31c9984f958d0b23331d6c636ba8c443941afa277dd2b00c9b7884b4bc9a55047b77305cc6061d9aa9e6be99b70f2f469f6c1accba77228ef129af79bb7f196176753ed27f8308a30b298c34bfc3503dce92f77f0ed8b6d16b6&amp;#34;, &amp;#34;rsa_sig2&amp;#34;: &amp;#34;56b9bac062a9a75b2db42b480e439927265a06b0815be14814f19cd27553a8bdd2815c1814a060fa25b9713b10516b57c9e1f399415492f1ac9a8795034ade99744237a6354d32c0e7330b0b0f52d237e7967863869cf9fdc387f90349c9fbffa15aa72c48ece92bbe59760f41606bfff28af9fdde8f275bf07379f798d98d4d&amp;#34;, &amp;#34;cipher&amp;#34;: &amp;#34;65312f30ef4f34edd32c11ce885c51279bdecd16168953733f04380eb1ed183542e745d630133c4c0c5ce7580bbfb90a347c387eb2743ffaeae5cb7a82058e0fb8a85f7aa392433dc12f0b78e9e0b577909353de84913a47895109de2019a3b88b72f03e13b16f7b092e7a428c664ed174b2cb63208b7a55e9d02a2c0f268d4e&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;There are 3 known, plaintext messages, $m_1$, $m_2$, and $m_3$. A p256 curve is used and a private key on the curve is generated. Then, a ECDSA signature is created from signing the sha256 hash of $m_1$. We are given this signature.&lt;/p&gt;
&lt;p&gt;Next, a prime $p$ is deterministically generated, using the public key on the curve, point $Q$. Then standard RSA follows, generating prime $q$, public key $n=pq$, and private key $d=e^{-1} \bmod(\phi{(n)})$. Signatures of $m_2$ and $m_3$ are created using the RSA private key, and we are given these signatures. The flag is then encrypted with the RSA key, and we are given the encrypted flag.&lt;/p&gt;
&lt;p&gt;The challenge is to recover both the ECC and RSA public keys, and decrypt the flag.&lt;/p&gt;
&lt;h3 id=&#34;recovering-ecc-public-key&#34;&gt;Recovering ECC Public Key&lt;/h3&gt;
&lt;p&gt;I searched online for recovering the public key from an ECDSA signature and found &lt;a href=&#34;https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work&#34;&gt;this&lt;/a&gt;, which you should read for more details, but essentially you can recover the public key given a signature $(r, s)$, by finding the two points $R$ and $\prime{R}$ with the same x coordinate as $r$, and calculating:&lt;/p&gt;
&lt;p&gt;$$
r^{-1}(sR - zG) \newline
r^{-1}(s\prime{R} - zG)
$$&lt;/p&gt;
&lt;p&gt;where $z$ is the message that was signed, and $G$ is the generator on the curve. As shown above this yields two points, one of which is the public key $Q$.&lt;/p&gt;
&lt;p&gt;We can do so using the sage code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# p-256 curve paramters from https://neuromancer.sk/std/nist/P-256&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;K &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GF(p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;E &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; EllipticCurve(K, (a, b))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;G &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; E(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_order(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r,s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(ec_sig[:&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;]), bytes_to_long(ec_sig[&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(MSG1_HASH&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digest())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r_inv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(r, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;order())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R, R_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lift_x(K(r), all&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Q_1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_inv &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (s&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;R &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;G)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Q_2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_inv &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (s&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;R_ &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;G)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;recovering-rsa-public-key&#34;&gt;Recovering RSA Public Key&lt;/h3&gt;
&lt;p&gt;We have two messages $m_2$ and $m_3$ that are signed with RSA, yielding $s_2$ and $s_3$. Searching online again I found &lt;a href=&#34;https://crypto.stackexchange.com/questions/26188/rsa-public-key-recovery-from-signatures&#34;&gt;this&lt;/a&gt; which states you can recover public modulus $n$ by computing $\gcd{(s_2^e - m_2, s_3^e - m_3)} = kn$ where $k$ is small.&lt;/p&gt;
&lt;p&gt;This makes sense as $m_2 = s_2^e \bmod{n}$ thus $m_2 = s_2^e - k_2n$ for some integer $k_2$, therefore we can GCD $m_2 - s_2^e = -k_2n$ and $m_3 - s_3^e = -k_3n$ to obtain a multiple of $n$.&lt;/p&gt;
&lt;p&gt;As $e = 65537$, this takes a while to compute, but after doing so we recover (a multiple of) the public modulus $n$.&lt;/p&gt;
&lt;p&gt;Note that $m_2$ is actually a transformed version of the plaintext message, as it is first hashed then some pkcs1_15 scheme is used to pad the message. This made it really annoying to get the message that was actually signed, so I directly edited the library code to print the message being signed, and ran the challenge script with a test flag.&lt;/p&gt;

  &lt;img src=&#34;./img/get_real_m.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;h3 id=&#34;getting-the-flag&#34;&gt;Getting the flag&lt;/h3&gt;
&lt;p&gt;Now that we have both the ECDSA and RSA pubkey, we can recover the flag. As mentioned before, one of the RSA primes are generated deterministically based on the ECDSA pubkey $Q$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_special_prime&lt;/span&gt;(b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt;(isPrime(t)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rsa_p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_special_prime(long_to_bytes(ec&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pointQ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;long_to_bytes(ec&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pointQ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;y))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So now that we recovered the pubkey, we can simply call this function to recover a prime. Even though we have 2 possible ECDSA pubkeys, we can check which one is correct by generating the 2 possible primes and using GCD with $n$.&lt;/p&gt;
&lt;p&gt;From there, it&amp;rsquo;s just simple RSA to generate the RSA private key and decrypt the flag.&lt;/p&gt;
&lt;p&gt;Solve script:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;719365842&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;719365842&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import Crypto.Hash.SHA256 as sha256
import Crypto.PublicKey.RSA as rsa
import Crypto.Cipher.PKCS1_OAEP as oaep
from Crypto.Util.number import *

## Generate RSA parameters
def generate_special_prime(b):
    t = bytes_to_long(b)
    while not(isPrime(t)):
        t &amp;#43;= 1
    return t

data = {&amp;#34;ec_sig&amp;#34;: &amp;#34;8d32a95ab9b4d92f6ff307d9721451707822d2eae3e07c5c605f0d5979a2e2210b5149487c4d1bedafa96628fcc3579b4842abfa156a963d7db0c15d8da32cc9&amp;#34;, &amp;#34;rsa_sig1&amp;#34;: &amp;#34;45e225f7532b25aa283f80b5166de185cff8b46fb3c9de982083b1ed4a7621c14d0ab541e945c31c9984f958d0b23331d6c636ba8c443941afa277dd2b00c9b7884b4bc9a55047b77305cc6061d9aa9e6be99b70f2f469f6c1accba77228ef129af79bb7f196176753ed27f8308a30b298c34bfc3503dce92f77f0ed8b6d16b6&amp;#34;, &amp;#34;rsa_sig2&amp;#34;: &amp;#34;56b9bac062a9a75b2db42b480e439927265a06b0815be14814f19cd27553a8bdd2815c1814a060fa25b9713b10516b57c9e1f399415492f1ac9a8795034ade99744237a6354d32c0e7330b0b0f52d237e7967863869cf9fdc387f90349c9fbffa15aa72c48ece92bbe59760f41606bfff28af9fdde8f275bf07379f798d98d4d&amp;#34;, &amp;#34;cipher&amp;#34;: &amp;#34;65312f30ef4f34edd32c11ce885c51279bdecd16168953733f04380eb1ed183542e745d630133c4c0c5ce7580bbfb90a347c387eb2743ffaeae5cb7a82058e0fb8a85f7aa392433dc12f0b78e9e0b577909353de84913a47895109de2019a3b88b72f03e13b16f7b092e7a428c664ed174b2cb63208b7a55e9d02a2c0f268d4e&amp;#34;}

MESSAGE1 = b&amp;#39;If a new source of energy is not found, no one is going to win this war&amp;#39;
MSG1_HASH = sha256.new(MESSAGE1)

ec_sig = bytes.fromhex(data[&amp;#34;ec_sig&amp;#34;])
s1 = int(data[&amp;#34;rsa_sig1&amp;#34;], 16)
s2 = int(data[&amp;#34;rsa_sig2&amp;#34;], 16)
enc_flag = bytes.fromhex(data[&amp;#34;cipher&amp;#34;])

# p-256 curve paramters from https://neuromancer.sk/std/nist/P-256
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff 
K = GF(p)
a = K(0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc)
b = K(0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b)
E = EllipticCurve(K, (a, b))
G = E(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)
E.set_order(0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * 0x1)

# part 1: recover ECC public key
r,s = bytes_to_long(ec_sig[:32]), bytes_to_long(ec_sig[32:])
z = bytes_to_long(MSG1_HASH.digest())

r_inv = pow(r, -1, E.order())
R, R_ = E.lift_x(K(r), all=True)

Q_1 = r_inv * (s*R - z*G)
Q_2 = r_inv * (s*R_ - z*G)

print(f&amp;#34;Recovered possible ECSDA pubkeys:&amp;#34;)
print(f&amp;#34;{Q_1 = }&amp;#34;)
print(f&amp;#34;{Q_2 = }&amp;#34;)

# part 2: recover RSA public key

e = 65537
# values from editing library src and printing msg before it got signed
# MESSAGE2 = b&amp;#39;Bah weep gragnah weep nini bong&amp;#39;
# MESSAGE3 = b&amp;#39;Freedom is the right of all sentient beings&amp;#39;
m2 = 5486124068793688683255936251187209270074392635932332070112001988456197381759672947165175699536362793613284725337872111744958183862744647903224103718245670299614498700710006264535421091908069935709303403272242499531581061652193706559968553759421347924920266204277973339410586176390872847811111144114590842
m3 = 5486124068793688683255936251187209270074392635932332070112001988456197381759672947165175699536362793613284725337872111744958183862744647903224103718245670299614498700710006264535421091908069935709303403272242499531581061652193643492425095701346333448554897794580398627955585138706133687412101835882486651

print(f&amp;#34;Recovering RSA pubkey...&amp;#34;)

kn = gcd(s1^e - m2, s2^e - m3)

print(f&amp;#34;Recovered RSA pubkey multiple {kn = }&amp;#34;)

# last part: decrypting flag

rsa_p_1 = generate_special_prime(long_to_bytes(int(Q_1.x()))&amp;#43;long_to_bytes(int(Q_1.y())))
rsa_p_2 = generate_special_prime(long_to_bytes(int(Q_2.x()))&amp;#43;long_to_bytes(int(Q_2.y())))

p = None
if gcd(rsa_p_1, kn) != 1:
    p = rsa_p_1
elif gcd(rsa_p_2, kn) != 1:
    p = rsa_p_2
else:
    print(&amp;#34;Something went wrong, neither primes are correct&amp;#34;)

# k*n = k*p*q
kq = kn // p
# get largest factor of kq which should be q
q = list(dict(factor(kq)).keys())[-1]

n = p*q
d = pow(e, -1, (p-1)*(q-1))

r = rsa.construct((int(n),int(e),int(d)))
decrypter = oaep.new(r)
flag = decrypter.decrypt(enc_flag)
print(f&amp;#34;{flag = }&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Flag: &lt;code&gt;cybears{D0nt_m4k3_pr1v4t3_publ1c_k3yz!}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;arpeeceethree---3-solves&#34;&gt;arpeeceethree - 3 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You hand over your identity parchment to the temple monk. He scrutinises it closely, looking for any signs of malintent.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python client.py -r arpeeceethree.chal.cybears.io:2323&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;There was a lot of source and dependencies to install for this challenge, but the vulnerability is actually very simple.&lt;/p&gt;
&lt;p&gt;We are provided with 3 files, &lt;code&gt;client.py&lt;/code&gt;, &lt;code&gt;server.py&lt;/code&gt; and &lt;code&gt;server.proto&lt;/code&gt;.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;349268715&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;349268715&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;client.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey


def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ECDH(curve=NIST256p)
    client_ephemeral_ecdh.generate_private_key()
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    s = remote(host, port)

    ## Create new user
    log.info(&amp;#34;Creating new user&amp;#34;)
    e = create_user()

    ## Register
    log.info(&amp;#34;Registering new user&amp;#34;)
    uid = register(s,e)

    ## Login
    log.info(&amp;#34;Logging in - part 1&amp;#34;)
    (sessionId, chal, sepk) = login(s, uid)
    log.info(&amp;#34;Logging in - part 2&amp;#34;)
    ceph = login2(s, e, sessionId, chal)

    ## Request message
    log.info(&amp;#34;Requesting message&amp;#34;)
    msg = request_msg(s, sessionId, uid, ceph, sepk)
    log.info(&amp;#34;message received: {}&amp;#34;.format(msg))


    s.close()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;927461358&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;927461358&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

# protoc -I=. --python_out=. ./server.proto
# socat -d TCP-LISTEN:2323,reuseaddr,fork EXEC:&amp;#34;python3 server_stdio_3.py&amp;#34;

from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey
import uuid

import logging
import os
import sys

from cybears import flag

#logging.root.setLevel(logging.DEBUG)
#logging.root.setLevel(logging.INFO)
logging.root.setLevel(logging.ERROR)

logger = logging.getLogger(&amp;#34;__name__&amp;#34;)

h1 = logging.StreamHandler(sys.stderr)
h1.setLevel(logging.DEBUG)
h2 = logging.StreamHandler(sys.stderr)
h2.setLevel(logging.INFO)

logger.addHandler(h1)
logger.addHandler(h2)


def send_message(msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to stdout &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    sys.stdout.buffer.write(mh.SerializeToString() &amp;#43; data)
    sys.stdout.flush()
    logging.info(&amp;#34;Sent msg over stdout...&amp;#34;)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None   

def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message():
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= sys.stdin.buffer.read(1)
        try: 
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e: 
            pass
    logging.debug(&amp;#34;header {}&amp;#34;.format(header))

    # Receive the message data
    data = sys.stdin.buffer.read(header.msglen)
    logging.debug(&amp;#34;received [{}]&amp;#34;.format(data))

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None: 
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            logging.debug(&amp;#34;msg {}&amp;#34;.format(msg))
            return msg
        except _DecodeError:
            return None
    else:
        return None

def handle_register_request(msg):
    logging.debug(&amp;#34;Got register request&amp;#34;)
    # validate request
    # check public key is on correct curve
    try:
        v = VerifyingKey.from_string(msg.clientPublicKey, NIST256p)
    except Exception as e:
        resp = spb.RegisterResponse()
        resp.type = spb.MSG_REGISTER_RESPONSE
        resp.uid = 0xff
        resp.status = spb.FAILURE
        send_message(resp) 
        logging.info(&amp;#34;FAILURE: User failed to registered with invalid pub key: {} and error {}&amp;#34;.format(msg.clientPublicKey,e))
        return spb.FAILURE

    # parse request
    uid = register_user(USERS, msg.name, msg.clientPublicKey)

    # send response
    resp = spb.RegisterResponse()
    resp.type = spb.MSG_REGISTER_RESPONSE
    resp.uid = uid
    resp.status = spb.SUCCESS
    send_message(resp) 
    logging.info(&amp;#34;SUCCESS: User registered with uid: {}&amp;#34;.format(uid))

    return spb.SUCCESS

def handle_login_request(SESSION, msg):
    logging.debug(&amp;#34;Got Login request&amp;#34;)
    resp = spb.LoginResponse()
    resp.type = spb.MSG_LOGIN_RESPONSE

    # validate request
    if msg.uid &amp;gt; len(USERS) or msg.uid == 0: 
        logging.info(&amp;#34;ERROR: invalid uid&amp;#34;)
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        resp.challenge = b&amp;#39;&amp;#39;
        resp.ephemeralServerPublicKey = b&amp;#39;&amp;#39;
        send_message(resp)
        return spb.FAILURE

    requested_user = USERS[msg.uid - 1]

    # parse request
    
    # send response
    challenge = os.urandom(32) # random 32-byte challenge to sign    
    server_ephemeral_ecdh = ECDH(curve=NIST256p)
    server_ephemeral_ecdh.generate_private_key()
    server_ephemeral_public_key = server_ephemeral_ecdh.get_public_key()
    
    sessionId = str(uuid.uuid4()).encode()

    resp.status = spb.SUCCESS
    resp.sessionId = sessionId
    resp.challenge = challenge
    resp.ephemeralServerPublicKey = server_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    SESSIONS[sessionId] = {&amp;#39;completed_challenge&amp;#39;:False, &amp;#39;challenge&amp;#39;:challenge, &amp;#39;ephemeral_ecdh&amp;#39;:server_ephemeral_ecdh, &amp;#39;uid&amp;#39;:msg.uid}
    logging.debug(&amp;#34;New session created {}&amp;#34;.format(SESSIONS[sessionId]))
    logging.info(&amp;#34;SUCCESS: User correctly requested login with uid: {}&amp;#34;.format(msg.uid))
    send_message(resp)

    return spb.SUCCESS

def verify_challenge(chal, chalResponse, public_key):

    try:
        public_key.verify(chalResponse, data=chal)
    except ecdsa.BadSignatureError:
        return False

    return True

def handle_login_challenge_request(SESSION, USERS, msg):
    logging.debug(&amp;#34;Got Login Challenge request&amp;#34;)
    resp = spb.LoginChallengeResponse()
    resp.type = spb.MSG_LOGIN_CHALLENGE_RESPONSE
        
    # validate request
        # sessionId in SESSIONS?
    if msg.sessionId not in SESSIONS:
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: User send invalid sessionId: {}&amp;#34;.format(msg.sessionId))
        send_message(resp)
        return spb.FAILURE

    uid = SESSIONS[msg.sessionId][&amp;#39;uid&amp;#39;]
    requested_user = USERS[uid - 1]
    logging.debug(&amp;#34;requested user {}: {}&amp;#34;.format(uid,requested_user))
    clientPubKey = VerifyingKey.from_string(requested_user[&amp;#39;pubkey&amp;#39;], NIST256p) #already validated 
    clientRole = requested_user[&amp;#39;role&amp;#39;]

    sessionId = msg.sessionId
        # verify challenge
    if not verify_challenge(SESSION[sessionId][&amp;#39;challenge&amp;#39;], msg.challengeResponse, clientPubKey):
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: User failed challenge: {}&amp;#34;.format(msg.challenge))
        send_message(resp)
        return spb.FAILURE

        # ensure ephem client key is on curve
    try:
        clientEphemPubKey = VerifyingKey.from_string(msg.ephemeralClientPublicKey, NIST256p)
    except Exception as e:
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: Invalid client ephemeral public key: {}&amp;#34;.format(msg.ephemeralClientPublicKey))
        send_message(resp)
        return spb.FAILURE

    # action request
    server_ephemeral_ecdh = SESSIONS[sessionId][&amp;#39;ephemeral_ecdh&amp;#39;]
    server_ephemeral_ecdh.load_received_public_key(clientEphemPubKey)
    shared_secret = server_ephemeral_ecdh.generate_sharedsecret_bytes()

    token  = shared_secret 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(clientRole) 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid) 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId

    # send response
    resp.status = spb.SUCCESS
    resp.sessionId = sessionId

    SESSIONS[sessionId][&amp;#39;completed_challenge&amp;#39;] = True
    SESSIONS[sessionId].update( {&amp;#39;client_token&amp;#39;:token} )
    logging.info(&amp;#34;SUCCESS: User correctly completed challenge with uid: {}&amp;#34;.format(uid))
    send_message(resp)

    return spb.SUCCESS

def handle_message_request(SESSIONS, msg):
    logging.debug(&amp;#34;Got message request&amp;#34;)
    resp = spb.MessageResponse()
    resp.type = spb.MSG_MESSAGE_RESPONSE
    # validate request
    if msg.sessionId not in SESSIONS:
        resp.status = spb.FAILURE
        resp.encMsg = b&amp;#39;&amp;#39;
        resp.encMsgTag = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;ERROR: Invalid sessionId: {}&amp;#34;.format(sessionId)) 
        send_message(resp)
        return spb.FAILURE

    # parse request
    if SESSIONS[msg.sessionId][&amp;#39;completed_challenge&amp;#39;] == False or &amp;#39;client_token&amp;#39; not in SESSIONS[msg.sessionId]:
        resp.status = spb.FAILURE
        resp.encMsg = b&amp;#39;&amp;#39;
        resp.encMsgTag = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;ERROR: challenge not completed for this session&amp;#34;)
        send_message(resp)
        return spb.FAILURE

    token = SESSIONS[msg.sessionId][&amp;#39;client_token&amp;#39;]
    role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
    
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2) 

    if role == spb.ADMIN:
        plain = b&amp;#39;Congratulations - here is your flag: &amp;#39; &amp;#43; flag
    else:
        plain = b&amp;#39;Welcome USER!&amp;#39;

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    (cipher, tag) = a.encrypt_and_digest(plain)

    # send response    

    resp.status = spb.SUCCESS
    resp.encMsg = cipher
    resp.encMsgTag = tag
    logging.info(&amp;#34;SUCCESS: message sent&amp;#34;) 
    send_message(resp)

    return spb.SUCCESS

def register_user(USERS, name, pubkey, role = spb.USER):
    len_db = len(USERS)
    uid = len_db &amp;#43; 1
    USERS.append( {&amp;#34;name&amp;#34;: name, &amp;#34;pubkey&amp;#34;: pubkey, &amp;#34;uid&amp;#34;:uid, &amp;#34;role&amp;#34;: role} )
    logging.debug(&amp;#34;users = {}&amp;#34;.format(USERS))
    return uid

if __name__ == &amp;#34;__main__&amp;#34;:
    
    logging.debug(&amp;#34;creating sessions database&amp;#34;)
    # create session database
    SESSIONS = {}

    logging.debug(&amp;#34;creating admin user&amp;#34;)
    # create admin user
    server_ecdh = ECDH(curve=NIST256p)
    server_ecdh.generate_private_key()
    server_public_key = server_ecdh.get_public_key()
    spub = server_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)
    
    logging.debug(&amp;#34;creating user database&amp;#34;)
    # create user database
    USERS = []
    register_user(USERS, b&amp;#34;admin&amp;#34;, spub, role = spb.ADMIN)  


    logging.debug(&amp;#34;starting message loop&amp;#34;)
    while True:
       m  = recv_message()
       if m != None:
           if m.type == spb.MSG_REGISTER_REQUEST:
               handle_register_request(m)
               continue
           elif m.type == spb.MSG_LOGIN_REQUEST:
               ret = handle_login_request(SESSIONS, m)
               continue
           elif m.type == spb.MSG_LOGIN_CHALLENGE:
               ret = handle_login_challenge_request(SESSIONS, USERS, m)
               continue
           elif m.type == spb.MSG_MESSAGE_REQUEST:
               handle_message_request(SESSIONS, m)
               continue
           else:
               logging.error(&amp;#34;Unknown message type, exitting...&amp;#34;)
               exit(0)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;382547961&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;382547961&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;proto&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.proto&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-proto&#34; &gt;&lt;code&gt;
syntax = &amp;#34;proto2&amp;#34;;

package server;

enum MessageType {
	MSG_LOGIN_REQUEST=0;
	MSG_LOGIN_RESPONSE=1;
	MSG_LOGIN_CHALLENGE=2;
	MSG_LOGIN_CHALLENGE_RESPONSE=3;
	MSG_REGISTER_REQUEST=4;
	MSG_REGISTER_RESPONSE=5;
	MSG_MESSAGE_REQUEST=6;
	MSG_MESSAGE_RESPONSE=7;
}

enum Status {
		SUCCESS = 0;
		FAILURE = 1;
	}

enum Role {
		USER = 0;
		ADMIN = 1;
	}

message MessageHeader {
	required uint32 msglen = 1;
	required MessageType type = 2;
}

message RegisterRequest {
	required MessageType type = 1;
	required bytes name = 2;
	required bytes clientPublicKey = 3;
}

message RegisterResponse {
	required MessageType type = 1;
	required uint32 uid = 2;
	required Status status = 3;
}

message LoginRequest {
	required MessageType type = 1;
	required uint32 uid = 2;
}

message LoginResponse {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required bytes challenge = 3;
	required bytes ephemeralServerPublicKey = 4;
	required Status status = 5;
}

message LoginChallenge {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required bytes challengeResponse = 3;
	required bytes ephemeralClientPublicKey = 4;
}

message LoginChallengeResponse {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required Status status = 3; 
}
	
message MessageRequest {
	required MessageType type = 1;
	required bytes sessionId = 3;
}

message MessageResponse {
	required MessageType type = 1;
	required Status status = 2;
	required bytes encMsg = 3;
	required bytes encMsgTag = 4;
}

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;We also need to run the command in the server file &lt;code&gt;protoc -I=. --python_out=. ./server.proto&lt;/code&gt;, to generate &lt;code&gt;server_pb2.py&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s a lot of code to go through, but I&amp;rsquo;ll try to explain the relevant parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The server handles registering new users and logging in.&lt;/li&gt;
&lt;li&gt;To register, the client provides a public key, which must be on the NIST256p curve, then the public key is stored alongside their user id (&lt;code&gt;uid&lt;/code&gt;), name and role.&lt;/li&gt;
&lt;li&gt;To login, there are two steps.
&lt;ul&gt;
&lt;li&gt;Firstly, the server generates a random challenge and public key, and sends it to us.&lt;/li&gt;
&lt;li&gt;Then we must sign the challenge with our public key and send the signature to the server, which checks if the signature is valid. If so, the server calculates the shared secret with its private key and our public key. The server then stores our info (shared secret, role, uid, session id) in a &lt;code&gt;token&lt;/code&gt;, and sends us our session id.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We can also request a message, providing a session id. The server retrieves the token corresponding to our session, and checks if we have the admin role. If we do, we get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don&amp;rsquo;t think there&amp;rsquo;s anything wrong with the procedures described above, but I noticed our info was being stored in the token in a very bad way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle_login_challenge_request&lt;/span&gt;(SESSION, USERS, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shared_secret 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(clientRole) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(uid) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sessionId
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server then uses &lt;code&gt;|&lt;/code&gt; as a delimeter to seperate our info later on:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle_message_request&lt;/span&gt;(SESSIONS, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SESSIONS[msg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sessionId][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;client_token&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    role &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(token&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; role &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ADMIN:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Congratulations - here is your flag: &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Welcome USER!&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;bytes_to_long(token.split(b&#39;|&#39;)[1])&lt;/code&gt; retrieves the role by splitting with &lt;code&gt;|&lt;/code&gt; and getting the second element. This means if we can inject a &lt;code&gt;|&lt;/code&gt; character into the token somehow, we could trick it into thinking we have the admin role. However, it seems like we can&amp;rsquo;t control any info in the token, which are &lt;code&gt;shared_secret&lt;/code&gt;, &lt;code&gt;clientRole&lt;/code&gt;, &lt;code&gt;uid&lt;/code&gt; and &lt;code&gt;sessionId&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But it turns out, the admin role &lt;code&gt;spb.ADMIN&lt;/code&gt; is actually just the number &lt;code&gt;1&lt;/code&gt;, and since &lt;code&gt;shared_secret&lt;/code&gt; is essentially random bytes, there is a chance that it could contain the &lt;code&gt;|&lt;/code&gt; character.&lt;/p&gt;
&lt;p&gt;This is what &lt;code&gt;token&lt;/code&gt; usually looks like:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_secret   |role| uid| session id
...\xc3\x87\xf0|\x00|\x02|c8e9fd09-0cb1-4d6c-88d3-53596a98fccb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if &lt;code&gt;shared_secret&lt;/code&gt; happened to end with &lt;code&gt;|\x01&lt;/code&gt;?&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_secret   |role| uid| session id
...\xc3\x87|\x01|\x00|\x02|c8e9fd09-0cb1-4d6c-88d3-53596a98fccb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the second element when splitting by &lt;code&gt;|&lt;/code&gt; is &lt;code&gt;\x01&lt;/code&gt;, the admin role!&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;shared_secret&lt;/code&gt; is basically random bytes, there is a 1 in $256^2$ which is 1 in 65536 chance that it ends with &lt;code&gt;|\x01&lt;/code&gt; in which the server thinks we&amp;rsquo;re admin, giving us the flag. This actually meant if you ran the client script, unmodified, enough times, you would get the flag. So I did pretty much that, with slight optimizations.&lt;/p&gt;
&lt;p&gt;65536 is not a lot, but probably not a good idea connecting to the server that many times. Luckily, we can create users and login multiple times over the same connection, so we didn&amp;rsquo;t have to open many connections.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(host, port)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; create_user()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; register(s,e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; tqdm(range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (sessionId, chal, sepk) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; login(s, uid)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ceph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; login2(s, e, sessionId, chal)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# calculate shared secret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        server_ephemeral_public_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; VerifyingKey&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_string(sepk, NIST256p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ceph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_received_public_key(server_ephemeral_public_key)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        shared_secret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ceph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;generate_sharedsecret_bytes()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# if shared secret ends with |\x01 , request for the flag&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# (we aren&amp;#39;t explicitly checking for |\x01 because there is a chance&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# it could end with |\x00\x01 etc., which is still valid, slightly increasing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# our chances)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        token  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shared_secret
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;USER)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        role &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(token&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; role &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ADMIN:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request_msg(s, sessionId, uid, ceph, sepk)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Got the flag: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;msg &lt;span style=&#34;color:#e6db74&#34;&gt;= }&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            exit()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After ~30 minutes and running multiple instances, we actually got the flag: &lt;code&gt;cybears{Wh1ch_pr0gr4m_d0_j3d1_us3_t0_op3n_PDF_f1l35?Ad0b3_W4n_K3n0b1!}&lt;/code&gt;&lt;/p&gt;

  &lt;img src=&#34;./img/got_the_fricking_flag.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;Full solve script:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;467295183&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;467295183&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;remote_brute.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
&amp;#39;&amp;#39;&amp;#39;

python3 client.py -r arpeeceethree.chal.cybears.io:2323



&amp;#39;&amp;#39;&amp;#39;

from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey



def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ECDH(curve=NIST256p)
    client_ephemeral_ecdh.generate_private_key()
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    # log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    # log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    # log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

from tqdm import tqdm

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    logging.root.setLevel(logging.ERROR)

    while True:
        s = remote(host, port)
        e = create_user()
        uid = register(s,e)
        for i in tqdm(range(0, 1000)):
            (sessionId, chal, sepk) = login(s, uid)
            ceph = login2(s, e, sessionId, chal)

            # calculate shared secret
            server_ephemeral_public_key = VerifyingKey.from_string(sepk, NIST256p)
            ceph.load_received_public_key(server_ephemeral_public_key)
            shared_secret = ceph.generate_sharedsecret_bytes()

            # if shared secret ends with |\x01 , request for the flag
            # (we aren&amp;#39;t explicitly checking for |\x01 because there is a chance
            # it could end with |\x00\x01 etc., which is still valid, slightly increasing
            # our chances)
            token  = shared_secret
            token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
            role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
            if role == spb.ADMIN:
                msg = request_msg(s, sessionId, uid, ceph, sepk)
                print(f&amp;#34;Got the flag: {msg = }&amp;#34;)
                exit()
            else:
                continue

        s.close()


&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;h3 id=&#34;a-better-solution&#34;&gt;A better solution&lt;/h3&gt;
&lt;p&gt;Even though it worked, I thought that brute forcing on remote was probably unintended, and there should&amp;rsquo;ve been some way to brute force locally, but I couldn&amp;rsquo;t see how. Turns out my reading comprehension failed me again - I thought that the server uses the our public key we provided when registering to calculate the shared secret, but actually we provide it with another, ephemeral public key for the session when logging in.&lt;/p&gt;
&lt;p&gt;Since the server provides us with its ephermeral public key alongside the challenge, we can generate private keys and calculate the shared secret locally. If the shared secret ends with &lt;code&gt;|\x01&lt;/code&gt;, we use that public key and send it to the server, which should compute the same shared secret, and give us the flag. This way, we don&amp;rsquo;t need to brute force remote and can get the flag quickly in just one attempt.&lt;/p&gt;
&lt;p&gt;Better solve script:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;532786419&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;532786419&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
&amp;#39;&amp;#39;&amp;#39;

python3 client.py -r arpeeceethree.chal.cybears.io:2323



&amp;#39;&amp;#39;&amp;#39;

from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey



def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, ephemeral_ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ephemeral_ecdh
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    # log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    # log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    # log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

from tqdm import tqdm

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    logging.root.setLevel(logging.ERROR)

    s = remote(host, port)

    # register
    e = create_user()
    uid = register(s,e)

    # login step 1
    (sessionId, chal, sepk) = login(s, uid)
    server_ephemeral_ecdh_pubkey = VerifyingKey.from_string(sepk, NIST256p)

    # generate private keys until shared secret is what we want
    while True:
        client_ephemeral_ecdh = ECDH(curve=NIST256p)
        client_ephemeral_ecdh.generate_private_key()
        
        # calculate shared secret
        client_ephemeral_ecdh.load_received_public_key(server_ephemeral_ecdh_pubkey)
        shared_secret = client_ephemeral_ecdh.generate_sharedsecret_bytes()
        
        token = shared_secret
        token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
        role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
        if role == spb.ADMIN:
            break

    login2(s, e, client_ephemeral_ecdh, sessionId, chal)
    
    msg = request_msg(s, sessionId, uid, client_ephemeral_ecdh, sepk)
    print(f&amp;#34;Got the flag: {msg = }&amp;#34;)



&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;BSides Canberra 2024 was again, a great conference, and &lt;a href=&#34;https://x.com/cybearsctf&#34;&gt;Cybears&lt;/a&gt; hosted another fun CTF! I believe it&amp;rsquo;s truely one of the best conferences out there, and I&amp;rsquo;ll definitely be coming back next year!&lt;/p&gt;
&lt;p&gt;I was able to attend thanks to the &lt;a href=&#34;https://www.bsidesau.com.au/assistance.html&#34;&gt;Assistance Program&lt;/a&gt;, which covered my flights and hotel, so special thanks to Kylie, Silvio and Danielle for making this possible!&lt;/p&gt;
&lt;p&gt;For coming 2nd place, we won $500, and a Dungeons and Dragons lego set! We, alongside the other winning teams, skateboarding dogs and French Roomba, all decided to donate our prize money to the Assistance Program, and we hope this helps other people attend the conference in the future! We&amp;rsquo;re keeping the lego set though :P&lt;/p&gt;
&lt;p&gt;Btw, if you spotted any errors/typos in the blog, or have questions, feel free to DM/ping me on discord &lt;code&gt;thesavageteddy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;teddy / TheSavageTeddy&lt;/li&gt;
&lt;/ul&gt;

  &lt;img src=&#34;./img/conference.jpg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


</content>
    </item>
    
    <item>
      <title>CTF Writeups - p4CTF Finals 2023 in Poland</title>
      <link>https://TheSavageTeddy.github.io/featured/p4ctf-finals-2023/</link>
      <pubDate>Thu, 22 Jun 2023 23:20:00 +1000</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/featured/p4ctf-finals-2023/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;p4CTF Finals was an onsite event held in June 2023 in Katowice, Poland. Together with Emu Exploit, I qualified for event in the p4CTF qualifiers and had the opportunity to go to Poland to meet and compete with many top teams in the world, including &lt;a href=&#34;https://twitter.com/FlatNetworkOrg&#34;&gt;&lt;code&gt;The Flat Network Society&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/DragonSectorCTF&#34;&gt;&lt;code&gt;Dragon Sector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/justCatTheFish&#34;&gt;&lt;code&gt;justCatTheFish&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/hxpctf&#34;&gt;&lt;code&gt;hxp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/0rganizers&#34;&gt;&lt;code&gt;0rganizers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/allesctf&#34;&gt;&lt;code&gt;ALLES&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/fluxfingers&#34;&gt;&lt;code&gt;FluxFingers&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Before we could compete in the event, we had to first get to Poland, which proved to be a pain as our travel time was 50 hours - 30 hours across three flights to Paris, and 20 hours on the bus to Katowice. However, it was definetely worth the time, as we got to also see some tourist attractions in Paris!&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;p4CTF Finals was an onsite event held in June 2023 in Katowice, Poland. Together with Emu Exploit, I qualified for event in the p4CTF qualifiers and had the opportunity to go to Poland to meet and compete with many top teams in the world, including &lt;a href=&#34;https://twitter.com/FlatNetworkOrg&#34;&gt;&lt;code&gt;The Flat Network Society&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/DragonSectorCTF&#34;&gt;&lt;code&gt;Dragon Sector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/justCatTheFish&#34;&gt;&lt;code&gt;justCatTheFish&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/hxpctf&#34;&gt;&lt;code&gt;hxp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/0rganizers&#34;&gt;&lt;code&gt;0rganizers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/allesctf&#34;&gt;&lt;code&gt;ALLES&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/fluxfingers&#34;&gt;&lt;code&gt;FluxFingers&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Before we could compete in the event, we had to first get to Poland, which proved to be a pain as our travel time was 50 hours - 30 hours across three flights to Paris, and 20 hours on the bus to Katowice. However, it was definetely worth the time, as we got to also see some tourist attractions in Paris!&lt;/p&gt;

  &lt;img src=&#34;./img/emu_paris.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; max-height: 40em&#34;  /&gt;


&lt;p&gt;Also, thanks to the &lt;a href=&#34;https://twitter.com/p4_team&#34;&gt;p4CTF team&lt;/a&gt; for hosting an amazing event, and our sponsors who made the trip possible!&lt;/p&gt;
&lt;p&gt;Below are writeups for some challenges I solved during the 24h CTF, which were quite unique!&lt;/p&gt;
&lt;p&gt;For example, for sanity check, you had to go to the p4 organiser&amp;rsquo;s desk and eat (edible) bugs in order to obtain the paper containing network credentials for some of the challenges, and the flag was &lt;code&gt;p4{eat-bugs-gain-sanity}&lt;/code&gt; which I thought was quite funny. The bugs were crunchy.&lt;/p&gt;
&lt;h1 id=&#34;challenge-overview&#34;&gt;Challenge Overview&lt;/h1&gt;
&lt;p&gt;There were a total of 18 challenges - I mostly solved crypto, and got a funny unintended solution on a misc. Below are writeups of some of these challenges:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/p4ctf-finals-2023/#pallas-crypto---12-solves&#34;&gt;Pallas&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;12&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/p4ctf-finals-2023/#aes_observed-crypto---6-solves&#34;&gt;aes_observed&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;6&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/p4ctf-finals-2023/#pepega-packets-misc---5-solves&#34;&gt;Pepega Packets&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;misc&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;
&lt;h1 id=&#34;pallas-crypto---12-solves&#34;&gt;Pallas (crypto) - 12 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Tell me my secret&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are given python source &lt;code&gt;task.py&lt;/code&gt; and the output &lt;code&gt;output.txt&lt;/code&gt;.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;task.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *

from sec import secret
print(len(secret))

text   = b&amp;#34;The Pallas&amp;#39;s cat is a highly specialised predator of small mammals, which it catches by stalking or ambushing near exits of burrows.&amp;#34;

def bits_to_bytes(l):
	l = [str(f) for f in l]
	l=&amp;#34;&amp;#34;.join(l)
	final = [l[i * 8:(i &amp;#43; 1) * 8] for i in range((len(l) &amp;#43; 8 - 1) // 8 )]
	final = [int(x,2) for x in final]
	return bytes(final)

def bytes_to_bits(bb):
	r = &amp;#34;&amp;#34;
	for c in bb:
		r &amp;#43;= bin(c)[2:].rjust(8,&amp;#34;0&amp;#34;)
	r= list(map(int, r))
	return r

def my_crypto_inner(text, secret):
	tl = len(text)
	sl = len(secret)
	enc = [0]*len(text)
	for i in range(tl):
		enc[i]=text[i]
		enc[i]^=secret[i % sl]
		for div in range(1, tl):
			if i%div == 0:
				enc[i] ^= enc[(i-div) % sl]
			if i&amp;gt;0 and div%i == 0:
				enc[i] ^= text[(i-div) % sl]
	return enc

def my_crypto(text, secret):
	text = bytes_to_bits(text)
	secret = bytes_to_bits(secret)
	res = my_crypto_inner(text,secret)
	return bits_to_bytes(res)

encrypted = my_crypto(text,secret)
print(encrypted)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;&lt;code&gt;output.txt&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xce\x80&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86\x8b\xbe\x00\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa7&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;M&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x1f\xe8\x87\x8e\xa3\xec&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x8d\x8a\xbd\xd4\xe7\x92&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa1\x8c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;w&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;F&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x06\x8a\xa8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa6\xcd&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xaf\xce\xbc\x90&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xc4\r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xac\xb1&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ng&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd5\x88\\\x07\xa9&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;z&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x8d\xc2\x9f\x9c\x89\xf8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x87&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Ut&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xf5\xdc\xdd&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;a9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe0\xc5\xa0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb8\xf6\xbe\n\xb1\xd0\xdc&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd6\xfc\x15\x13\xbf&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xbf&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x94\x0e\x98\x9a\x12\xd0\x9e\xdf\xba&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd8\x8b\x0e&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x87&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb3\xd6\xcd\xef\x92\xa1\xa3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb4&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\xdb&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;w&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{DE&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The main encryption function is &lt;code&gt;my_crypto_inner(text, secret)&lt;/code&gt;, which takes in 2 arguments - the text and the secret. We are given the text, and our goal is to recover the secret which is the flag.&lt;/p&gt;
&lt;p&gt;Upon some testing, I noticed that the encryption of each byte seemed to be independent of other bytes - that is, there was no shuffling around within the encryption.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ciphertext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xce\x80&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86\x8b\xbe\x00\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa7&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;M&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x1f\xe8\x87\x8e\xa3\xec&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x8d\x8a\xbd\xd4\xe7\x92&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa1\x8c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;w&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;F&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x06\x8a\xa8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa6\xcd&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xaf\xce\xbc\x90&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xc4\r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xac\xb1&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ng&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd5\x88\\\x07\xa9&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;z&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x8d\xc2\x9f\x9c\x89\xf8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x87&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Ut&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xf5\xdc\xdd&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;a9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe0\xc5\xa0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb8\xf6\xbe\n\xb1\xd0\xdc&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd6\xfc\x15\x13\xbf&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xbf&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x94\x0e\x98\x9a\x12\xd0\x9e\xdf\xba&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd8\x8b\x0e&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x87&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb3\xd6\xcd\xef\x92\xa1\xa3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb4&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\xdb&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;w&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{DE&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;p4{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# flag format&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flag&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ljust(&lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;?&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ind &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;encrypted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; my_crypto(text,flag)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(encrypted[:&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(ciphertext[:&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running the script above gave the output&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xce\x80\x06&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xfc\r\xae\xd6&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;W&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xce\x80&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86\x8b\xbe\x00\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;I&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice how the first 3 bytes &lt;code&gt;_\xce\x80&lt;/code&gt; are the same, as we entered the first 3 bytes correct (&lt;code&gt;p4{&lt;/code&gt; flag format)! This means we can recover the flag with a brute force approach, by appending a character to the end and checking if the encrypted matches the ciphertext at that index.&lt;/p&gt;
&lt;p&gt;For example, we can try encrypting &lt;code&gt;p4{a&lt;/code&gt;, &lt;code&gt;p4{b&lt;/code&gt; etc, and if the output at that index &lt;code&gt;3&lt;/code&gt; matched the given ciphertext at the same index, it would be the correct letter!&lt;/p&gt;
&lt;p&gt;We can automate this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; string
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ascii_letters &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; string&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digits &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;_!@#$%^&amp;amp;*(),./&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encode()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ciphertext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xce\x80&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86\x8b\xbe\x00\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa7&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;M&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x1f\xe8\x87\x8e\xa3\xec&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x8d\x8a\xbd\xd4\xe7\x92&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa1\x8c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;w&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x15&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;F&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x06\x8a\xa8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xa6\xcd&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xaf\xce\xbc\x90&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;go&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xc4\r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xac\xb1&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ng&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd5\x88\\\x07\xa9&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;z&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x8d\xc2\x9f\x9c\x89\xf8&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x87&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Ut&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xf5\xdc\xdd&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;a9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xe0\xc5\xa0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb8\xf6\xbe\n\xb1\xd0\xdc&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd6\xfc\x15\x13\xbf&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xbf&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x94\x0e\x98\x9a\x12\xd0\x9e\xdf\xba&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xd8\x8b\x0e&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x87&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb3\xd6\xcd\xef\x92\xa1\xa3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xb4&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\xdb&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;w&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{DE&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;p4{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# known flag format&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ind &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(flag) &lt;span style=&#34;color:#75715e&#34;&gt;# index we are brute forcing at&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; cs:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flag&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;bytes([c])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        encrypted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; my_crypto(text,temp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ljust(&lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;?&amp;#34;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ciphertext[ind] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; encrypted[ind]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flag&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;bytes([c])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ind&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;found char &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;bytes([c])&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, current flag: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;flag&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(flag&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode())
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this, we slowly but surely recover the full flag: &lt;code&gt;p4{It_4ls0_pu1ls_0ut_rodeNts_with_ITs_pawsFromShallowBurrows.}&lt;/code&gt;&lt;/p&gt;

  &lt;img src=&#34;./img/pallas-solve.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;Full solve script:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;solve.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *

#from sec import secret
#print(len(secret))

text   = b&amp;#34;The Pallas&amp;#39;s cat is a highly specialised predator of small mammals, which it catches by stalking or ambushing near exits of burrows.&amp;#34;

def bits_to_bytes(l):
	l = [str(f) for f in l]
	l=&amp;#34;&amp;#34;.join(l)
	final = [l[i * 8:(i &amp;#43; 1) * 8] for i in range((len(l) &amp;#43; 8 - 1) // 8 )]
	final = [int(x,2) for x in final]
	return bytes(final)

def bytes_to_bits(bb):
	r = &amp;#34;&amp;#34;
	for c in bb:
		r &amp;#43;= bin(c)[2:].rjust(8,&amp;#34;0&amp;#34;)
	r= list(map(int, r))
	return r

def my_crypto_inner(text, secret):
	tl = len(text)
	sl = len(secret)
	enc = [0]*len(text)
	for i in range(tl):
		enc[i]=text[i]
		enc[i]^=secret[i % sl]
		for div in range(1, tl):
			if i%div == 0:
				enc[i] ^= enc[(i-div) % sl]
			if i&amp;gt;0 and div%i == 0:
				enc[i] ^= text[(i-div) % sl]
	return enc

def my_crypto(text, secret):
	text = bytes_to_bits(text)
	secret = bytes_to_bits(secret)
	res = my_crypto_inner(text,secret)
	return bits_to_bytes(res)

import string

cs = string.ascii_letters &amp;#43; string.digits &amp;#43; &amp;#34;{}_!@#$%^&amp;amp;*(),./&amp;#34;
cs = cs.encode()

ciphertext = b&amp;#39;_\xce\x80^\x86\x8b\xbe\x00\x15I\xa7]\x86M\x1f\xe8\x87\x8e\xa3\xec_\x8d\x8a\xbd\xd4\xe7\x923\xa1\x8cw\x15F\x06\x8a\xa87\xa6\xcd)/\xaf\xce\xbc\x90go\xc4\r(\xac\xb1ng\xd5\x88\\\x07\xa9z\\G\x8d\xc2\x9f\x9c\x89\xf8r\x87Ut\xf5\xdc\xdda9\xe0\xc5\xa0G\xb8\xf6\xbe\n\xb1\xd0\xdc-\xd6\xfc\x15\x13\xbf}\xbf5\xb0S\x94\x0e\x98\x9a\x12\xd0\x9e\xdf\xba3\xd8\x8b\x0eR\x87$\xb3\xd6\xcd\xef\x92\xa1\xa3|\xb4-\n\xdbw\x86{DE&amp;#39;

flag = b&amp;#34;p4{&amp;#34; # known flag format
ind = len(flag) # index we are brute forcing at
while True:
    for c in cs:
        temp = flag&amp;#43;bytes([c])
        encrypted = my_crypto(text,temp.ljust(62,b&amp;#34;?&amp;#34;))
        if ciphertext[ind] == encrypted[ind]:
            flag&amp;#43;=bytes([c])
            ind&amp;#43;=1
            print(f&amp;#34;found char {bytes([c]).decode()}, current flag: {flag.decode()}&amp;#34;)
            break
    else:
	    break

print(flag.decode())

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h1 id=&#34;aes_observed-crypto---6-solves&#34;&gt;aes_observed (crypto) - 6 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;We have managed to get a person near our enemies encryption box.&lt;br&gt;
He actions are limited but he can run some encryptions for us and percsely measure voltage just after sbox.&lt;br&gt;
Can we do something with this information that would help us to recover some other plaintexts?&lt;br&gt;
HINT: the Key is a flag.&lt;br&gt;
&lt;code&gt;nc aes-observed.zajebistyc.tf 9999&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are only given a server to connect to, which responds with 50 plaintext to voltage pairs.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Plaintext                                                        Voltage
78a41912ae910166f57e6f1a46df63ee3a434860e116f5343d111181e657cc5c 2.512
5f55d8fdb3ab5881554eadda588587c053f32b3abf282557b8dff50d03d5656a 2.418
etc...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The challenge name &lt;code&gt;aes_observed&lt;/code&gt; hints to these plaintexts being encrypted with AES, and the given voltage suggests we need to perform an AES &lt;a href=&#34;https://en.wikipedia.org/wiki/Side-channel_attack&#34;&gt;side-channel attack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are 2 main side channel attacks given voltages for RSA - Differential Power Analysis (DPA) and Correlation Power Analysis (CPA). To be honest, I have absolutely no idea how to perform these attacks.&lt;/p&gt;
&lt;p&gt;However, I remembered that in PicoCTF 2023 there was a very similar challenge series named &lt;code&gt;Power Analysis&lt;/code&gt;, which also featured RSA side-channel attacks.&lt;/p&gt;
&lt;p&gt;Searching for writeups on it, I found &lt;a href=&#34;https://eshard.com/posts/pico-ctf-power-analysis-challenges&#34;&gt;this article&lt;/a&gt;, where their writeup for &lt;code&gt;PowerAnalysis: Part 1&lt;/code&gt; proved to be extremely helpful.&lt;/p&gt;

  &lt;img src=&#34;./img/cpa-blog.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;There are a few differences between that challenge and the one we are trying to solve:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we are given less samples (50 instead of 500)&lt;/li&gt;
&lt;li&gt;the plaintexts are longer (32 bytes instead of 16)&lt;/li&gt;
&lt;li&gt;the key we are trying to recover is longer (also 32 bytes instead of 16), but I didn&amp;rsquo;t know this until later on&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can easily solve the first issue by connecting multiple times to the server and gathering a large number of samples, and for the second issue, since AES block sizes are usually 16 bytes, I simply cut off the last 16 bytes of the 32 bytes for now.&lt;/p&gt;
&lt;p&gt;Here is the code to collect the samples:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; pwn &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plaintexts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;leaks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;aes-observed.zajebistyc.tf&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;9999&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        resp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fromhex(resp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;# only consider first 16 bytes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        leak &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(resp[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [v &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; pt]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plaintexts&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;array(arr))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        leaks&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append([leak,leak]) &lt;span style=&#34;color:#75715e&#34;&gt;# has to be in this format for the attack&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We collect 10000 samples in total, which should be sufficient to perform the attack and recover the key.&lt;/p&gt;
&lt;p&gt;Next, we perform the CPA attack in the exact same way as the article.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ths &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; read_ths_from_ram(samples&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;array(leaks), plaintext&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;array(plaintexts))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;attack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scared&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;CPAAttack(selection_function&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;scared&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;aes&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;selection_functions&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;encrypt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;FirstSubBytes(), 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          model&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;scared&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Monobit(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          discriminant&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;scared&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nanmax,  &lt;span style=&#34;color:#75715e&#34;&gt;# Positive correlation expected&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          convergence_step&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;attack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;run(scared&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Container(ths))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;found_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;nanargmax(attack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;scores, axis&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;astype(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;uint8&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(found_key)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Combining the code and running it, we recover the key in decimal format: &lt;code&gt;[112  52 123  79 115  99 105 108 108 111 115  99 111 112 101 115]&lt;/code&gt;. A quick from decimal in CyberChef gives us the flag:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p4{Oscilloscopes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, it doesn&amp;rsquo;t seem to be the full flag. We assumed at the start that the key size is 16 bytes as it is the most common key size, but AES keys can actually be 16, 24 or 32 bytes.&lt;/p&gt;
&lt;p&gt;Remembering that we neglected the last 16 bytes of the plaintext, we re-run the script - this time, only considering the last 16 bytes of the plaintext.&lt;/p&gt;
&lt;p&gt;We simply modify the line &lt;code&gt;pt = bytes.fromhex(resp[0])[:16]&lt;/code&gt; to &lt;code&gt;[16:]&lt;/code&gt; to do so.&lt;/p&gt;
&lt;p&gt;This works as we recover the last 16 bytes of the key, which is &lt;code&gt;? Still_matter!}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The full flag we get is &lt;code&gt;p4{Oscilloscopes? Still_matter!}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Full cleaned solve script:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;solve.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *

import numpy as np
from tqdm.notebook import tqdm
from estraces import read_ths_from_ram
import scared

plaintexts1 = []
plaintexts2 = []
leaks = [] # voltage

for _ in range(200):
    r = remote(&amp;#34;aes-observed.zajebistyc.tf&amp;#34;,9999)
    r.recvline()
    for i in range(50):
        resp = r.recvline().strip().decode().split(&amp;#34;\t&amp;#34;)
        pt1 = bytes.fromhex(resp[0])[:16]
        pt2 = bytes.fromhex(resp[0])[16:]
        leak = float(resp[1])
        arr = [v for v in pt1]
        plaintexts1.append(np.array(arr))
        arr = [v for v in pt2]
        plaintexts2.append(np.array(arr))
        leaks.append([leak,leak]) # has to be in this format for the attack
    r.close()

# Run attack for first 16 bytes of key
ths = read_ths_from_ram(samples=np.array(leaks), plaintext=np.array(plaintexts1))
attack = scared.CPAAttack(selection_function=scared.aes.selection_functions.encrypt.FirstSubBytes(), 
                          model=scared.Monobit(0), 
                          discriminant=scared.nanmax,  # Positive correlation expected
                          convergence_step=50)
attack.run(scared.Container(ths))

found_key = np.nanargmax(attack.scores, axis=0).astype(&amp;#39;uint8&amp;#39;)

print(found_key)

# Run attack for last 16 bytes of key
ths = read_ths_from_ram(samples=np.array(leaks), plaintext=np.array(plaintexts2))
attack = scared.CPAAttack(selection_function=scared.aes.selection_functions.encrypt.FirstSubBytes(), 
                          model=scared.Monobit(0), 
                          discriminant=scared.nanmax,  # Positive correlation expected
                          convergence_step=50)
attack.run(scared.Container(ths))

found_key = np.nanargmax(attack.scores, axis=0).astype(&amp;#39;uint8&amp;#39;)

print(found_key)

# p4{Oscilloscopes? Still_matter!}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h1 id=&#34;pepega-packets-misc---5-solves&#34;&gt;Pepega Packets (misc) - 5 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Can you be faster enough?&lt;br&gt;
&lt;code&gt;http://10.0.XXX.2:80&lt;/code&gt;&lt;br&gt;
NOTE: Every team have separate ip address, please look on your paper from sanity check :)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is probably the hardest I&amp;rsquo;ve ever cheese&amp;rsquo;d a challenge - and it was first blood as well&amp;hellip;&lt;/p&gt;
&lt;p&gt;We are given the server&amp;rsquo;s code:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;go&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.go&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-go&#34; &gt;&lt;code&gt;
package main

import (
	&amp;#34;context&amp;#34;
	&amp;#34;errors&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;github.com/florianl/go-nflog&amp;#34;
	&amp;#34;github.com/ghedo/go.pkt/layers&amp;#34;
	&amp;#34;github.com/ghedo/go.pkt/packet&amp;#34;
	&amp;#34;github.com/ghedo/go.pkt/packet/ipv4&amp;#34;
	&amp;#34;github.com/ghedo/go.pkt/packet/tcp&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;net&amp;#34;
	&amp;#34;net/http&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;os/exec&amp;#34;
	&amp;#34;strconv&amp;#34;
	&amp;#34;strings&amp;#34;
	&amp;#34;sync&amp;#34;
	&amp;#34;syscall&amp;#34;
	&amp;#34;time&amp;#34;
)

type PacketInfo struct {
	ArrivedAt time.Time

	FromIP   net.IP
	FromPort uint16

	ToIP   net.IP
	ToPort uint16
}

func GetPacketInfo(data []byte) (*PacketInfo, error) {
	netPacket, err := layers.UnpackAll(data, packet.IPv4)
	if err != nil {
		return nil, err
	}

	ipInfo, ok := netPacket.(*ipv4.Packet)
	if !ok {
		return nil, errors.New(&amp;#34;not ip packet&amp;#34;)
	}

	tcpInfo, ok := netPacket.Payload().(*tcp.Packet)
	if !ok {
		return nil, errors.New(&amp;#34;not tcp packet&amp;#34;)
	}

	return &amp;amp;PacketInfo{
		FromIP:   ipInfo.SrcAddr,
		FromPort: tcpInfo.SrcPort,
		ToIP:     ipInfo.DstAddr,
		ToPort:   tcpInfo.DstPort,
	}, nil
}

func GetPacketStream() (chan PacketInfo, error) {
	ctx, cancel := context.WithCancel(context.Background())
	config := nflog.Config{
		Group:    nflogGroup,
		Copymode: nflog.NfUlnlCopyPacket,
		Bufsize:  64,
		Logger:   log.New(os.Stderr, &amp;#34;nflog&amp;#34;, log.LstdFlags),
	}

	nf, err := nflog.Open(&amp;amp;config)
	if err != nil {
		cancel()
		return nil, err
	}

	go func() {
		&amp;lt;-ctx.Done()
		nf.Close()
	}()
	packetStream := make(chan PacketInfo, 65000)

	funcHook := func(msg nflog.Msg) int {
		var packetData []byte
		if msg, exists := msg[nflog.AttrPayload]; exists {
			if msg, ok := msg.([]byte); ok {
				packetData = msg
			}
		}

		var packetTime time.Time
		if msg, exists := msg[nflog.AttrTimestamp]; exists {
			if msg, ok := msg.(time.Time); ok {
				packetTime = msg
			}
		}

		info, err := GetPacketInfo(packetData)
		if err != nil {
			log.Printf(&amp;#34;invalid packet raw=%q&amp;#34;, packetData)
			return 0
		}
		info.ArrivedAt = packetTime

		select {
		case packetStream &amp;lt;- *info:
		default:
			log.Fatalf(&amp;#34;closed channel or overflow&amp;#34;)
			cancel()
		}
		return 0
	}

	err = nf.Register(ctx, funcHook)
	if err != nil {
		cancel()
		return nil, err
	}

	return packetStream, nil
}

func workerFirewall() {
	packetStream, err := GetPacketStream()
	if err != nil {
		log.Fatal(&amp;#34;packetStream err&amp;#34;, err)
	}
	for pkt := range packetStream {
		if GlobalDB.Ban(pkt.FromIP.String(), time.Minute) {
			log.Printf(&amp;#34;banning suspicious connection = %&amp;#43;v\n&amp;#34;, pkt)
		}
	}
}

type localDB struct {
	mu     sync.RWMutex
	banned map[string]time.Time
}

func NewLocalDB() *localDB {
	return &amp;amp;localDB{
		banned: make(map[string]time.Time),
	}
}

func (c *localDB) Ban(remoteIP string, expireDuration time.Duration) bool {
	c.mu.Lock()
	c.banned[remoteIP] = time.Now().Add(expireDuration)
	c.mu.Unlock()
	return true
}

func (c *localDB) IsBanned(remoteIP string) bool {
	c.mu.RLock()
	expireAt, exists := c.banned[remoteIP]
	c.mu.RUnlock()
	if !exists {
		return false
	}
	if time.Since(expireAt).Seconds() &amp;gt; 0 {
		return false
	}
	return true
}

func setupNftables() {
	nftScript := `#!/usr/sbin/nft -f

	table inet chall_pepega_%interface% {}
	delete table inet chall_pepega_%interface%
	table inet chall_pepega_%interface% {
		chain input {
			type filter hook input priority 0; policy accept;
			iif &amp;#34;%interface%&amp;#34; tcp dport %port% log group %nfgroup%
		}
	}
	`
	nftScript = strings.ReplaceAll(nftScript, &amp;#34;%interface%&amp;#34;, interfaceString)
	nftScript = strings.ReplaceAll(nftScript, &amp;#34;%port%&amp;#34;, portString)
	nftScript = strings.ReplaceAll(nftScript, &amp;#34;%nfgroup%&amp;#34;, strconv.Itoa(int(nflogGroup)))

	cmd := exec.Command(&amp;#34;/usr/sbin/nft&amp;#34;, &amp;#34;-f&amp;#34;, &amp;#34;-&amp;#34;)
	cmd.Stdin = strings.NewReader(nftScript)

	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf(&amp;#34;Error executing nft script: err=%&amp;#43;v\nerror output:\n%s\n&amp;#34;, err, output)
	}
}

func getInterfaceIP(interfaceName string) (net.IP, error) {
	iface, err := net.InterfaceByName(interfaceName)
	if err != nil {
		return nil, err
	}

	addrs, err := iface.Addrs()
	if err != nil {
		return nil, err
	}

	for _, addr := range addrs {
		ipNet, ok := addr.(*net.IPNet)
		if ok &amp;amp;&amp;amp; !ipNet.IP.IsLoopback() {
			if ipNet.IP.To4() != nil {
				return ipNet.IP, nil
			}
		}
	}

	return nil, fmt.Errorf(&amp;#34;no IP address found for interface %s&amp;#34;, interfaceName)
}

func workerHttp() {
	http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, &amp;#34;Welcome to the packets!!! Now please get fast  flag!&amp;#34;)
	})
	http.HandleFunc(&amp;#34;/flag&amp;#34;, func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain&amp;#34;)
		flusher, ok := w.(http.Flusher)
		if !ok {
			http.Error(w, &amp;#34;Streaming not supported&amp;#34;, http.StatusInternalServerError)
			return
		}
		remoteAddrStr, _, err := net.SplitHostPort(r.RemoteAddr)
		if err != nil {
			http.Error(w, fmt.Sprintf(&amp;#34;Error extracting remote address, ip=%s&amp;#34;, r.RemoteAddr), http.StatusInternalServerError)
			return
		}
		remoteAddr := net.ParseIP(remoteAddrStr).To4()
		if len(remoteAddr) != 4 {
			http.Error(w, fmt.Sprintf(&amp;#34;Error parsing remote address, ip=%s, ip=%s&amp;#34;, r.RemoteAddr, remoteAddrStr), http.StatusInternalServerError)
			return
		}

		for i := 1; i &amp;lt;= 5; i&amp;#43;&amp;#43; {
			fmt.Fprintf(w, &amp;#34;Validating your request [%d/5], please wait \n&amp;#34;, i)
			flusher.Flush()

			if GlobalDB.IsBanned(remoteAddr.String()) {
				fmt.Fprintln(w, &amp;#34;Sad  You are banned &amp;#34;)
				return
			}
			time.Sleep(time.Second)
		}

		fmt.Fprintf(w, &amp;#34;Here you go!!!  Flag: %s&amp;#34;, flagString)
	})

	serverIP, err := getInterfaceIP(interfaceString)
	if err != nil {
		log.Fatal(&amp;#34;getInterfaceIP err: &amp;#34;, err)
	}
	log.Printf(&amp;#34;Listen on %s:%s\n&amp;#34;, serverIP, portString)

	server := &amp;amp;http.Server{
		Addr:         serverIP.String() &amp;#43; &amp;#34;:&amp;#34; &amp;#43; portString,
		Handler:      http.DefaultServeMux,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}
	listener, err := net.Listen(&amp;#34;tcp&amp;#34;, server.Addr)
	if err != nil {
		log.Fatal(&amp;#34;Error creating listener: &amp;#34;, err)
	}
	rawListener, err := listener.(*net.TCPListener).File()
	if err != nil {
		log.Fatal(&amp;#34;Error getting raw listener file: &amp;#34;, err)
	}
	if err := syscall.SetsockoptString(int(rawListener.Fd()), syscall.SOL_SOCKET, syscall.SO_BINDTODEVICE, interfaceString); err != nil {
		log.Fatal(&amp;#34;Error setting SO_BINDTODEVICE option: &amp;#34;, err)
	}
	if err := server.Serve(listener); err != nil {
		log.Fatal(&amp;#34;server.ListenAndServe err: &amp;#34;, err)
	}
}

var GlobalDB *localDB
var flagString string
var portString string
var interfaceString string
var nflogGroup uint16

func main() {
	flagString = os.Getenv(&amp;#34;FLAG&amp;#34;)
	if len(flagString) == 0 {
		log.Fatal(&amp;#34;flag is empty&amp;#34;)
	}

	portString = os.Getenv(&amp;#34;LISTEN_PORT&amp;#34;)
	if len(portString) == 0 {
		portString = &amp;#34;8080&amp;#34;
	}

	interfaceString = os.Getenv(&amp;#34;LISTEN_INTERFACE&amp;#34;)
	if len(interfaceString) == 0 {
		interfaceString = &amp;#34;eth0&amp;#34;
	}

	nflogGroupStr := os.Getenv(&amp;#34;NFLOG_GROUP&amp;#34;)
	if len(nflogGroupStr) == 0 {
		nflogGroupStr = &amp;#34;100&amp;#34;
	}
	nflogGroup64, err := strconv.ParseUint(nflogGroupStr, 10, 16)
	if err != nil {
		log.Fatal(&amp;#34;invalid nflog group&amp;#34;)
	}
	nflogGroup = uint16(nflogGroup64)

	GlobalDB = NewLocalDB()

	setupNftables()

	go workerFirewall()
	workerHttp()
}

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;We can see that to get the flag, all you have to do is to request the &lt;code&gt;/flag&lt;/code&gt; endpoint and if you&amp;rsquo;re not banned for 5 seconds, it&amp;rsquo;ll give you the flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Validating your request [%d/5], please wait \n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;flusher&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Flush&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GlobalDB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IsBanned&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;remoteAddr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintln&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Sad  You are banned &amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Second&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Here you go!!!  Flag: %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;flagString&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It checks if your IP (&lt;code&gt;remoteAddr&lt;/code&gt;) is banned every second for 5 seconds, and we can find that our IP gets banned for 1 minute when we connect to the server initially in &lt;code&gt;workerFirewall()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;workerFirewall&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;workerHttp&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;workerFirewall&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;packetStream&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetPacketStream&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatal&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;packetStream err&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pkt&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;packetStream&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GlobalDB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Ban&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;pkt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;FromIP&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt;(), &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Minute&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;banning suspicious connection = %+v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;pkt&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;go&lt;/code&gt; before &lt;code&gt;workerFirewall()&lt;/code&gt; essentially means that the function runs asynchronosly, allowing &lt;code&gt;workerHttp()&lt;/code&gt; to be ran alongside &lt;code&gt;workerFirewall()&lt;/code&gt;, which bans our IP address.&lt;/p&gt;
&lt;p&gt;Clearly, we are trying to race the functions in order to send a request where &lt;code&gt;workerFirewall()&lt;/code&gt; takes longer than 5 seconds to respond and ban our IP, so we are able to fetch the flag before we are banned. This is also hinted by in the challenge description.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can you be faster enough?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The naive approach is to simply flood the server with requests on one computer, and use another computer with a seperate IP to request the flag, hoping that the server will lag enough that their IP takes &amp;gt;5 seconds to be banned.&lt;/p&gt;
&lt;p&gt;I coded up a horrendous partially GPT generated python script, with threads to continuesly ping the server to see if this was even viable.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;not_ddos.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import requests
import threading
import time


def flood():
    for i in range(10000000):
        resp = requests.get(&amp;#34;http://10.0.14.2:8080/flag&amp;#34;)
        #print(resp.text)
    print(&amp;#34;ended&amp;#34;)

# Number of threads to run
num_threads = 3000

# Create and start the threads
threads = []
for i in range(num_threads):
    thread = threading.Thread(target=flood, name=f&amp;#34;Thread-{i&amp;#43;1}&amp;#34;)
    thread.start()
    threads.append(thread)
    print(i)

# Wait for all threads to finish
for thread in threads:
    thread.join()

print(&amp;#34;All threads have completed.&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Surprisingly, it actually worked! With a teammate&amp;rsquo;s computer, they requested the &lt;code&gt;/flag&lt;/code&gt; endpoint with their not-yet-banned IP, and got this message:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Validating your request [1/5], please wait 
Validating your request [2/5], please wait 
Sad  You are banned 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We got to &lt;code&gt;2/5&lt;/code&gt;, meaning it lagged the server for around 1 second! Clearly, we just needed a few more requests.&lt;/p&gt;
&lt;p&gt;However, it was at this point when my team started trying to persuade me against DDoS&amp;rsquo;ing the challenge infra, as I took their computers away for more manpower. To be fair, it was in the rules that attacking infra and brute force attacks were not allowed.&lt;/p&gt;

  &lt;img src=&#34;./img/rules.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;So after several failed attemps with thousands of python threads and another teammate&amp;rsquo;s computer, I asked the organisers in person if what I was doing is intended and if it was allowed.&lt;/p&gt;
&lt;p&gt;I was told it wasn&amp;rsquo;t intended (wasn&amp;rsquo;t too surprising) and a maybe for if it was allowed. So I took it as a yes and continued my method.&lt;/p&gt;
&lt;p&gt;Without my teammate&amp;rsquo;s support and resources, I would need to find a way to lag the server using just one computer. What I was doing was essentially DoS&amp;rsquo;ing the infra with my own script - but there are lots of DoS scripts out there already! So why not just steal one from GitHub?&lt;/p&gt;
&lt;p&gt;I came across &lt;a href=&#34;https://github.com/gkbrk/slowloris&#34;&gt;this DoS tool&lt;/a&gt; which looked good, using sockets instead of requests.&lt;/p&gt;

  &lt;img src=&#34;./img/slowloris.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;Modifying the code to accept floats as delay values for even faster DoS&amp;rsquo;ing, I convinced my teammate that it was not a DoS script and I was not breaking any rules, quick just &lt;code&gt;curl /flag&lt;/code&gt; endpoint easy flag.&lt;/p&gt;
&lt;p&gt;And it worked.&lt;/p&gt;

  &lt;img src=&#34;./img/ddos_lol.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;Here you can see on my teammate &lt;a href=&#34;https://twitter.com/torrytwooo&#34;&gt;torry2&amp;rsquo;s&lt;/a&gt; computer, we successfully lagged the server enough with the DoS tool and blooded the challenge &lt;code&gt;p4{wow-you-are-very-fast-pepega!}&lt;/code&gt;.&lt;/p&gt;

  &lt;img src=&#34;./img/pepega_blood.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;h4 id=&#34;intended-solution&#34;&gt;Intended solution&lt;/h4&gt;
&lt;p&gt;After the event, it was revealed that out of the 5 teams that solved the challenge, none of their solutions were intended - everyone went with the request flooding method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cypis&lt;/code&gt;, the challenge author, later revealed that only 1 packet, not 100000, was required to solve the challenge.&lt;/p&gt;
&lt;p&gt;We can see that &lt;code&gt;workerFirewall()&lt;/code&gt; uses &lt;code&gt;GetPacketInfo()&lt;/code&gt; to obtain our remote IP, so we could make the function hang or return an error to cause our IP to never be returned.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;GetPacketInfo&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;PacketInfo&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;netPacket&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;layers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;UnpackAll&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;packet&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IPv4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;ipInfo&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;netPacket&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ipv4&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Packet&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;not ip packet&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;tcpInfo&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;netPacket&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Payload&lt;/span&gt;().(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;tcp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Packet&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;errors&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;not tcp packet&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;PacketInfo&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;FromIP&lt;/span&gt;:   &lt;span style=&#34;color:#a6e22e&#34;&gt;ipInfo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SrcAddr&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;FromPort&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;tcpInfo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SrcPort&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;ToIP&lt;/span&gt;:     &lt;span style=&#34;color:#a6e22e&#34;&gt;ipInfo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DstAddr&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;ToPort&lt;/span&gt;:   &lt;span style=&#34;color:#a6e22e&#34;&gt;tcpInfo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;DstPort&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I did think of this before trying the other method, but I didn&amp;rsquo;t know how to edit packets in Wireshark or &lt;code&gt;tcprelay&lt;/code&gt; some malformed packets to do so.&lt;/p&gt;
&lt;p&gt;cypis posted the solve script on discord, using &lt;code&gt;scapy&lt;/code&gt; to relay the packets in python, which is cool. I think (correct me if I&amp;rsquo;m wrong) the solution causes &lt;code&gt;layers.UnpackAll(data, packet.IPv4)&lt;/code&gt; to hang due to a malformed packet pointing out of bounds somewhere.&lt;/p&gt;

  &lt;img src=&#34;./img/intended.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;Overall I thought it was a fun challenge, and despite the funny unintended solution, the intended solution was quite nice as well!&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;p4CTF Finals was definetely one of the best CTFs I&amp;rsquo;ve been to, not to mention meeting everyone from top teams was really cool! After the event there was an after party, and it was fun talking to the organisers and competitors.&lt;/p&gt;
&lt;p&gt;Again, huge thanks to the &lt;a href=&#34;https://twitter.com/p4_team&#34;&gt;p4CTF team&lt;/a&gt; for hosting the event, and our sponsors who made it possible for us to go! And thanks to my teammates &lt;a href=&#34;https://twitter.com/toasterpwn&#34;&gt;&lt;code&gt;toasterpwn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/_bradan&#34;&gt;&lt;code&gt;bradan&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/torrytwooo&#34;&gt;&lt;code&gt;torry2&lt;/code&gt;&lt;/a&gt; for playing with me!&lt;/p&gt;
&lt;p&gt;If we qualify next year, I&amp;rsquo;ll definetely be coming to the event again - given that our travel does not take 50 hours again!&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;teddy / TheSavageTeddy&lt;/li&gt;
&lt;/ul&gt;

  &lt;img src=&#34;./img/irl_scoreboard.jpg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


</content>
    </item>
    
    <item>
      <title>Crypto Writeups - IrisCTF 2023</title>
      <link>https://TheSavageTeddy.github.io/posts/crypto-iris2023/</link>
      <pubDate>Mon, 09 Jan 2023 03:00:00 +1100</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/posts/crypto-iris2023/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;I solved 4/6 crypto challenges in IrisCTF 2023, here are the writeups for them.&lt;/p&gt;
&lt;p&gt;Challenges (dynamic scoring):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#babynotrsa---145-solves&#34;&gt;&lt;code&gt;babynotrsa&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;sera&lt;/code&gt; - 145 solves&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#babymixup---98-solves&#34;&gt;&lt;code&gt;babymixup&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;sera&lt;/code&gt; - 98 solves&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#nonces-and-keys---53-solves&#34;&gt;&lt;code&gt;Nonces and Keys&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;lambda&lt;/code&gt; - 53 solves&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#aes-bad-256---18-solves&#34;&gt;&lt;code&gt;AES-BAD-256&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;sera&lt;/code&gt; - 18 solves&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;babynotrsa---145-solves&#34;&gt;babynotrsa - 145 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Everyone knows &lt;a href=&#34;https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29&#34;&gt;RSA&lt;/a&gt;, but everyone also knows that RSA is slow. Why not just use a faster operation than exponentiation?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are given a source and output:&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;I solved 4/6 crypto challenges in IrisCTF 2023, here are the writeups for them.&lt;/p&gt;
&lt;p&gt;Challenges (dynamic scoring):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#babynotrsa---145-solves&#34;&gt;&lt;code&gt;babynotrsa&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;sera&lt;/code&gt; - 145 solves&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#babymixup---98-solves&#34;&gt;&lt;code&gt;babymixup&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;sera&lt;/code&gt; - 98 solves&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#nonces-and-keys---53-solves&#34;&gt;&lt;code&gt;Nonces and Keys&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;lambda&lt;/code&gt; - 53 solves&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/posts/crypto-iris2023/#aes-bad-256---18-solves&#34;&gt;&lt;code&gt;AES-BAD-256&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;sera&lt;/code&gt; - 18 solves&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;babynotrsa---145-solves&#34;&gt;babynotrsa - 145 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Everyone knows &lt;a href=&#34;https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29&#34;&gt;RSA&lt;/a&gt;, but everyone also knows that RSA is slow. Why not just use a faster operation than exponentiation?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are given a source and output:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;chal.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-py&#34; &gt;&lt;code&gt;
from Crypto.Util.number import getStrongPrime

# We get 2 1024-bit primes
p = getStrongPrime(1024)
q = getStrongPrime(1024)

# We calculate the modulus
n = p*q

# We generate our encryption key
import secrets
e = secrets.randbelow(n)

# We take our input
flag = b&amp;#34;irisctf{REDACTED_REDACTED_REDACTED}&amp;#34;
assert len(flag) == 35
# and convert it to a number
flag = int.from_bytes(flag, byteorder=&amp;#39;big&amp;#39;)

# We encrypt our input
encrypted = (flag * e) % n

print(f&amp;#34;n: {n}&amp;#34;)
print(f&amp;#34;e: {e}&amp;#34;)
print(f&amp;#34;flag: {encrypted}&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;output.txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-txt&#34; &gt;&lt;code&gt;
n: 21429933885346644587620272790089165813353259223649897308397918491861562279767580488441831451651834802520437234248670652477414296159324726172158330221397420877323921934377321483041598028053870169281419856238830264612049920637819183013812186448416408328958360799645342598727238977986741643705720539702955864527935398839069236768630867447760912744208154645904678859979378604386855741350220991958191408182147658532111413386776058224418484895056146180001830405844881486308594953615999140110712045286000170660686758188247928230655746746482354748673482506070246808187808961599576834080344066055446605664648340486804023919467
e: 10788856448030235429585145974385410619185237539198378911887172763282204686697141640582780419040340318300048024100764883750608733331571719088729202796193207904701854848679412033514037149161609202467086017862616635522167577463675349103892366486246290794304652162107619408011548841664240624935414339021041162505899467159623692906986841033101688573177710503499081107294555688550493634416552587963816327790111808356639558596438537569271043190414208204773219496030644456745185896540608008662177117212000718802474957268532153146989410300300554162811564064457762004188326986236869603714437275058878379647196886872404148116134
flag: 3954523654845598592730156937269688140867480061118457307435945875579028695730063528424973907208923014508950419982702682082417623843946231057553311028711409093751376287876799688357176816093484535703797332422565021382453879908968161161537921292725907853309522100738603080298951279637316809695591295752657105226749125868510570125512146397480808774515489938198191435285342823923715673372695893409325086032930406554421670815433958591841773705563688270739343539481283865883427560667086249616210745997056621098406247201301461721906304555526293017773805845093545204570993288514598261070097976786800172141678030841959348372097

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Looking at the source, it looks like standard RSA, but noticed on this line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# We encrypt our input&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;encrypted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (flag &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; e) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;the &amp;ldquo;encryption&amp;rdquo; is not RSA, as it uses multiplication instead of exponentiation. This means we can calculate an &lt;a href=&#34;https://en.wikipedia.org/wiki/Modular_multiplicative_inverse&#34;&gt;inverse element&lt;/a&gt; \(k\) for \(e\) and \(n\) where \(e \times k = 1 \pmod{n}\).&lt;/p&gt;
&lt;p&gt;Then we multiply this (\(k\)) by &lt;code&gt;encrypted&lt;/code&gt; mod &lt;code&gt;n&lt;/code&gt; to recover the flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Util.number &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; long_to_bytes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;21429933885346644587620272790089165813353259223649897308397918491861562279767580488441831451651834802520437234248670652477414296159324726172158330221397420877323921934377321483041598028053870169281419856238830264612049920637819183013812186448416408328958360799645342598727238977986741643705720539702955864527935398839069236768630867447760912744208154645904678859979378604386855741350220991958191408182147658532111413386776058224418484895056146180001830405844881486308594953615999140110712045286000170660686758188247928230655746746482354748673482506070246808187808961599576834080344066055446605664648340486804023919467&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10788856448030235429585145974385410619185237539198378911887172763282204686697141640582780419040340318300048024100764883750608733331571719088729202796193207904701854848679412033514037149161609202467086017862616635522167577463675349103892366486246290794304652162107619408011548841664240624935414339021041162505899467159623692906986841033101688573177710503499081107294555688550493634416552587963816327790111808356639558596438537569271043190414208204773219496030644456745185896540608008662177117212000718802474957268532153146989410300300554162811564064457762004188326986236869603714437275058878379647196886872404148116134&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;encrypted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3954523654845598592730156937269688140867480061118457307435945875579028695730063528424973907208923014508950419982702682082417623843946231057553311028711409093751376287876799688357176816093484535703797332422565021382453879908968161161537921292725907853309522100738603080298951279637316809695591295752657105226749125868510570125512146397480808774515489938198191435285342823923715673372695893409325086032930406554421670815433958591841773705563688270739343539481283865883427560667086249616210745997056621098406247201301461721906304555526293017773805845093545204570993288514598261070097976786800172141678030841959348372097&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(e,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (encrypted &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; k) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(long_to_bytes(flag))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;irisctf{discrete_divide_isn&#39;t_hard}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;babymixup---98-solves&#34;&gt;babymixup - 98 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;I encrypted a public string and the flag with AES. There&amp;rsquo;s no known key recovery attacks against AES, so you can&amp;rsquo;t decrypt the flag.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Given source and output:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;chal.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-py&#34; &gt;&lt;code&gt;
from Crypto.Cipher import AES
import os

key = os.urandom(16)

flag = b&amp;#34;flag{REDACTED}&amp;#34;
assert len(flag) % 16 == 0

iv = os.urandom(16)
cipher = AES.new(iv,  AES.MODE_CBC, key)
print(&amp;#34;IV1 =&amp;#34;, iv.hex())
print(&amp;#34;CT1 =&amp;#34;, cipher.encrypt(b&amp;#34;Hello, this is a public message. This message contains no flags.&amp;#34;).hex())

iv = os.urandom(16)
cipher = AES.new(key, AES.MODE_CBC, iv )
print(&amp;#34;IV2 =&amp;#34;, iv.hex())
print(&amp;#34;CT2 =&amp;#34;, cipher.encrypt(flag).hex())
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;output.txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-txt&#34; &gt;&lt;code&gt;
IV1 = 4ee04f8303c0146d82e0bbe376f44e10
CT1 = de49b7bb8e3c5e9ed51905b6de326b39b102c7a6f0e09e92fe398c75d032b41189b11f873c6cd8cdb65a276f2e48761f6372df0a109fd29842a999f4cc4be164
IV2 = 1fe31329e7c15feadbf0e43a0ee2f163
CT2 = f6816a603cefb0a0fd8a23a804b921bf489116fcc11d650c6ffb3fc0aae9393409c8f4f24c3d4b72ccea787e84de7dd0
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As shown, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;iv&lt;/code&gt; are completely random, but &lt;code&gt;key&lt;/code&gt; is re-used for both encryptions of &lt;code&gt;P1&lt;/code&gt; (&lt;code&gt;b&amp;quot;Hello, this ...&amp;quot;&lt;/code&gt;) and &lt;code&gt;P2&lt;/code&gt; (the flag).&lt;/p&gt;
&lt;p&gt;We also spot an error with the code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(iv,  AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CBC, key)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(key, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CBC, iv )
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;iv&lt;/code&gt; are swapped for the first operation! For reference, the function is supposed to be &lt;code&gt;AES.new(key, AES mode, IV)&lt;/code&gt;. Let&amp;rsquo;s see how we can exploit this.&lt;/p&gt;
&lt;p&gt;With all block cipher puzzles, it helps to use a diagram that illustrates their decryption scheme. In this case it&amp;rsquo;s &lt;code&gt;AES-CBC&lt;/code&gt;.&lt;/p&gt;

  &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/1200px-CBC_decryption.svg.png&#34;  alt=&#34;wikipedia diagram of AES-CBC decryption&#34;  class=&#34;center&#34;  style=&#34;filter: invert(100%) sepia(100%) saturate(0%) hue-rotate(327deg) brightness(104%) contrast(101%);&#34;  /&gt;


&lt;p&gt;We have &lt;code&gt;IV1&lt;/code&gt; and &lt;code&gt;IV2&lt;/code&gt; from the output, but &lt;code&gt;IV1&lt;/code&gt; is actually the key used to encrypt &lt;code&gt;CT1&lt;/code&gt;. We can figure out the actual &lt;code&gt;IV&lt;/code&gt; for &lt;code&gt;CT1&lt;/code&gt; by looking at the diagram - notice that to decrypt, &lt;code&gt;CT1&lt;/code&gt; is decrypted using the &lt;code&gt;key&lt;/code&gt; then XOR&amp;rsquo;ed with the &lt;code&gt;IV&lt;/code&gt;, and since we know &lt;code&gt;P1&lt;/code&gt; (the plaintext), by properties of XOR, figuring out the &lt;code&gt;IV&lt;/code&gt; is just decrypting without an IV then XORing with the plaintext.&lt;/p&gt;
&lt;p&gt;Recall that &lt;code&gt;real_IV1&lt;/code&gt; is actually the key used to encrypt our flag &lt;code&gt;CT2&lt;/code&gt;, so we now have the key to decrypt the flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Cipher &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; AES
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; binascii &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; unhexlify
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;(a,b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes([x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x,y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(a,b)])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;IV1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4ee04f8303c0146d82e0bbe376f44e10&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CT1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;de49b7bb8e3c5e9ed51905b6de326b39b102c7a6f0e09e92fe398c75d032b41189b11f873c6cd8cdb65a276f2e48761f6372df0a109fd29842a999f4cc4be164&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;IV2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1fe31329e7c15feadbf0e43a0ee2f163&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CT2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;f6816a603cefb0a0fd8a23a804b921bf489116fcc11d650c6ffb3fc0aae9393409c8f4f24c3d4b72ccea787e84de7dd0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(unhexlify(IV1), AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CBC, &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\x00&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;real_IV1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xor(cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(unhexlify(CT1)), &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, this is a public message. This message contains no flags.&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;real_IV1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; real_IV1[:&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;# only first block, IVs are 16 bytes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cipher &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(real_IV1, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_CBC, unhexlify(IV2))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(cipher&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(unhexlify(CT2)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;irisctf{the_iv_aint_secret_either_way_using_cbc}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;nonces-and-keys---53-solves&#34;&gt;Nonces and Keys - 53 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Because of our revolutionary AES-128-OFB technology we have encrypted your user data so securely that even with the key (k=0x13371337133713371337133713371337) evil hackers can&amp;rsquo;t read out the passwords!!!&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are provided with an encrypted sqlite3 file &lt;code&gt;challenge_enc.sqlite3&lt;/code&gt;. Our goal is to decrypt it.&lt;/p&gt;
&lt;p&gt;Already given in the challenge description, the key is &lt;code&gt;0x13371337133713371337133713371337&lt;/code&gt; and the file is encrypted using &lt;code&gt;AES-128-OFB&lt;/code&gt;. Again, we can pull up a diagram.&lt;/p&gt;

  &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/OFB_decryption.svg/1202px-OFB_decryption.svg.png&#34;  alt=&#34;wikipedia diagram for AES-OFB decryption&#34;  class=&#34;center&#34;  style=&#34;filter: invert(100%) sepia(100%) saturate(0%) hue-rotate(327deg) brightness(104%) contrast(101%);&#34;  /&gt;


&lt;p&gt;&lt;code&gt;AES-OFB&lt;/code&gt; being a stream cipher, encryption and decryption are identical. But the more important thing to notice is that we can recover the stream for cipher using known plaintext! Notice that if we have a block of known plaintext &lt;code&gt;P1&lt;/code&gt; and ciphertext &lt;code&gt;C1&lt;/code&gt;, &lt;code&gt;P1&lt;/code&gt; xor &lt;code&gt;C1&lt;/code&gt; will give us the stream (Key and IV encryption). Furthermore, this stream is used as the &amp;ldquo;IV&amp;rdquo; for the next block, and since we have the key already, we can decrypt every subsequent block.&lt;/p&gt;
&lt;p&gt;Now all we need is a block of known plaintext. A quick google search brings us to the sqlite3 magic bytes &lt;code&gt;53514c69746520666f726d6174203300&lt;/code&gt;, which is conveniently 16 bytes - a full block!&lt;/p&gt;
&lt;p&gt;From there we script the decryption of the rest of the blocks, and CTRL+F the flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; Crypto.Cipher &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; AES
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; binascii &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; unhexlify
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;challenge_enc.sqlite3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    enc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xor&lt;/span&gt;(a,b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes([x&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;y &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x,y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; zip(a,b)])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plaintext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unhexlify(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;13371337133713371337133713371337&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unhexlify(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;53514c69746520666f726d6174203300&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# sqlite3 magic bytes &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plaintext &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; p1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# loop that keeps using the previous stream as IV and decrypting&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(enc)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; enc[i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;:i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(p1, len(p1))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xor(c1, p1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; enc[i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;:i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ofb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;new(key, AES&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;MODE_OFB, e1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ofb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decrypt(c2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(p1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    plaintext &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; p1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(plaintext)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;decrypted.sqlite3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(plaintext)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
  &lt;img src=&#34;./img/sqlflag.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;&lt;code&gt;irisctf{g0tt4_l0v3_s7re4mciph3rs}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;aes-bad-256---18-solves&#34;&gt;AES-BAD-256 - 18 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;I heard that some common block cipher modes have lots of footguns - using none (ECB) results in the legendary &lt;a href=&#34;https://words.filippo.io/the-ecb-penguin/&#34;&gt;ECB Penguin&lt;/a&gt;, while others are vulnerable to &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit-flipping_attack&#34;&gt;bit flipping&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Padding_oracle_attack&#34;&gt;padding&lt;/a&gt; attacks, so I made my own that would never fall to such a technique.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&amp;rsquo;m going to admit - I cheesed this challenge quite hard with bruteforce, but in my defense it was 3am&amp;hellip;&lt;/p&gt;

  &lt;img src=&#34;./img/3amflag.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 50%;&#34;  /&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;chal.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-py&#34; &gt;&lt;code&gt;
from Crypto.Cipher import AES as AES_BLOCK
import secrets
import random

AES_BLOCK_SIZE = 16
MODE_BLOCK_SIZE = AES_BLOCK_SIZE * 16

KEY = secrets.token_bytes(AES_BLOCK_SIZE)
AES = AES_BLOCK.new(KEY, AES_BLOCK.MODE_ECB)

import random
random.seed(KEY)

PERMUTATION = list(range(AES_BLOCK_SIZE))
random.shuffle(PERMUTATION)

def encrypt(inp):
    inp = inp.ljust(MODE_BLOCK_SIZE, b&amp;#34;\x00&amp;#34;)
    
    assert len(inp) % MODE_BLOCK_SIZE == 0

    data = b&amp;#34;&amp;#34;
    for block in range(0, len(inp), MODE_BLOCK_SIZE):
        for i in range(AES_BLOCK_SIZE):
            data &amp;#43;= bytes(inp[block&amp;#43;j*AES_BLOCK_SIZE&amp;#43;PERMUTATION[i]] for j in range(MODE_BLOCK_SIZE // AES_BLOCK_SIZE))
    
    return AES.encrypt(data)

def decrypt(inp):
    assert len(inp) % MODE_BLOCK_SIZE == 0

    inp = AES.decrypt(inp)
    data = b&amp;#34;&amp;#34;
    for block in range(0, len(inp), MODE_BLOCK_SIZE):
        for j in range(MODE_BLOCK_SIZE // AES_BLOCK_SIZE):
            for i in range(AES_BLOCK_SIZE):
                data &amp;#43;= bytes([inp[block &amp;#43; PERMUTATION.index(i) * (MODE_BLOCK_SIZE // AES_BLOCK_SIZE) &amp;#43; j]])
  
    return data

import json

def make_echo(inp):
    data = json.dumps({&amp;#34;type&amp;#34;: &amp;#34;echo&amp;#34;, &amp;#34;msg&amp;#34;: inp}).encode(errors=&amp;#34;ignore&amp;#34;)
    assert len(data) &amp;lt; 2**32
    return len(data).to_bytes(length=2, byteorder=&amp;#34;little&amp;#34;) &amp;#43; data

def run_command(inp):
    inp = decrypt(inp)
    length = int.from_bytes(inp[:2], byteorder=&amp;#34;little&amp;#34;)
    if length &amp;#43; 2 &amp;gt;= len(inp):
        return &amp;#34;Invalid command&amp;#34;
    
    # Show me what you got
    command = inp[2:length&amp;#43;2].decode(&amp;#34;ascii&amp;#34;, errors=&amp;#34;replace&amp;#34;)
    try:
        command = json.loads(command, strict=False)
    except Exception as e:
        return &amp;#34;Invalid command&amp;#34;

    if &amp;#34;type&amp;#34; not in command:
        return &amp;#34;No command type&amp;#34;

    match command[&amp;#34;type&amp;#34;]:
        case &amp;#34;echo&amp;#34;:
            return command.get(&amp;#34;msg&amp;#34;, &amp;#34;Hello world!&amp;#34;)
        case &amp;#34;flag&amp;#34;:
            with open(&amp;#34;/flag&amp;#34;, &amp;#34;r&amp;#34;) as f:
                return f.read()
        case other:
            return f&amp;#34;Unknown command type {command[&amp;#39;type&amp;#39;]}...&amp;#34;

BANNER = &amp;#34;This is an echo service. This interface is protected by AES-BAD-256 technology.&amp;#34;

MENU = &amp;#34;&amp;#34;&amp;#34;
1. Get an echo command
2. Run a command
3. Exit
&amp;#34;&amp;#34;&amp;#34;

def main():
    print(BANNER)
    while True:
        print(MENU)
        command = input(&amp;#34;&amp;gt; &amp;#34;)
        match command:
            case &amp;#34;1&amp;#34;:
                print(&amp;#34;Give me some text.\n&amp;#34;)
                data = input(&amp;#34;&amp;gt; &amp;#34;)
                print(encrypt(make_echo(data)).hex())
            case &amp;#34;2&amp;#34;:
                print(&amp;#34;Give me a command.\n&amp;#34;)
                data = bytes.fromhex(input(&amp;#34;(hex) &amp;gt; &amp;#34;))
                print(run_command(data))
            case other:
                print(&amp;#34;Bye!&amp;#34;)
                exit(0)
                

if __name__ == &amp;#34;__main__&amp;#34;:
    main()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Okay, I didn&amp;rsquo;t go through most the code but the important thing is that this is a modification of AES-ECB with random block orders.&lt;/p&gt;
&lt;p&gt;Connecting to remote and testing a bit, I tried flipping some bits:&lt;/p&gt;

  &lt;img src=&#34;./img/flipped.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 50%;&#34;  /&gt;


&lt;p&gt;and yep, it does indeed look vulnerable to bit-flipping attacks! Notice &lt;code&gt;echo&lt;/code&gt; -&amp;gt; &lt;code&gt;zcho&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The server generates us a ciphertext of command &lt;code&gt;echo&lt;/code&gt; with some data, and our goal is to flip bits to make the command &lt;code&gt;flag&lt;/code&gt;, which gives us the flag.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; command[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;]:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;echo&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; command&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world!&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;flag&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/flag&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; other:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown command type &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;command[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;type&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;...&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What&amp;rsquo;s super useful is that if the command is not valid, it tells us what our command was! Essentially, we get feedback about what bit we flipped something to.&lt;/p&gt;
&lt;p&gt;Now, remember the modification - block orders are random, therefore we will script to flip bits from every block and observe the feedback to see if we flipped the right bits. Our goal is to figure out which blocks need to be flipped to change the &lt;code&gt;echo&lt;/code&gt; text.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; pwn &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; binascii &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; unhexlify, hexlify
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;runcmd&lt;/span&gt;(thehex):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(hexlify(thehex))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getecho&lt;/span&gt;(txt):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(txt)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;strip()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; unhexlify(a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flipbit&lt;/span&gt;(str, pos):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bytes([[a,a&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xff&lt;/span&gt;][c&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;pos] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c, a &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(str)])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;aes.chal.irisc.tf&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10100&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;validecho &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getecho(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recv()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;indexes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(validecho), &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dat &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; runcmd(flipbit(validecho, i))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown command type&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; dat:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dat[&lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ord(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dat[&lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ord(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dat[&lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ord(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;h&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dat[&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ord(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;o&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        indexes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    indexes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                indexes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            indexes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(indexes)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Some horrifying python code, but it does the job. Like I said, 3am and coding don&amp;rsquo;t mix well.&lt;/p&gt;
&lt;p&gt;Anyways, now that we have the indexes of blocks that when flipped, change a character of &lt;code&gt;echo&lt;/code&gt;, we now can either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read the source code properly to figure how to flip them into the text &lt;code&gt;flag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OR&amp;hellip; brute force flipping the bit into every byte possible to figure which ones will result in the text &lt;code&gt;flag&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;guess which one I chose&amp;hellip;&lt;/p&gt;
&lt;p&gt;So we have positions of bits that when flipped, change a character at a position. We can just:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;go through each position, e.g. the position that affects &lt;code&gt;e&lt;/code&gt; from &lt;code&gt;echo&lt;/code&gt;, and change that bit into something.&lt;/li&gt;
&lt;li&gt;observe the response - does the character &lt;code&gt;e&lt;/code&gt; get flipped into &lt;code&gt;f&lt;/code&gt; from &lt;code&gt;flag&lt;/code&gt;? if not, change the bit into something else.&lt;/li&gt;
&lt;li&gt;after doing so for all the bits, we should get the flag!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here&amp;rsquo;s the horrendous code that does this:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;6&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;6&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;sol.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-py&#34; &gt;&lt;code&gt;
from pwn import *
from binascii import unhexlify, hexlify

def runcmd(thehex):
    r.sendline(b&amp;#34;2&amp;#34;)
    r.recv()
    r.sendline(hexlify(thehex))
    return r.recv()

def getecho(txt):
    r.sendline(b&amp;#34;1&amp;#34;)
    r.recv()
    r.sendline(txt)
    a=r.recvline().strip()
    print(a)
    return unhexlify(a)

def flipbit(str, pos):
    return bytes([[a,a^0xff][c==pos] for c, a in enumerate(str)])

r = remote(&amp;#39;aes.chal.irisc.tf&amp;#39;, 10100)

r.recv()
r.recv()
validecho = getecho(&amp;#34;hello&amp;#34;)
r.recv()
indexes = [None,None,None,None]
for i in range(0, len(validecho), 16):
    dat = runcmd(flipbit(validecho, i))
    
    if b&amp;#34;Unknown command type&amp;#34; in dat:
        if dat[21] == ord(&amp;#34;e&amp;#34;):
            if dat[22] == ord(&amp;#34;c&amp;#34;):
                if dat[23] == ord(&amp;#34;h&amp;#34;):
                    if dat[24] == ord(&amp;#34;o&amp;#34;):
                        pass
                    else:
                        indexes[3] = i
                else:
                    indexes[2] = i
            else:
                indexes[1] = i
        else:
            indexes[0] = i

finalecho = list(validecho)

for count, flagchar in enumerate(b&amp;#34;flag&amp;#34;):
    foundit = False
    for second in range(0, 256):
        for test in range(0, 256):
            testecho = list(validecho)
            testecho[indexes[count]] = test
            testecho[indexes[count]] ^=second
            testecho = bytes(testecho)
            dat = runcmd(testecho)
            print(dat)
            print(dat[21&amp;#43;count:22&amp;#43;count], count, flagchar)
            if dat[21&amp;#43;count:22&amp;#43;count] == bytes([flagchar]) and b&amp;#34;Unknown command type&amp;#34; in dat:
                print(&amp;#34;FOUND!!!&amp;#34;, test, dat, testecho.hex()) # good dopamine
                finalecho[indexes[count]] = test
                foundit = True
                break
        if foundit:
            break

dat = runcmd(bytes(finalecho))
print(dat)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The great thing is there is a &lt;em&gt;slight&lt;/em&gt; chance that the bit it&amp;rsquo;s choosing to flip never matches the character needed, so this was like gambling until 4 of them matched. But that&amp;rsquo;s what you get for brute forcing.&lt;/p&gt;

  &lt;img src=&#34;./img/amazingflag.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;As you can see, after brute forcing for the final &lt;code&gt;g&lt;/code&gt; of &lt;code&gt;flag&lt;/code&gt;, the full flipped ciphertext was sent and we got the flag!!!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;irisctf{bad_at_diffusion_mode}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I enjoyed these crypto challenges as they weren&amp;rsquo;t math oriented, although they were on the easy side, they were still fun and enjoyable to solve! Kudos to the challenge authors &lt;code&gt;sera&lt;/code&gt; and &lt;code&gt;lambda&lt;/code&gt; for making these!&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
