<!DOCTYPE html>
<html lang="en">
<head>
  
  
  
  
  

    <title>Crypto Writeups - IrisCTF 2023 :: teddyctf</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Writeups for multiple `crypto` challenges from IrisCTF 2023" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://TheSavageTeddy.github.io/posts/crypto-iris2023/" />


<script async src="https://www.googletagmanager.com/gtag/js?id=G-J6PB683BSR"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-J6PB683BSR', { 'anonymize_ip': false });
}
</script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>





  
  
  
  
  
  <link rel="stylesheet" href="https://TheSavageTeddy.github.io/styles.css">







  <link rel="shortcut icon" href="https://TheSavageTeddy.github.io/favicon.ico">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="teddyctf" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Crypto Writeups - IrisCTF 2023">
<meta property="og:description" content="Writeups for multiple `crypto` challenges from IrisCTF 2023" />
<meta property="og:url" content="https://TheSavageTeddy.github.io/posts/crypto-iris2023/" />
<meta property="og:site_name" content="teddyctf" />

  
  
    
  
  <meta property="og:image" content="https://TheSavageTeddy.github.io/posts/crypto-iris2023/3amflag.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="CTF Writeups" />

  <meta property="article:section" content="cryptography" />


  <meta property="article:published_time" content="2023-01-09 00:00:00 &#43;0800 AWST" />












</head>
<body class="green">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner" style="height: 34px;">
    <img src="/images/teddypfp.jpg" style="max-height: 100%; max-width: 100%; display: block;">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    teddy / TheSavageTeddy
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;â–¾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/contact">Contact</a></li>
        
      
        
          <li><a href="/featured">Featured Posts</a></li>
        
      
        
          <li><a href="/posts">Other Posts</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          
            <li><a href="/about">About</a></li>
          
        
      
        
          
            <li><a href="/contact">Contact</a></li>
          
        
      
        
          
            <li><a href="/featured"><b>Featured Posts</b></a></li>
          
        
      
        
          
            <li><a href="/posts">Other Posts</a></li>
          
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://TheSavageTeddy.github.io/posts/crypto-iris2023/"><img src="https://irissec.xyz/assets/img/logo_ascii.png"  class="left"  style="border-radius: 5px; height: auto; width: 3em; display: inline; vertical-align: middle; "  /> Crypto Writeups - IrisCTF 2023</a>
  </h1>
  <div class="post-meta">
    
      <time class="post-date">
        Jan 9, 2023 :: teddyctf
        
      </time>
    
    
    
  </div>

  
    <span class="post-tags">
      
      #<a href="https://TheSavageTeddy.github.io/tags/ctf/">ctf</a>&nbsp;
      
      #<a href="https://TheSavageTeddy.github.io/tags/crypto/">crypto</a>&nbsp;
      
      #<a href="https://TheSavageTeddy.github.io/tags/writeup/">writeup</a>&nbsp;
      
    </span>
  
  
  <img src="/posts/crypto-iris2023/3amflag.png"
    class="post-cover"
    alt=" "
    title="Cover Image" 
    style="border: 1.5px solid #78E2A0; border-radius: 5px; padding: 0px; display:block; margin: auto; max-height: 40em; max-width: auto; " />


  

  <div class="post-content"><div>
        <h1 id="overview">Overview<a href="#overview" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>I solved 4/6 crypto challenges in IrisCTF 2023, here are the writeups for them.</p>
<p>Challenges (dynamic scoring):</p>
<ul>
<li><a href="#babynotrsa---145-solves"><code>babynotrsa</code></a> by <code>sera</code> - 145 solves</li>
<li><a href="#babymixup---98-solves"><code>babymixup</code></a> by <code>sera</code> - 98 solves</li>
<li><a href="#nonces-and-keys---53-solves"><code>Nonces and Keys</code></a> by <code>lambda</code> - 53 solves</li>
<li><a href="#aes-bad-256---18-solves"><code>AES-BAD-256</code></a> by <code>sera</code> - 18 solves</li>
</ul>
<h1 id="babynotrsa---145-solves">babynotrsa - 145 solves<a href="#babynotrsa---145-solves" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<blockquote>
<p>Everyone knows <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>, but everyone also knows that RSA is slow. Why not just use a faster operation than exponentiation?</p>
</blockquote>
<p>We are given a source and output:</p>



  <div class="collapsable-code">
    <input id="1" type="checkbox"  />
    <label for="1">
      <span class="collapsable-code__language">py</span>
      <span class="collapsable-code__title">chal.py</span>
      <span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide"></span>
    </label>
    <pre class="language-py" ><code>
from Crypto.Util.number import getStrongPrime

# We get 2 1024-bit primes
p = getStrongPrime(1024)
q = getStrongPrime(1024)

# We calculate the modulus
n = p*q

# We generate our encryption key
import secrets
e = secrets.randbelow(n)

# We take our input
flag = b&#34;irisctf{REDACTED_REDACTED_REDACTED}&#34;
assert len(flag) == 35
# and convert it to a number
flag = int.from_bytes(flag, byteorder=&#39;big&#39;)

# We encrypt our input
encrypted = (flag * e) % n

print(f&#34;n: {n}&#34;)
print(f&#34;e: {e}&#34;)
print(f&#34;flag: {encrypted}&#34;)
</code></pre>
  </div>





  <div class="collapsable-code">
    <input id="2" type="checkbox" checked />
    <label for="2">
      <span class="collapsable-code__language">txt</span>
      <span class="collapsable-code__title">output.txt</span>
      <span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide"></span>
    </label>
    <pre class="language-txt" ><code>
n: 21429933885346644587620272790089165813353259223649897308397918491861562279767580488441831451651834802520437234248670652477414296159324726172158330221397420877323921934377321483041598028053870169281419856238830264612049920637819183013812186448416408328958360799645342598727238977986741643705720539702955864527935398839069236768630867447760912744208154645904678859979378604386855741350220991958191408182147658532111413386776058224418484895056146180001830405844881486308594953615999140110712045286000170660686758188247928230655746746482354748673482506070246808187808961599576834080344066055446605664648340486804023919467
e: 10788856448030235429585145974385410619185237539198378911887172763282204686697141640582780419040340318300048024100764883750608733331571719088729202796193207904701854848679412033514037149161609202467086017862616635522167577463675349103892366486246290794304652162107619408011548841664240624935414339021041162505899467159623692906986841033101688573177710503499081107294555688550493634416552587963816327790111808356639558596438537569271043190414208204773219496030644456745185896540608008662177117212000718802474957268532153146989410300300554162811564064457762004188326986236869603714437275058878379647196886872404148116134
flag: 3954523654845598592730156937269688140867480061118457307435945875579028695730063528424973907208923014508950419982702682082417623843946231057553311028711409093751376287876799688357176816093484535703797332422565021382453879908968161161537921292725907853309522100738603080298951279637316809695591295752657105226749125868510570125512146397480808774515489938198191435285342823923715673372695893409325086032930406554421670815433958591841773705563688270739343539481283865883427560667086249616210745997056621098406247201301461721906304555526293017773805845093545204570993288514598261070097976786800172141678030841959348372097

</code></pre>
  </div>


<p>Looking at the source, it looks like standard RSA, but noticed on this line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#75715e"># We encrypt our input</span>
</span></span><span style="display:flex;"><span>encrypted <span style="color:#f92672">=</span> (flag <span style="color:#f92672">*</span> e) <span style="color:#f92672">%</span> n
</span></span></code></pre></div><p>the &ldquo;encryption&rdquo; is not RSA, as it uses multiplication instead of exponentiation. This means we can calculate an <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">inverse element</a> \(k\) for \(e\) and \(n\) where \(e \times k = 1 \pmod{n}\).</p>
<p>Then we multiply this (\(k\)) by <code>encrypted</code> mod <code>n</code> to recover the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> long_to_bytes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">21429933885346644587620272790089165813353259223649897308397918491861562279767580488441831451651834802520437234248670652477414296159324726172158330221397420877323921934377321483041598028053870169281419856238830264612049920637819183013812186448416408328958360799645342598727238977986741643705720539702955864527935398839069236768630867447760912744208154645904678859979378604386855741350220991958191408182147658532111413386776058224418484895056146180001830405844881486308594953615999140110712045286000170660686758188247928230655746746482354748673482506070246808187808961599576834080344066055446605664648340486804023919467</span>
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> <span style="color:#ae81ff">10788856448030235429585145974385410619185237539198378911887172763282204686697141640582780419040340318300048024100764883750608733331571719088729202796193207904701854848679412033514037149161609202467086017862616635522167577463675349103892366486246290794304652162107619408011548841664240624935414339021041162505899467159623692906986841033101688573177710503499081107294555688550493634416552587963816327790111808356639558596438537569271043190414208204773219496030644456745185896540608008662177117212000718802474957268532153146989410300300554162811564064457762004188326986236869603714437275058878379647196886872404148116134</span>
</span></span><span style="display:flex;"><span>encrypted <span style="color:#f92672">=</span> <span style="color:#ae81ff">3954523654845598592730156937269688140867480061118457307435945875579028695730063528424973907208923014508950419982702682082417623843946231057553311028711409093751376287876799688357176816093484535703797332422565021382453879908968161161537921292725907853309522100738603080298951279637316809695591295752657105226749125868510570125512146397480808774515489938198191435285342823923715673372695893409325086032930406554421670815433958591841773705563688270739343539481283865883427560667086249616210745997056621098406247201301461721906304555526293017773805845093545204570993288514598261070097976786800172141678030841959348372097</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> pow(e,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> (encrypted <span style="color:#f92672">*</span> k) <span style="color:#f92672">%</span> n
</span></span><span style="display:flex;"><span>print(long_to_bytes(flag))
</span></span></code></pre></div><p><code>irisctf{discrete_divide_isn't_hard}</code></p>
<h1 id="babymixup---98-solves">babymixup - 98 solves<a href="#babymixup---98-solves" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<blockquote>
<p>I encrypted a public string and the flag with AES. There&rsquo;s no known key recovery attacks against AES, so you can&rsquo;t decrypt the flag.</p>
</blockquote>
<p>Given source and output:</p>



  <div class="collapsable-code">
    <input id="3" type="checkbox"  />
    <label for="3">
      <span class="collapsable-code__language">py</span>
      <span class="collapsable-code__title">chal.py</span>
      <span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide"></span>
    </label>
    <pre class="language-py" ><code>
from Crypto.Cipher import AES
import os

key = os.urandom(16)

flag = b&#34;flag{REDACTED}&#34;
assert len(flag) % 16 == 0

iv = os.urandom(16)
cipher = AES.new(iv,  AES.MODE_CBC, key)
print(&#34;IV1 =&#34;, iv.hex())
print(&#34;CT1 =&#34;, cipher.encrypt(b&#34;Hello, this is a public message. This message contains no flags.&#34;).hex())

iv = os.urandom(16)
cipher = AES.new(key, AES.MODE_CBC, iv )
print(&#34;IV2 =&#34;, iv.hex())
print(&#34;CT2 =&#34;, cipher.encrypt(flag).hex())
</code></pre>
  </div>





  <div class="collapsable-code">
    <input id="4" type="checkbox" checked />
    <label for="4">
      <span class="collapsable-code__language">txt</span>
      <span class="collapsable-code__title">output.txt</span>
      <span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide"></span>
    </label>
    <pre class="language-txt" ><code>
IV1 = 4ee04f8303c0146d82e0bbe376f44e10
CT1 = de49b7bb8e3c5e9ed51905b6de326b39b102c7a6f0e09e92fe398c75d032b41189b11f873c6cd8cdb65a276f2e48761f6372df0a109fd29842a999f4cc4be164
IV2 = 1fe31329e7c15feadbf0e43a0ee2f163
CT2 = f6816a603cefb0a0fd8a23a804b921bf489116fcc11d650c6ffb3fc0aae9393409c8f4f24c3d4b72ccea787e84de7dd0
</code></pre>
  </div>


<p>As shown, <code>key</code> and <code>iv</code> are completely random, but <code>key</code> is re-used for both encryptions of <code>P1</code> (<code>b&quot;Hello, this ...&quot;</code>) and <code>P2</code> (the flag).</p>
<p>We also spot an error with the code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(iv,  AES<span style="color:#f92672">.</span>MODE_CBC, key)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(key, AES<span style="color:#f92672">.</span>MODE_CBC, iv )
</span></span></code></pre></div><p>The <code>key</code> and <code>iv</code> are swapped for the first operation! For reference, the function is supposed to be <code>AES.new(key, AES mode, IV)</code>. Let&rsquo;s see how we can exploit this.</p>
<p>With all block cipher puzzles, it helps to use a diagram that illustrates their decryption scheme. In this case it&rsquo;s <code>AES-CBC</code>.</p>

  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/1200px-CBC_decryption.svg.png"  alt="wikipedia diagram of AES-CBC decryption"  class="center"  style="filter: invert(100%) sepia(100%) saturate(0%) hue-rotate(327deg) brightness(104%) contrast(101%);"  />


<p>We have <code>IV1</code> and <code>IV2</code> from the output, but <code>IV1</code> is actually the key used to encrypt <code>CT1</code>. We can figure out the actual <code>IV</code> for <code>CT1</code> by looking at the diagram - notice that to decrypt, <code>CT1</code> is decrypted using the <code>key</code> then XOR&rsquo;ed with the <code>IV</code>, and since we know <code>P1</code> (the plaintext), by properties of XOR, figuring out the <code>IV</code> is just decrypting without an IV then XORing with the plaintext.</p>
<p>Recall that <code>real_IV1</code> is actually the key used to encrypt our flag <code>CT2</code>, so we now have the key to decrypt the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> binascii <span style="color:#f92672">import</span> unhexlify
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">xor</span>(a,b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bytes([x<span style="color:#f92672">^</span>y <span style="color:#66d9ef">for</span> x,y <span style="color:#f92672">in</span> zip(a,b)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IV1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;4ee04f8303c0146d82e0bbe376f44e10&#39;</span>
</span></span><span style="display:flex;"><span>CT1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;de49b7bb8e3c5e9ed51905b6de326b39b102c7a6f0e09e92fe398c75d032b41189b11f873c6cd8cdb65a276f2e48761f6372df0a109fd29842a999f4cc4be164&#39;</span>
</span></span><span style="display:flex;"><span>IV2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1fe31329e7c15feadbf0e43a0ee2f163&#39;</span>
</span></span><span style="display:flex;"><span>CT2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;f6816a603cefb0a0fd8a23a804b921bf489116fcc11d650c6ffb3fc0aae9393409c8f4f24c3d4b72ccea787e84de7dd0&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(unhexlify(IV1), AES<span style="color:#f92672">.</span>MODE_CBC, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>real_IV1 <span style="color:#f92672">=</span> xor(cipher<span style="color:#f92672">.</span>decrypt(unhexlify(CT1)), <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Hello, this is a public message. This message contains no flags.&#34;</span>)
</span></span><span style="display:flex;"><span>real_IV1 <span style="color:#f92672">=</span> real_IV1[:<span style="color:#ae81ff">16</span>] <span style="color:#75715e"># only first block, IVs are 16 bytes</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cipher <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(real_IV1, AES<span style="color:#f92672">.</span>MODE_CBC, unhexlify(IV2))
</span></span><span style="display:flex;"><span>print(cipher<span style="color:#f92672">.</span>decrypt(unhexlify(CT2)))
</span></span></code></pre></div><p><code>irisctf{the_iv_aint_secret_either_way_using_cbc}</code></p>
<h1 id="nonces-and-keys---53-solves">Nonces and Keys - 53 solves<a href="#nonces-and-keys---53-solves" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<blockquote>
<p>Because of our revolutionary AES-128-OFB technology we have encrypted your user data so securely that even with the key (k=0x13371337133713371337133713371337) evil hackers can&rsquo;t read out the passwords!!!</p>
</blockquote>
<p>We are provided with an encrypted sqlite3 file <code>challenge_enc.sqlite3</code>. Our goal is to decrypt it.</p>
<p>Already given in the challenge description, the key is <code>0x13371337133713371337133713371337</code> and the file is encrypted using <code>AES-128-OFB</code>. Again, we can pull up a diagram.</p>

  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/OFB_decryption.svg/1202px-OFB_decryption.svg.png"  alt="wikipedia diagram for AES-OFB decryption"  class="center"  style="filter: invert(100%) sepia(100%) saturate(0%) hue-rotate(327deg) brightness(104%) contrast(101%);"  />


<p><code>AES-OFB</code> being a stream cipher, encryption and decryption are identical. But the more important thing to notice is that we can recover the stream for cipher using known plaintext! Notice that if we have a block of known plaintext <code>P1</code> and ciphertext <code>C1</code>, <code>P1</code> xor <code>C1</code> will give us the stream (Key and IV encryption). Furthermore, this stream is used as the &ldquo;IV&rdquo; for the next block, and since we have the key already, we can decrypt every subsequent block.</p>
<p>Now all we need is a block of known plaintext. A quick google search brings us to the sqlite3 magic bytes <code>53514c69746520666f726d6174203300</code>, which is conveniently 16 bytes - a full block!</p>
<p>From there we script the decryption of the rest of the blocks, and CTRL+F the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> binascii <span style="color:#f92672">import</span> unhexlify
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;challenge_enc.sqlite3&#34;</span>, <span style="color:#e6db74">&#39;rb&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    enc <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">xor</span>(a,b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bytes([x<span style="color:#f92672">^</span>y <span style="color:#66d9ef">for</span> x,y <span style="color:#f92672">in</span> zip(a,b)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plaintext <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> unhexlify(<span style="color:#e6db74">&#34;13371337133713371337133713371337&#34;</span>)
</span></span><span style="display:flex;"><span>p1 <span style="color:#f92672">=</span> unhexlify(<span style="color:#e6db74">&#34;53514c69746520666f726d6174203300&#34;</span>) <span style="color:#75715e"># sqlite3 magic bytes </span>
</span></span><span style="display:flex;"><span>plaintext <span style="color:#f92672">+=</span> p1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># loop that keeps using the previous stream as IV and decrypting</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(enc)<span style="color:#f92672">//</span><span style="color:#ae81ff">16</span>):
</span></span><span style="display:flex;"><span>    c1 <span style="color:#f92672">=</span> enc[i<span style="color:#f92672">*</span><span style="color:#ae81ff">16</span>:i<span style="color:#f92672">*</span><span style="color:#ae81ff">16</span><span style="color:#f92672">+</span><span style="color:#ae81ff">16</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(p1, len(p1))
</span></span><span style="display:flex;"><span>    e1 <span style="color:#f92672">=</span> xor(c1, p1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    c2 <span style="color:#f92672">=</span> enc[i<span style="color:#f92672">*</span><span style="color:#ae81ff">16</span><span style="color:#f92672">+</span><span style="color:#ae81ff">16</span>:i<span style="color:#f92672">*</span><span style="color:#ae81ff">16</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">32</span>]
</span></span><span style="display:flex;"><span>    ofb <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(key, AES<span style="color:#f92672">.</span>MODE_OFB, e1)
</span></span><span style="display:flex;"><span>    p1 <span style="color:#f92672">=</span> ofb<span style="color:#f92672">.</span>decrypt(c2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(p1)
</span></span><span style="display:flex;"><span>    plaintext <span style="color:#f92672">+=</span> p1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(plaintext)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;decrypted.sqlite3&#34;</span>, <span style="color:#e6db74">&#39;wb&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(plaintext)
</span></span></code></pre></div>
  <img src="./img/sqlflag.png"  class="center"  style="border-radius: 5px;"  />


<p><code>irisctf{g0tt4_l0v3_s7re4mciph3rs}</code></p>
<h1 id="aes-bad-256---18-solves">AES-BAD-256 - 18 solves<a href="#aes-bad-256---18-solves" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<blockquote>
<p>I heard that some common block cipher modes have lots of footguns - using none (ECB) results in the legendary <a href="https://words.filippo.io/the-ecb-penguin/">ECB Penguin</a>, while others are vulnerable to <a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">bit flipping</a> and <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack">padding</a> attacks, so I made my own that would never fall to such a technique.</p>
</blockquote>
<p>I&rsquo;m going to admit - I cheesed this challenge quite hard with bruteforce, but in my defense it was 3am&hellip;</p>

  <img src="./img/3amflag.png"  class="center"  style="border-radius: 5px; width: 50%;"  />





  <div class="collapsable-code">
    <input id="5" type="checkbox" checked />
    <label for="5">
      <span class="collapsable-code__language">py</span>
      <span class="collapsable-code__title">chal.py</span>
      <span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide"></span>
    </label>
    <pre class="language-py" ><code>
from Crypto.Cipher import AES as AES_BLOCK
import secrets
import random

AES_BLOCK_SIZE = 16
MODE_BLOCK_SIZE = AES_BLOCK_SIZE * 16

KEY = secrets.token_bytes(AES_BLOCK_SIZE)
AES = AES_BLOCK.new(KEY, AES_BLOCK.MODE_ECB)

import random
random.seed(KEY)

PERMUTATION = list(range(AES_BLOCK_SIZE))
random.shuffle(PERMUTATION)

def encrypt(inp):
    inp = inp.ljust(MODE_BLOCK_SIZE, b&#34;\x00&#34;)
    
    assert len(inp) % MODE_BLOCK_SIZE == 0

    data = b&#34;&#34;
    for block in range(0, len(inp), MODE_BLOCK_SIZE):
        for i in range(AES_BLOCK_SIZE):
            data &#43;= bytes(inp[block&#43;j*AES_BLOCK_SIZE&#43;PERMUTATION[i]] for j in range(MODE_BLOCK_SIZE // AES_BLOCK_SIZE))
    
    return AES.encrypt(data)

def decrypt(inp):
    assert len(inp) % MODE_BLOCK_SIZE == 0

    inp = AES.decrypt(inp)
    data = b&#34;&#34;
    for block in range(0, len(inp), MODE_BLOCK_SIZE):
        for j in range(MODE_BLOCK_SIZE // AES_BLOCK_SIZE):
            for i in range(AES_BLOCK_SIZE):
                data &#43;= bytes([inp[block &#43; PERMUTATION.index(i) * (MODE_BLOCK_SIZE // AES_BLOCK_SIZE) &#43; j]])
  
    return data

import json

def make_echo(inp):
    data = json.dumps({&#34;type&#34;: &#34;echo&#34;, &#34;msg&#34;: inp}).encode(errors=&#34;ignore&#34;)
    assert len(data) &lt; 2**32
    return len(data).to_bytes(length=2, byteorder=&#34;little&#34;) &#43; data

def run_command(inp):
    inp = decrypt(inp)
    length = int.from_bytes(inp[:2], byteorder=&#34;little&#34;)
    if length &#43; 2 &gt;= len(inp):
        return &#34;Invalid command&#34;
    
    # Show me what you got
    command = inp[2:length&#43;2].decode(&#34;ascii&#34;, errors=&#34;replace&#34;)
    try:
        command = json.loads(command, strict=False)
    except Exception as e:
        return &#34;Invalid command&#34;

    if &#34;type&#34; not in command:
        return &#34;No command type&#34;

    match command[&#34;type&#34;]:
        case &#34;echo&#34;:
            return command.get(&#34;msg&#34;, &#34;Hello world!&#34;)
        case &#34;flag&#34;:
            with open(&#34;/flag&#34;, &#34;r&#34;) as f:
                return f.read()
        case other:
            return f&#34;Unknown command type {command[&#39;type&#39;]}...&#34;

BANNER = &#34;This is an echo service. This interface is protected by AES-BAD-256 technology.&#34;

MENU = &#34;&#34;&#34;
1. Get an echo command
2. Run a command
3. Exit
&#34;&#34;&#34;

def main():
    print(BANNER)
    while True:
        print(MENU)
        command = input(&#34;&gt; &#34;)
        match command:
            case &#34;1&#34;:
                print(&#34;Give me some text.\n&#34;)
                data = input(&#34;&gt; &#34;)
                print(encrypt(make_echo(data)).hex())
            case &#34;2&#34;:
                print(&#34;Give me a command.\n&#34;)
                data = bytes.fromhex(input(&#34;(hex) &gt; &#34;))
                print(run_command(data))
            case other:
                print(&#34;Bye!&#34;)
                exit(0)
                

if __name__ == &#34;__main__&#34;:
    main()
</code></pre>
  </div>


<p>Okay, I didn&rsquo;t go through most the code but the important thing is that this is a modification of AES-ECB with random block orders.</p>
<p>Connecting to remote and testing a bit, I tried flipping some bits:</p>

  <img src="./img/flipped.png"  class="center"  style="border-radius: 5px; width: 50%;"  />


<p>and yep, it does indeed look vulnerable to bit-flipping attacks! Notice <code>echo</code> -&gt; <code>zcho</code></p>
<p>The server generates us a ciphertext of command <code>echo</code> with some data, and our goal is to flip bits to make the command <code>flag</code>, which gives us the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>match command[<span style="color:#e6db74">&#34;type&#34;</span>]:
</span></span><span style="display:flex;"><span>    case <span style="color:#e6db74">&#34;echo&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> command<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;msg&#34;</span>, <span style="color:#e6db74">&#34;Hello world!&#34;</span>)
</span></span><span style="display:flex;"><span>    case <span style="color:#e6db74">&#34;flag&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;/flag&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    case other:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Unknown command type </span><span style="color:#e6db74">{</span>command[<span style="color:#e6db74">&#39;type&#39;</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74">...&#34;</span>
</span></span></code></pre></div><p>What&rsquo;s super useful is that if the command is not valid, it tells us what our command was! Essentially, we get feedback about what bit we flipped something to.</p>
<p>Now, remember the modification - block orders are random, therefore we will script to flip bits from every block and observe the feedback to see if we flipped the right bits. Our goal is to figure out which blocks need to be flipped to change the <code>echo</code> text.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> binascii <span style="color:#f92672">import</span> unhexlify, hexlify
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">runcmd</span>(thehex):
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;2&#34;</span>)
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>sendline(hexlify(thehex))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> r<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getecho</span>(txt):
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>    r<span style="color:#f92672">.</span>sendline(txt)
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">=</span>r<span style="color:#f92672">.</span>recvline()<span style="color:#f92672">.</span>strip()
</span></span><span style="display:flex;"><span>    print(a)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> unhexlify(a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">flipbit</span>(str, pos):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bytes([[a,a<span style="color:#f92672">^</span><span style="color:#ae81ff">0xff</span>][c<span style="color:#f92672">==</span>pos] <span style="color:#66d9ef">for</span> c, a <span style="color:#f92672">in</span> enumerate(str)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;aes.chal.irisc.tf&#39;</span>, <span style="color:#ae81ff">10100</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>validecho <span style="color:#f92672">=</span> getecho(<span style="color:#e6db74">&#34;hello&#34;</span>)
</span></span><span style="display:flex;"><span>r<span style="color:#f92672">.</span>recv()
</span></span><span style="display:flex;"><span>indexes <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>,<span style="color:#66d9ef">None</span>,<span style="color:#66d9ef">None</span>,<span style="color:#66d9ef">None</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(validecho), <span style="color:#ae81ff">16</span>):
</span></span><span style="display:flex;"><span>    dat <span style="color:#f92672">=</span> runcmd(flipbit(validecho, i))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Unknown command type&#34;</span> <span style="color:#f92672">in</span> dat:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> dat[<span style="color:#ae81ff">21</span>] <span style="color:#f92672">==</span> ord(<span style="color:#e6db74">&#34;e&#34;</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> dat[<span style="color:#ae81ff">22</span>] <span style="color:#f92672">==</span> ord(<span style="color:#e6db74">&#34;c&#34;</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> dat[<span style="color:#ae81ff">23</span>] <span style="color:#f92672">==</span> ord(<span style="color:#e6db74">&#34;h&#34;</span>):
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> dat[<span style="color:#ae81ff">24</span>] <span style="color:#f92672">==</span> ord(<span style="color:#e6db74">&#34;o&#34;</span>):
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        indexes[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    indexes[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                indexes[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            indexes[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>print(indexes)
</span></span></code></pre></div><p>Some horrifying python code, but it does the job. Like I said, 3am and coding don&rsquo;t mix well.</p>
<p>Anyways, now that we have the indexes of blocks that when flipped, change a character of <code>echo</code>, we now can either:</p>
<ul>
<li>read the source code properly to figure how to flip them into the text <code>flag</code></li>
<li>OR&hellip; brute force flipping the bit into every byte possible to figure which ones will result in the text <code>flag</code></li>
</ul>
<p>guess which one I chose&hellip;</p>
<p>So we have positions of bits that when flipped, change a character at a position. We can just:</p>
<ol>
<li>go through each position, e.g. the position that affects <code>e</code> from <code>echo</code>, and change that bit into something.</li>
<li>observe the response - does the character <code>e</code> get flipped into <code>f</code> from <code>flag</code>? if not, change the bit into something else.</li>
<li>after doing so for all the bits, we should get the flag!</li>
</ol>
<p>Here&rsquo;s the horrendous code that does this:</p>



  <div class="collapsable-code">
    <input id="6" type="checkbox" checked />
    <label for="6">
      <span class="collapsable-code__language">py</span>
      <span class="collapsable-code__title">sol.py</span>
      <span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide"></span>
    </label>
    <pre class="language-py" ><code>
from pwn import *
from binascii import unhexlify, hexlify

def runcmd(thehex):
    r.sendline(b&#34;2&#34;)
    r.recv()
    r.sendline(hexlify(thehex))
    return r.recv()

def getecho(txt):
    r.sendline(b&#34;1&#34;)
    r.recv()
    r.sendline(txt)
    a=r.recvline().strip()
    print(a)
    return unhexlify(a)

def flipbit(str, pos):
    return bytes([[a,a^0xff][c==pos] for c, a in enumerate(str)])

r = remote(&#39;aes.chal.irisc.tf&#39;, 10100)

r.recv()
r.recv()
validecho = getecho(&#34;hello&#34;)
r.recv()
indexes = [None,None,None,None]
for i in range(0, len(validecho), 16):
    dat = runcmd(flipbit(validecho, i))
    
    if b&#34;Unknown command type&#34; in dat:
        if dat[21] == ord(&#34;e&#34;):
            if dat[22] == ord(&#34;c&#34;):
                if dat[23] == ord(&#34;h&#34;):
                    if dat[24] == ord(&#34;o&#34;):
                        pass
                    else:
                        indexes[3] = i
                else:
                    indexes[2] = i
            else:
                indexes[1] = i
        else:
            indexes[0] = i

finalecho = list(validecho)

for count, flagchar in enumerate(b&#34;flag&#34;):
    foundit = False
    for second in range(0, 256):
        for test in range(0, 256):
            testecho = list(validecho)
            testecho[indexes[count]] = test
            testecho[indexes[count]] ^=second
            testecho = bytes(testecho)
            dat = runcmd(testecho)
            print(dat)
            print(dat[21&#43;count:22&#43;count], count, flagchar)
            if dat[21&#43;count:22&#43;count] == bytes([flagchar]) and b&#34;Unknown command type&#34; in dat:
                print(&#34;FOUND!!!&#34;, test, dat, testecho.hex()) # good dopamine
                finalecho[indexes[count]] = test
                foundit = True
                break
        if foundit:
            break

dat = runcmd(bytes(finalecho))
print(dat)
</code></pre>
  </div>


<p>The great thing is there is a <em>slight</em> chance that the bit it&rsquo;s choosing to flip never matches the character needed, so this was like gambling until 4 of them matched. But that&rsquo;s what you get for brute forcing.</p>

  <img src="./img/amazingflag.png"  class="center"  style="border-radius: 5px;"  />


<p>As you can see, after brute forcing for the final <code>g</code> of <code>flag</code>, the full flipped ciphertext was sent and we got the flag!!!</p>
<p><code>irisctf{bad_at_diffusion_mode}</code></p>
<h1 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>I enjoyed these crypto challenges as they weren&rsquo;t math oriented, although they were on the easy side, they were still fun and enjoyable to solve! Kudos to the challenge authors <code>sera</code> and <code>lambda</code> for making these!</p>

      </div></div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>teddyctf</span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
