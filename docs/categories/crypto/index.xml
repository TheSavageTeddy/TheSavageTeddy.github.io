<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Crypto on teddyctf</title>
    <link>https://TheSavageTeddy.github.io/categories/crypto/</link>
    <description>Recent content in Crypto on teddyctf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>teddyctf</copyright>
    <lastBuildDate>Sat, 28 Sep 2024 17:53:20 +1000</lastBuildDate><atom:link href="https://TheSavageTeddy.github.io/categories/crypto/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Crypto Writeups - BSides Canberra CTF 2024</title>
      <link>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/</link>
      <pubDate>Sat, 28 Sep 2024 17:53:20 +1000</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Last week I went to BSides Canberra 2024 to see the amazing talks, meet people, and of course, play CTF. After 2 days of solving interesting challenges, my team &lt;a href=&#34;https://x.com/EmuExploit&#34;&gt;Emu Exploit&lt;/a&gt; managed to get 2nd place overall!&lt;/p&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;I was basically the only person in the team who was willing to do crypto :&amp;lt; so I decided to write up the crypto challenges I solved. Enjoy!&lt;/p&gt;
&lt;h1 id=&#34;challenges-overview&#34;&gt;Challenges Overview&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;43&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#psionic---10-solves&#34;&gt;Psionic&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;10&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#public-service---8-solves&#34;&gt;Public Service&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#arpeeceethree---3-solves&#34;&gt;arpeeceethree&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm - 43 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You enter a room. On the wall is a large tapestry showing two people exchanging gifts. What could it mean?&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Last week I went to BSides Canberra 2024 to see the amazing talks, meet people, and of course, play CTF. After 2 days of solving interesting challenges, my team &lt;a href=&#34;https://x.com/EmuExploit&#34;&gt;Emu Exploit&lt;/a&gt; managed to get 2nd place overall!&lt;/p&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;I was basically the only person in the team who was willing to do crypto :&amp;lt; so I decided to write up the crypto challenges I solved. Enjoy!&lt;/p&gt;
&lt;h1 id=&#34;challenges-overview&#34;&gt;Challenges Overview&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;43&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#psionic---10-solves&#34;&gt;Psionic&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;10&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#public-service---8-solves&#34;&gt;Public Service&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2024/#arpeeceethree---3-solves&#34;&gt;arpeeceethree&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;discrete-add-a-rithm---43-solves&#34;&gt;Discrete Add-a-rithm - 43 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You enter a room. On the wall is a large tapestry showing two people exchanging gifts. What could it mean?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are provided with two files, &lt;code&gt;discreteAddarithm.py&lt;/code&gt; and &lt;code&gt;out.txt&lt;/code&gt;&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;discreteAddarithm.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Util.number import getPrime, getRandomInteger, getRandomRange
from Crypto.Protocol.KDF import HKDF
import Crypto.Hash.SHA512 as sha512
import Crypto.Cipher.AES as aes
from Crypto.Util.Padding import pad, unpad
from binascii import * 
from cybearssecrets import flag

def generateParameters(bitlen=1024):
	p = getPrime(bitlen)
	gen = getRandomRange(2,p-1)
	return gen, p

def generateKeyPair(p, gen):
	privateKey = getRandomRange(2,p-1)
	publicKey = privateKey*gen % p
	return privateKey, publicKey

def generateSharedSecret(p, recipientPrivateKey, senderPublicKey):
	sharedSecret = recipientPrivateKey*senderPublicKey % p
	return sharedSecret

## Init
gen, p = generateParameters()
print(&amp;#34;gen = {}&amp;#34;.format(gen))
print(&amp;#34;p = {}&amp;#34;.format(p))

## A: Alice generates her pub/priv key pair
aPrivateKey, aPublicKey = generateKeyPair(p, gen)

## B: Bob generates his pub/priv key pair
bPrivateKey, bPublicKey = generateKeyPair(p, gen)

## A: Alice sends Bob her public key
print(&amp;#34;aPublicKey = {}&amp;#34;.format(aPublicKey))

## B: Bob sends Alice his public key
print(&amp;#34;bPublicKey = {}&amp;#34;.format(bPublicKey))

## A: Alice caluculates the shared secret
aSharedSecret = generateSharedSecret(p, aPrivateKey, bPublicKey)

## B: Bob caluculates the shared secret
bSharedSecret = generateSharedSecret(p, bPrivateKey, aPublicKey)

## Prove that they match
assert(aSharedSecret == bSharedSecret)

## A: Alice encrypts a message to Bob
aSessionKey, aIV = HKDF(long_to_bytes(aSharedSecret), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
a = aes.new(aSessionKey, aes.MODE_CBC, iv=aIV)
aCipher = a.encrypt(pad(flag,16))

print(&amp;#34;aCipher = {}&amp;#34;.format(hexlify(aCipher)))

## B: Bob decrypts the message
bSessionKey, bIV = HKDF(long_to_bytes(bSharedSecret), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
b = aes.new(bSessionKey, aes.MODE_CBC, iv=bIV)
bPlain = unpad(b.decrypt(aCipher), 16)

if (bPlain == flag):
	print(&amp;#34;Successful decryption!&amp;#34;) 
else:
	print(&amp;#34;Error - something went wrong&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;485136927&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;485136927&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;text&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;out.txt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-text&#34; &gt;&lt;code&gt;
gen = 107665309954437515284050955368964848368303288172119448977068684165707548536106035934408882308704533335892101447750709116199826328820028967921540045634698373851938861013761725712688725891129665455073194344098566187055873775659411023106521425479072045658166413360399757570409372209072730576562842193768242314124
p = 154305601419430130125267211117098923915333624355567046250094074039674228187186943601303157833374662739969026864299363336407319080223107540886546467388611809417774875857578639486137855088896821184616399750557477866148643263803196632154429856293530179926011705130915364080130059881980341409627009701357523451267
aPublicKey = 80354936104370249925868492705190743680652231716704224547570074631753287352078443184923555333860525866848256788314156023903492043171511797029693297228294483818872563765707539175061570839714448005871291987391648926205060807957012526950116361633119573934316064444374124669861697695772912934202842834007697535925
bPublicKey = 42387482047117421466928118692687568439415997629141048723182072767997284324764640343272008345119819287526375581385721174494274510726524360731480638585425669685247170958054446797249761744238847427213615385731375648168698821769635116850680245545304663686514311913787022427877096835277158288159213482962236809739
aCipher = b&amp;#39;618fa12c3a6a6956a47a91bec13f9e1fe2d1031ba2f40a42b4f4d1d9757d0195ea6215fd694c2b99cf9a00be97b46791&amp;#39;
Successful decryption!
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It is essentially &lt;a href=&#34;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&#34;&gt;Diffie Hellman key exchange&lt;/a&gt;, but with multiplication instead of exponentiation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p$ is a random 1024-bit prime&lt;/li&gt;
&lt;li&gt;$g$ (&lt;code&gt;gen&lt;/code&gt;) is a random integer from $2$ to $p-1$&lt;/li&gt;
&lt;li&gt;Alice generates her private key $a$ and computes her public key $A = a \times g \bmod{p}$&lt;/li&gt;
&lt;li&gt;Bob generates his public key $b$ and computers his public key $B = b \times g \bmod{p}$&lt;/li&gt;
&lt;li&gt;We are given $p$, $g$, $A$ and $B$&lt;/li&gt;
&lt;li&gt;The shared secret $s$ is calculated such that $s = A \times b = a \times g \times b = B \times a \bmod{p}$, and used as an AES key to encrypt the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Diffie Hellman leverages the discrete logarithm problem to make retrieving the private key from the public key difficult. However, in this challenge, multiplication is used instead of exponentiation to compute the public key, as $A = a \times g \bmod{p}$ instead of $A = a^g \bmod{p}$.&lt;/p&gt;
&lt;p&gt;Therefore, we can simply rearrange for the private key $a = A \times g^{-1} \bmod{p}$, then calculate the shared secret $s = a \times B \bmod{p}$, and decrypt the flag using the shared secret as the AES key.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Protocol.KDF import HKDF
import Crypto.Hash.SHA512 as sha512
import Crypto.Cipher.AES as aes

# values
g = 107665309954437515284050955368964848368303288172119448977068684165707548536106035934408882308704533335892101447750709116199826328820028967921540045634698373851938861013761725712688725891129665455073194344098566187055873775659411023106521425479072045658166413360399757570409372209072730576562842193768242314124
p = 154305601419430130125267211117098923915333624355567046250094074039674228187186943601303157833374662739969026864299363336407319080223107540886546467388611809417774875857578639486137855088896821184616399750557477866148643263803196632154429856293530179926011705130915364080130059881980341409627009701357523451267
A = 80354936104370249925868492705190743680652231716704224547570074631753287352078443184923555333860525866848256788314156023903492043171511797029693297228294483818872563765707539175061570839714448005871291987391648926205060807957012526950116361633119573934316064444374124669861697695772912934202842834007697535925
B = 42387482047117421466928118692687568439415997629141048723182072767997284324764640343272008345119819287526375581385721174494274510726524360731480638585425669685247170958054446797249761744238847427213615385731375648168698821769635116850680245545304663686514311913787022427877096835277158288159213482962236809739
enc =  bytes.fromhex(&amp;#39;618fa12c3a6a6956a47a91bec13f9e1fe2d1031ba2f40a42b4f4d1d9757d0195ea6215fd694c2b99cf9a00be97b46791&amp;#39;)

# solve
a = (A * pow(g, -1, p)) % p
s = (a * B) % p

aSessionKey, aIV = HKDF(long_to_bytes(s), 16, b&amp;#39;cybears2024&amp;#39;, sha512, num_keys=2)
a = aes.new(aSessionKey, aes.MODE_CBC, iv=aIV)
flag = a.decrypt(enc)
print(f&amp;#34;{flag = }&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Flag: &lt;code&gt;cybears{C3rt41nly_ADDS_s0m3_pr0bl3ms}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;psionic---10-solves&#34;&gt;Psionic - 10 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The cybears face a door with a large wooden face carved into it. Surprisingly, the face starts moving and speaking! &amp;ldquo;Speak the password to enter&amp;rdquo; booms the door&amp;hellip; the cybears consider their options..&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nc psionic.chal.cybears.io 2323&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This was a really weird challenge. We are given server code and an instance to connect to:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;219574638&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;219574638&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

from hashlib import sha1
from Crypto.Util.number import bytes_to_long, long_to_bytes, getRandomInteger, getPrime
import ast
import sys
import json

# This cybears.py file is not included in the handout.
# If you&amp;#39;d like to test locally, create a cybears.py file and put sensible variables in there
from cybears import secret_password, secret_password_chars, flag

# Server-client authentication protocol, but utilising Private-Set-Intersection
# Based on https://csrc.nist.gov/CSRC/media//Projects/pec/documents/stppa-02-PSI-rosulek.pdf

# Client ------------- Server
# 1. {H(p1)^a, H(p2)^a ... } -&amp;gt; 
# 2.               &amp;lt;- {H(s1)^b, H(s2)^b, ..., H(p1)^a^b, H(p2)^a^b... }
# 3. {H(s1)^b^a, H(s2)^b^a, ...} 
# 4. Client checks whether any of the H(s_i)^b^a == H(p_j)^a^b
# 5. Server does same
# 6. If all p_i == s_j, allow client to submit H(nonce || password) for flag! 


def validate_client(client1): 
    result = False
    output = {}

    # parse input 
    try:
        c = ast.literal_eval(client1)
    except Exception as e: 
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        return result, output    

    # Check that we have a set
    if type(c) != list: 
        return result, output

    # Check that all elements in the list are integers
    if all(list(map(lambda x: type(x) == int, c))) != True: 
        return result, output

    result = True
    output = c
    return result, output 


if __name__ == &amp;#34;__main__&amp;#34;:

    # Generate ephemeral server public/private keys
    generator = 2
    public_prime = getPrime(1024)
    server_private = getRandomInteger(1024)
    server_public = pow( 2, server_private, public_prime)
    params = { &amp;#34;prime&amp;#34; : public_prime, &amp;#34;generator&amp;#34;: generator, &amp;#34;server_public&amp;#34; : server_public } 
    


    print(&amp;#34;Welcome to the psionic login server!&amp;#34;)
    print(&amp;#34;params = {}&amp;#34;.format(json.dumps(params)))
    print(&amp;#34;Please enter your set of passwords and we will confirm there is a match:&amp;#34;)

    # 1. client to send commitment
    client1 = input() #expect single string of len(password) entries as a list
    
    result, output = validate_client(client1)
    if result == False: 
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        sys.exit(-1)
    
    if len(output) != len(secret_password):
        print(&amp;#34;Incorrect length - must same length as password&amp;#34;)
        sys.exit(-1)
        
    # 2. server to send commitment
    server_response1 = list(map(lambda x : pow(x, server_private, public_prime), output))
    server_response2 = list(map(lambda x : pow(bytes_to_long(sha1(x.encode()).digest()), server_private, public_prime), secret_password_chars))
    print(&amp;#34;{}&amp;#34;.format(server_response1 &amp;#43; server_response2))

    # 3. client to send verification
    client2 = input() #expect single string of len(password) entries as a list

    result2, output2 = validate_client(client2)
    if result2 == False:
        print(&amp;#34;Incorrect format - must be a list of integers&amp;#34;)
        sys.exit(-1)

    if len(output2) != len(secret_password):
        print(&amp;#34;Incorrect length - must same length as password&amp;#34;)
        print(&amp;#34;DEBUG: {} / {}&amp;#34;.format( len(output), len(secret_password)))
        sys.exit(-1)

    # 5. Server validation - confirm that { H(p_i)^b^a } == {H(s_i)^a^b}
    # Client could just replay, but we don&amp;#39;t just accept this as proof of knowing the password! 
    print(&amp;#34;checking...&amp;#34;)
    
    if (set(output2) == set(server_response1)): 
        print(&amp;#34;Sets are a match! You must know the password!&amp;#34;) 
        print(&amp;#34;Send it through&amp;#34;) # TODO, hash with a nonce? 
        
        client_password = input()
        if(client_password == secret_password): 
            print(&amp;#34;Correct! Here is your flag: {}&amp;#34;.format(flag))
            sys.exit(0)
        else: 
            print(&amp;#34;Incorrect password&amp;#34;)
            sys.exit(-1)
    else:
        print(&amp;#34;Set mismatch. You don&amp;#39;t know the password!&amp;#34;)
        sys.exit(-1)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It&amp;rsquo;s supposedly some sort of &amp;ldquo;Private Set Intersection&amp;rdquo; (PSI), where we need to provide integers (being characters of the password), and it will tell us how many of those are part of the password, and we provide the full password to get the flag.&lt;/p&gt;
&lt;p&gt;Lets step through the server code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, we&amp;rsquo;re provided with some parameters, a prime $p$, generator $g$ and server public value $v = g^y \bmod{p}$ where $y$ is the server private value (These turn out to be useless, so we can kind of just ignore this).&lt;/li&gt;
&lt;li&gt;Next, it prompts us for a list of integers $X = \{x_0, x_1, &amp;hellip;, x_n\}$, and the list must be the same length as the password&lt;/li&gt;
&lt;li&gt;It then loops through the list of integers $X$ and computes $H_X = x_n^y \bmod{p}$ for each item $x_n$ in our list $X$, where H(x) is the SHA1 hash function.&lt;/li&gt;
&lt;li&gt;It does a similar operation for the password chars, computing $H_Z = H(z_n)^y \bmod{p}$ for each character $z_n$ in the password $Z$.&lt;/li&gt;
&lt;li&gt;It sends us both $H_X$ and $H_Z$, which are &amp;ldquo;hidden&amp;rdquo;, hashed values used to compute the private set intersection.&lt;/li&gt;
&lt;li&gt;We are prompted again to provide another list of integers, and the server will check if this list is equal to $H_X$. This step doesn&amp;rsquo;t really make sense since the server sends us $H_X$, so all we have to do is repeat it back.&lt;/li&gt;
&lt;li&gt;If equal, we will be prompted to enter the password as a string, and if the password is correct, we get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code really confused me as I wasn&amp;rsquo;t sure what the challenge was here. I looked at the &lt;a href=&#34;https://csrc.nist.gov/CSRC/media//Projects/pec/documents/stppa-02-PSI-rosulek.pdf&#34;&gt;link provided in the code&lt;/a&gt; which was an overview on Private Set Intersection, and saw that just hashing elements of the set was bad for PSI.&lt;/p&gt;

  &lt;img src=&#34;./img/bad_psi.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;This is because the point of a private set intersection is for two parties, each with their own private set of data, to compute the intersection between the two sets, &lt;strong&gt;without&lt;/strong&gt; either party learning about the whole private set of the other.&lt;/p&gt;
&lt;p&gt;One (bad) way to do this is for you to hash all elements of your set, and the other party does the same. Then you can compare hashed elements - as identical elements hash to the same digest, you can perform PSI by computing the intersection between sets containing the hashed elements. But the link mentions this is a bad way to do it, because you can use a dictionary attack, hashing all possible values of elements in the set, and comparing it to the hash digest of the other party, learning about their elements if hash digests match.&lt;/p&gt;
&lt;p&gt;However, the server seems to mitigate this - recall that our &amp;ldquo;hidden&amp;rdquo; set is $H_X = x_n^y \bmod{p}$, and we don&amp;rsquo;t know the server private value $y$, so we cannot compute this ourselves. But almost the same method is used to generate the password, $H_Z = H(z_n)^y \bmod{p}$, and the server sends us both these sets. Therefore, we can send $X = \{H(&amp;ldquo;a&amp;rdquo;), H(&amp;ldquo;b&amp;rdquo;), &amp;hellip;\}$ and the server will compute $H_X = x_n^y \bmod{p}$ which will be $\{H(&amp;ldquo;a&amp;rdquo;)^y, H(&amp;ldquo;b&amp;rdquo;)^y, &amp;hellip;\}$, and we can compute this set to the password set which will be $\{H(z_0)^y, H(z_1)^y, &amp;hellip;, H(z_n)^y\}$ and intersect these two sets. An element in both these sets reveals a character of the password.&lt;/p&gt;
&lt;p&gt;The server imports the secret password and password chars:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# This cybears.py file is not included in the handout.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# If you&amp;#39;d like to test locally, create a cybears.py file and put sensible variables in there&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; cybears &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; secret_password, secret_password_chars, flag
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I assumed &lt;code&gt;cybears.py&lt;/code&gt; would look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1234567890!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(secret_password)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cybears&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{testing}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But after my solve script worked local but not on remote, I asked the challenge author if &lt;code&gt;secret_password&lt;/code&gt; and &lt;code&gt;secret_password_chars&lt;/code&gt; were constnat on the server. As it turns out, while &lt;code&gt;secret_password&lt;/code&gt; is constant, &lt;code&gt;secret_password_chars&lt;/code&gt; is not - it&amp;rsquo;s scrambled! Which means &lt;code&gt;cybears.py&lt;/code&gt; probably looks something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1234567890!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;secret_password_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;shuffle(list(secret_password))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cybears&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{testing}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Knowing this, I came up with the solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Brute force a little bit to get the password length (server will error if provided integer list not same length as password), which turned out to be 11&lt;/li&gt;
&lt;li&gt;Check what characters were in the password, by sending integers from 0 to 255, 11 at a time, and intersecting the sets returned from the server. Technically, the sets returned by the server were lists, so we can note the indexes of elements that intersected to know which character is in the password.&lt;/li&gt;
&lt;li&gt;Attempt to unscramble the characters to form a password, such as by using an anagram solver.&lt;/li&gt;
&lt;li&gt;Submit password and get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I found it really weird that I had to unscramble the password, it didn&amp;rsquo;t seem to make sense that &lt;code&gt;secret_password_chars&lt;/code&gt; was scrambled, as otherwise, you could easily correlate the indexes of intersecting elements to know what character is in what position. My best guess for why it was scrambled would be that the challenge author wanted to simulate the unordered nature of sets. If anyone knows why, please let me know!&lt;/p&gt;
&lt;p&gt;After running a script to get all the chars, we get characters &lt;code&gt;[&#39;!&#39;, &#39;1&#39;, &#39;A&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;l&#39;, &#39;m&#39;, &#39;o&#39;, &#39;r&#39;, &#39;t&#39;]&lt;/code&gt;. Convering some from l33t c0d3 and putting it in an anagram solver, we get &lt;code&gt;Algorithm&lt;/code&gt; as a potential word. Then we can start to guess passwords, and the correct one turns out to be &lt;code&gt;Algorithm1!&lt;/code&gt;, which gets us the flag.&lt;/p&gt;
&lt;p&gt;Solve scripts:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;615783429&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;615783429&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;get_pw_chars.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *
from Crypto.Util.number import *
import json
import string
from hashlib import sha1

pw_chars = []

step = 11
for i in range(0, 256, step):
    r = remote(&amp;#34;psionic.chal.cybears.io&amp;#34;, 2323)
    # r = remote(&amp;#34;localhost&amp;#34;, 1111)

    r.recvline()
    r.recvuntil(b&amp;#34;params = &amp;#34;)
    params = json.loads(r.recvline().strip().decode()) # unused
    r.recvuntil(b&amp;#34; match:&amp;#34;)
    
    arr_raw = [chr(v) for v in range(i, i&amp;#43;step)]
    arr = [bytes_to_long(sha1(v.encode()).digest()) for v in arr_raw]

    r.sendline(str(arr).encode())
    r.recvline()

    resp = eval(r.recvline().strip().decode())
    H_X, H_Y = resp[:11], resp[11:]

    for xi, x in enumerate(H_X):
        for yi, y in enumerate(H_Y):
            if x == y:
                pw_chars.append(arr_raw[xi])

print(f&amp;#34;{pw_chars = }&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;593621748&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;593621748&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;get_flag.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import *
from Crypto.Util.number import *
import json
import string
from hashlib import sha1

pw_chars = []
r = remote(&amp;#34;psionic.chal.cybears.io&amp;#34;, 2323)
# r = remote(&amp;#34;localhost&amp;#34;, 1111)

r.recvline()
r.recvuntil(b&amp;#34;params = &amp;#34;)
params = json.loads(r.recvline().strip().decode()) # unused
r.recvuntil(b&amp;#34; match:&amp;#34;)

arr_raw = [chr(v) for v in range(0, 11)]
arr = [bytes_to_long(sha1(v.encode()).digest()) for v in arr_raw]

r.sendline(str(arr).encode())
r.recvline()

resp = eval(r.recvline().strip().decode())
H_X, H_Y = resp[:11], resp[11:]

r.sendline(str(H_X).encode())

r.sendline(b&amp;#34;Algorithm1!&amp;#34;)
r.interactive()

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Flag: &lt;code&gt;cybears{n0t_s0_pr1v@t3_int3rs3ct10n}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This was a unique challenge, different to most crypto chals, but I didn&amp;rsquo;t really like having to guess the password from a set of characters - I thought that was a bit guessy and I was lucky to have guessed it.&lt;/p&gt;
&lt;h1 id=&#34;public-service---8-solves&#34;&gt;Public Service - 8 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You find a parchment filled with ancient writings. At the bottom are a number of ornate calligraphic signatures&amp;hellip;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This was a nice challenge. We&amp;rsquo;re given two files, &lt;code&gt;generate_signatures.py&lt;/code&gt; and &lt;code&gt;out.json&lt;/code&gt;:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;873692415&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;873692415&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;generate_signatures.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import Crypto.Signature.DSS as dss
import Crypto.PublicKey.ECC as ecc
import Crypto.Hash.SHA256 as sha256
import Crypto.PublicKey.RSA as rsa
import Crypto.Signature.PKCS1_v1_5 as pkcs
import Crypto.Cipher.PKCS1_OAEP as oaep
from Crypto.Util.number import inverse, getPrime, isPrime, long_to_bytes, bytes_to_long
from binascii import hexlify
import json

from cybearssecrets import FLAG

MESSAGE1 = b&amp;#39;If a new source of energy is not found, no one is going to win this war&amp;#39;
MESSAGE2 = b&amp;#39;Bah weep gragnah weep nini bong&amp;#39;
MESSAGE3 = b&amp;#39;Freedom is the right of all sentient beings&amp;#39;

## Generate Elliptic Curve parameters
ec = ecc.generate(curve = &amp;#34;p256&amp;#34;)
ec_signer = dss.new(ec, &amp;#39;fips-186-3&amp;#39;)

## Generate Elliptic Curve Signature
ec_hasher = sha256.new(MESSAGE1)
ec_sig = ec_signer.sign(ec_hasher)

## Generate RSA parameters
def generate_special_prime(b):
    t = bytes_to_long(b)
    while not(isPrime(t)):
        t &amp;#43;= 1
    return t

rsa_p = generate_special_prime(long_to_bytes(ec.pointQ.x)&amp;#43;long_to_bytes(ec.pointQ.y))
rsa_q = getPrime(512) 

rsa_n = rsa_p*rsa_q
rsa_e = 65537
rsa_d = inverse(rsa_e, (rsa_p-1)*(rsa_q-1))

r = rsa.construct((rsa_n,rsa_e,rsa_d))

## Generate RSA Signatures
rsa_signer = pkcs.new(r)

rsa_hasher1 = sha256.new(MESSAGE2)
rsa_hasher2 = sha256.new(MESSAGE3)

rsa_sig1 = rsa_signer.sign(rsa_hasher1)
rsa_sig2 = rsa_signer.sign(rsa_hasher2)

## Encrypt Flag
encrypter = oaep.new(r)
cipher = encrypter.encrypt(FLAG)

j = {}
j[&amp;#39;ec_sig&amp;#39;] = hexlify(ec_sig).decode()
j[&amp;#39;rsa_sig1&amp;#39;] = hexlify(rsa_sig1).decode()
j[&amp;#39;rsa_sig2&amp;#39;] = hexlify(rsa_sig2).decode()
j[&amp;#39;cipher&amp;#39;] = hexlify(cipher).decode()

with open(&amp;#34;out.json&amp;#34;, &amp;#34;w&amp;#34;) as g: 
    g.write(json.dumps(j))

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;827964531&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;827964531&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;json&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;out.json&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-json&#34; &gt;&lt;code&gt;
{&amp;#34;ec_sig&amp;#34;: &amp;#34;8d32a95ab9b4d92f6ff307d9721451707822d2eae3e07c5c605f0d5979a2e2210b5149487c4d1bedafa96628fcc3579b4842abfa156a963d7db0c15d8da32cc9&amp;#34;, &amp;#34;rsa_sig1&amp;#34;: &amp;#34;45e225f7532b25aa283f80b5166de185cff8b46fb3c9de982083b1ed4a7621c14d0ab541e945c31c9984f958d0b23331d6c636ba8c443941afa277dd2b00c9b7884b4bc9a55047b77305cc6061d9aa9e6be99b70f2f469f6c1accba77228ef129af79bb7f196176753ed27f8308a30b298c34bfc3503dce92f77f0ed8b6d16b6&amp;#34;, &amp;#34;rsa_sig2&amp;#34;: &amp;#34;56b9bac062a9a75b2db42b480e439927265a06b0815be14814f19cd27553a8bdd2815c1814a060fa25b9713b10516b57c9e1f399415492f1ac9a8795034ade99744237a6354d32c0e7330b0b0f52d237e7967863869cf9fdc387f90349c9fbffa15aa72c48ece92bbe59760f41606bfff28af9fdde8f275bf07379f798d98d4d&amp;#34;, &amp;#34;cipher&amp;#34;: &amp;#34;65312f30ef4f34edd32c11ce885c51279bdecd16168953733f04380eb1ed183542e745d630133c4c0c5ce7580bbfb90a347c387eb2743ffaeae5cb7a82058e0fb8a85f7aa392433dc12f0b78e9e0b577909353de84913a47895109de2019a3b88b72f03e13b16f7b092e7a428c664ed174b2cb63208b7a55e9d02a2c0f268d4e&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;There are 3 known, plaintext messages, $m_1$, $m_2$, and $m_3$. A p256 curve is used and a private key on the curve is generated. Then, a ECDSA signature is created from signing the sha256 hash of $m_1$. We are given this signature.&lt;/p&gt;
&lt;p&gt;Next, a prime $p$ is deterministically generated, using the public key on the curve, point $Q$. Then standard RSA follows, generating prime $q$, public key $n=pq$, and private key $d=e^{-1} \bmod(\phi{(n)})$. Signatures of $m_2$ and $m_3$ are created using the RSA private key, and we are given these signatures. The flag is then encrypted with the RSA key, and we are given the encrypted flag.&lt;/p&gt;
&lt;p&gt;The challenge is to recover both the ECC and RSA public keys, and decrypt the flag.&lt;/p&gt;
&lt;h3 id=&#34;recovering-ecc-public-key&#34;&gt;Recovering ECC Public Key&lt;/h3&gt;
&lt;p&gt;I searched online for recovering the public key from an ECDSA signature and found &lt;a href=&#34;https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work&#34;&gt;this&lt;/a&gt;, which you should read for more details, but essentially you can recover the public key given a signature $(r, s)$, by finding the two points $R$ and $\prime{R}$ with the same x coordinate as $r$, and calculating:&lt;/p&gt;
&lt;p&gt;$$
r^{-1}(sR - zG) \newline
r^{-1}(s\prime{R} - zG)
$$&lt;/p&gt;
&lt;p&gt;where $z$ is the message that was signed, and $G$ is the generator on the curve. As shown above this yields two points, one of which is the public key $Q$.&lt;/p&gt;
&lt;p&gt;We can do so using the sage code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# p-256 curve paramters from https://neuromancer.sk/std/nist/P-256&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;K &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GF(p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;E &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; EllipticCurve(K, (a, b))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;G &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; E(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_order(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r,s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(ec_sig[:&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;]), bytes_to_long(ec_sig[&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(MSG1_HASH&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;digest())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r_inv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pow(r, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;order())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R, R_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; E&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lift_x(K(r), all&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Q_1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_inv &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (s&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;R &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;G)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Q_2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_inv &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (s&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;R_ &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; z&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;G)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;recovering-rsa-public-key&#34;&gt;Recovering RSA Public Key&lt;/h3&gt;
&lt;p&gt;We have two messages $m_2$ and $m_3$ that are signed with RSA, yielding $s_2$ and $s_3$. Searching online again I found &lt;a href=&#34;https://crypto.stackexchange.com/questions/26188/rsa-public-key-recovery-from-signatures&#34;&gt;this&lt;/a&gt; which states you can recover public modulus $n$ by computing $\gcd{(s_2^e - m_2, s_3^e - m_3)} = kn$ where $k$ is small.&lt;/p&gt;
&lt;p&gt;This makes sense as $m_2 = s_2^e \bmod{n}$ thus $m_2 = s_2^e - k_2n$ for some integer $k_2$, therefore we can GCD $m_2 - s_2^e = -k_2n$ and $m_3 - s_3^e = -k_3n$ to obtain a multiple of $n$.&lt;/p&gt;
&lt;p&gt;As $e = 65537$, this takes a while to compute, but after doing so we recover (a multiple of) the public modulus $n$.&lt;/p&gt;
&lt;p&gt;Note that $m_2$ is actually a transformed version of the plaintext message, as it is first hashed then some pkcs1_15 scheme is used to pad the message. This made it really annoying to get the message that was actually signed, so I directly edited the library code to print the message being signed, and ran the challenge script with a test flag.&lt;/p&gt;

  &lt;img src=&#34;./img/get_real_m.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;h3 id=&#34;getting-the-flag&#34;&gt;Getting the flag&lt;/h3&gt;
&lt;p&gt;Now that we have both the ECDSA and RSA pubkey, we can recover the flag. As mentioned before, one of the RSA primes are generated deterministically based on the ECDSA pubkey $Q$:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_special_prime&lt;/span&gt;(b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt;(isPrime(t)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rsa_p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_special_prime(long_to_bytes(ec&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pointQ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;long_to_bytes(ec&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pointQ&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;y))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So now that we recovered the pubkey, we can simply call this function to recover a prime. Even though we have 2 possible ECDSA pubkeys, we can check which one is correct by generating the 2 possible primes and using GCD with $n$.&lt;/p&gt;
&lt;p&gt;From there, it&amp;rsquo;s just simple RSA to generate the RSA private key and decrypt the flag.&lt;/p&gt;
&lt;p&gt;Solve script:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;719365842&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;719365842&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
import Crypto.Hash.SHA256 as sha256
import Crypto.PublicKey.RSA as rsa
import Crypto.Cipher.PKCS1_OAEP as oaep
from Crypto.Util.number import *

## Generate RSA parameters
def generate_special_prime(b):
    t = bytes_to_long(b)
    while not(isPrime(t)):
        t &amp;#43;= 1
    return t

data = {&amp;#34;ec_sig&amp;#34;: &amp;#34;8d32a95ab9b4d92f6ff307d9721451707822d2eae3e07c5c605f0d5979a2e2210b5149487c4d1bedafa96628fcc3579b4842abfa156a963d7db0c15d8da32cc9&amp;#34;, &amp;#34;rsa_sig1&amp;#34;: &amp;#34;45e225f7532b25aa283f80b5166de185cff8b46fb3c9de982083b1ed4a7621c14d0ab541e945c31c9984f958d0b23331d6c636ba8c443941afa277dd2b00c9b7884b4bc9a55047b77305cc6061d9aa9e6be99b70f2f469f6c1accba77228ef129af79bb7f196176753ed27f8308a30b298c34bfc3503dce92f77f0ed8b6d16b6&amp;#34;, &amp;#34;rsa_sig2&amp;#34;: &amp;#34;56b9bac062a9a75b2db42b480e439927265a06b0815be14814f19cd27553a8bdd2815c1814a060fa25b9713b10516b57c9e1f399415492f1ac9a8795034ade99744237a6354d32c0e7330b0b0f52d237e7967863869cf9fdc387f90349c9fbffa15aa72c48ece92bbe59760f41606bfff28af9fdde8f275bf07379f798d98d4d&amp;#34;, &amp;#34;cipher&amp;#34;: &amp;#34;65312f30ef4f34edd32c11ce885c51279bdecd16168953733f04380eb1ed183542e745d630133c4c0c5ce7580bbfb90a347c387eb2743ffaeae5cb7a82058e0fb8a85f7aa392433dc12f0b78e9e0b577909353de84913a47895109de2019a3b88b72f03e13b16f7b092e7a428c664ed174b2cb63208b7a55e9d02a2c0f268d4e&amp;#34;}

MESSAGE1 = b&amp;#39;If a new source of energy is not found, no one is going to win this war&amp;#39;
MSG1_HASH = sha256.new(MESSAGE1)

ec_sig = bytes.fromhex(data[&amp;#34;ec_sig&amp;#34;])
s1 = int(data[&amp;#34;rsa_sig1&amp;#34;], 16)
s2 = int(data[&amp;#34;rsa_sig2&amp;#34;], 16)
enc_flag = bytes.fromhex(data[&amp;#34;cipher&amp;#34;])

# p-256 curve paramters from https://neuromancer.sk/std/nist/P-256
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff 
K = GF(p)
a = K(0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc)
b = K(0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b)
E = EllipticCurve(K, (a, b))
G = E(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)
E.set_order(0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * 0x1)

# part 1: recover ECC public key
r,s = bytes_to_long(ec_sig[:32]), bytes_to_long(ec_sig[32:])
z = bytes_to_long(MSG1_HASH.digest())

r_inv = pow(r, -1, E.order())
R, R_ = E.lift_x(K(r), all=True)

Q_1 = r_inv * (s*R - z*G)
Q_2 = r_inv * (s*R_ - z*G)

print(f&amp;#34;Recovered possible ECSDA pubkeys:&amp;#34;)
print(f&amp;#34;{Q_1 = }&amp;#34;)
print(f&amp;#34;{Q_2 = }&amp;#34;)

# part 2: recover RSA public key

e = 65537
# values from editing library src and printing msg before it got signed
# MESSAGE2 = b&amp;#39;Bah weep gragnah weep nini bong&amp;#39;
# MESSAGE3 = b&amp;#39;Freedom is the right of all sentient beings&amp;#39;
m2 = 5486124068793688683255936251187209270074392635932332070112001988456197381759672947165175699536362793613284725337872111744958183862744647903224103718245670299614498700710006264535421091908069935709303403272242499531581061652193706559968553759421347924920266204277973339410586176390872847811111144114590842
m3 = 5486124068793688683255936251187209270074392635932332070112001988456197381759672947165175699536362793613284725337872111744958183862744647903224103718245670299614498700710006264535421091908069935709303403272242499531581061652193643492425095701346333448554897794580398627955585138706133687412101835882486651

print(f&amp;#34;Recovering RSA pubkey...&amp;#34;)

kn = gcd(s1^e - m2, s2^e - m3)

print(f&amp;#34;Recovered RSA pubkey multiple {kn = }&amp;#34;)

# last part: decrypting flag

rsa_p_1 = generate_special_prime(long_to_bytes(int(Q_1.x()))&amp;#43;long_to_bytes(int(Q_1.y())))
rsa_p_2 = generate_special_prime(long_to_bytes(int(Q_2.x()))&amp;#43;long_to_bytes(int(Q_2.y())))

p = None
if gcd(rsa_p_1, kn) != 1:
    p = rsa_p_1
elif gcd(rsa_p_2, kn) != 1:
    p = rsa_p_2
else:
    print(&amp;#34;Something went wrong, neither primes are correct&amp;#34;)

# k*n = k*p*q
kq = kn // p
# get largest factor of kq which should be q
q = list(dict(factor(kq)).keys())[-1]

n = p*q
d = pow(e, -1, (p-1)*(q-1))

r = rsa.construct((int(n),int(e),int(d)))
decrypter = oaep.new(r)
flag = decrypter.decrypt(enc_flag)
print(f&amp;#34;{flag = }&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Flag: &lt;code&gt;cybears{D0nt_m4k3_pr1v4t3_publ1c_k3yz!}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;arpeeceethree---3-solves&#34;&gt;arpeeceethree - 3 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;You hand over your identity parchment to the temple monk. He scrutinises it closely, looking for any signs of malintent.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python client.py -r arpeeceethree.chal.cybears.io:2323&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;There was a lot of source and dependencies to install for this challenge, but the vulnerability is actually very simple.&lt;/p&gt;
&lt;p&gt;We are provided with 3 files, &lt;code&gt;client.py&lt;/code&gt;, &lt;code&gt;server.py&lt;/code&gt; and &lt;code&gt;server.proto&lt;/code&gt;.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;349268715&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;349268715&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;client.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey


def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ECDH(curve=NIST256p)
    client_ephemeral_ecdh.generate_private_key()
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    s = remote(host, port)

    ## Create new user
    log.info(&amp;#34;Creating new user&amp;#34;)
    e = create_user()

    ## Register
    log.info(&amp;#34;Registering new user&amp;#34;)
    uid = register(s,e)

    ## Login
    log.info(&amp;#34;Logging in - part 1&amp;#34;)
    (sessionId, chal, sepk) = login(s, uid)
    log.info(&amp;#34;Logging in - part 2&amp;#34;)
    ceph = login2(s, e, sessionId, chal)

    ## Request message
    log.info(&amp;#34;Requesting message&amp;#34;)
    msg = request_msg(s, sessionId, uid, ceph, sepk)
    log.info(&amp;#34;message received: {}&amp;#34;.format(msg))


    s.close()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;927461358&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;927461358&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
#!/usr/bin/python3

# protoc -I=. --python_out=. ./server.proto
# socat -d TCP-LISTEN:2323,reuseaddr,fork EXEC:&amp;#34;python3 server_stdio_3.py&amp;#34;

from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey
import uuid

import logging
import os
import sys

from cybears import flag

#logging.root.setLevel(logging.DEBUG)
#logging.root.setLevel(logging.INFO)
logging.root.setLevel(logging.ERROR)

logger = logging.getLogger(&amp;#34;__name__&amp;#34;)

h1 = logging.StreamHandler(sys.stderr)
h1.setLevel(logging.DEBUG)
h2 = logging.StreamHandler(sys.stderr)
h2.setLevel(logging.INFO)

logger.addHandler(h1)
logger.addHandler(h2)


def send_message(msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to stdout &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    sys.stdout.buffer.write(mh.SerializeToString() &amp;#43; data)
    sys.stdout.flush()
    logging.info(&amp;#34;Sent msg over stdout...&amp;#34;)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None   

def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message():
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= sys.stdin.buffer.read(1)
        try: 
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e: 
            pass
    logging.debug(&amp;#34;header {}&amp;#34;.format(header))

    # Receive the message data
    data = sys.stdin.buffer.read(header.msglen)
    logging.debug(&amp;#34;received [{}]&amp;#34;.format(data))

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None: 
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            logging.debug(&amp;#34;msg {}&amp;#34;.format(msg))
            return msg
        except _DecodeError:
            return None
    else:
        return None

def handle_register_request(msg):
    logging.debug(&amp;#34;Got register request&amp;#34;)
    # validate request
    # check public key is on correct curve
    try:
        v = VerifyingKey.from_string(msg.clientPublicKey, NIST256p)
    except Exception as e:
        resp = spb.RegisterResponse()
        resp.type = spb.MSG_REGISTER_RESPONSE
        resp.uid = 0xff
        resp.status = spb.FAILURE
        send_message(resp) 
        logging.info(&amp;#34;FAILURE: User failed to registered with invalid pub key: {} and error {}&amp;#34;.format(msg.clientPublicKey,e))
        return spb.FAILURE

    # parse request
    uid = register_user(USERS, msg.name, msg.clientPublicKey)

    # send response
    resp = spb.RegisterResponse()
    resp.type = spb.MSG_REGISTER_RESPONSE
    resp.uid = uid
    resp.status = spb.SUCCESS
    send_message(resp) 
    logging.info(&amp;#34;SUCCESS: User registered with uid: {}&amp;#34;.format(uid))

    return spb.SUCCESS

def handle_login_request(SESSION, msg):
    logging.debug(&amp;#34;Got Login request&amp;#34;)
    resp = spb.LoginResponse()
    resp.type = spb.MSG_LOGIN_RESPONSE

    # validate request
    if msg.uid &amp;gt; len(USERS) or msg.uid == 0: 
        logging.info(&amp;#34;ERROR: invalid uid&amp;#34;)
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        resp.challenge = b&amp;#39;&amp;#39;
        resp.ephemeralServerPublicKey = b&amp;#39;&amp;#39;
        send_message(resp)
        return spb.FAILURE

    requested_user = USERS[msg.uid - 1]

    # parse request
    
    # send response
    challenge = os.urandom(32) # random 32-byte challenge to sign    
    server_ephemeral_ecdh = ECDH(curve=NIST256p)
    server_ephemeral_ecdh.generate_private_key()
    server_ephemeral_public_key = server_ephemeral_ecdh.get_public_key()
    
    sessionId = str(uuid.uuid4()).encode()

    resp.status = spb.SUCCESS
    resp.sessionId = sessionId
    resp.challenge = challenge
    resp.ephemeralServerPublicKey = server_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    SESSIONS[sessionId] = {&amp;#39;completed_challenge&amp;#39;:False, &amp;#39;challenge&amp;#39;:challenge, &amp;#39;ephemeral_ecdh&amp;#39;:server_ephemeral_ecdh, &amp;#39;uid&amp;#39;:msg.uid}
    logging.debug(&amp;#34;New session created {}&amp;#34;.format(SESSIONS[sessionId]))
    logging.info(&amp;#34;SUCCESS: User correctly requested login with uid: {}&amp;#34;.format(msg.uid))
    send_message(resp)

    return spb.SUCCESS

def verify_challenge(chal, chalResponse, public_key):

    try:
        public_key.verify(chalResponse, data=chal)
    except ecdsa.BadSignatureError:
        return False

    return True

def handle_login_challenge_request(SESSION, USERS, msg):
    logging.debug(&amp;#34;Got Login Challenge request&amp;#34;)
    resp = spb.LoginChallengeResponse()
    resp.type = spb.MSG_LOGIN_CHALLENGE_RESPONSE
        
    # validate request
        # sessionId in SESSIONS?
    if msg.sessionId not in SESSIONS:
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: User send invalid sessionId: {}&amp;#34;.format(msg.sessionId))
        send_message(resp)
        return spb.FAILURE

    uid = SESSIONS[msg.sessionId][&amp;#39;uid&amp;#39;]
    requested_user = USERS[uid - 1]
    logging.debug(&amp;#34;requested user {}: {}&amp;#34;.format(uid,requested_user))
    clientPubKey = VerifyingKey.from_string(requested_user[&amp;#39;pubkey&amp;#39;], NIST256p) #already validated 
    clientRole = requested_user[&amp;#39;role&amp;#39;]

    sessionId = msg.sessionId
        # verify challenge
    if not verify_challenge(SESSION[sessionId][&amp;#39;challenge&amp;#39;], msg.challengeResponse, clientPubKey):
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: User failed challenge: {}&amp;#34;.format(msg.challenge))
        send_message(resp)
        return spb.FAILURE

        # ensure ephem client key is on curve
    try:
        clientEphemPubKey = VerifyingKey.from_string(msg.ephemeralClientPublicKey, NIST256p)
    except Exception as e:
        resp.status = spb.FAILURE
        resp.sessionId = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;FAILURE: Invalid client ephemeral public key: {}&amp;#34;.format(msg.ephemeralClientPublicKey))
        send_message(resp)
        return spb.FAILURE

    # action request
    server_ephemeral_ecdh = SESSIONS[sessionId][&amp;#39;ephemeral_ecdh&amp;#39;]
    server_ephemeral_ecdh.load_received_public_key(clientEphemPubKey)
    shared_secret = server_ephemeral_ecdh.generate_sharedsecret_bytes()

    token  = shared_secret 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(clientRole) 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid) 
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId

    # send response
    resp.status = spb.SUCCESS
    resp.sessionId = sessionId

    SESSIONS[sessionId][&amp;#39;completed_challenge&amp;#39;] = True
    SESSIONS[sessionId].update( {&amp;#39;client_token&amp;#39;:token} )
    logging.info(&amp;#34;SUCCESS: User correctly completed challenge with uid: {}&amp;#34;.format(uid))
    send_message(resp)

    return spb.SUCCESS

def handle_message_request(SESSIONS, msg):
    logging.debug(&amp;#34;Got message request&amp;#34;)
    resp = spb.MessageResponse()
    resp.type = spb.MSG_MESSAGE_RESPONSE
    # validate request
    if msg.sessionId not in SESSIONS:
        resp.status = spb.FAILURE
        resp.encMsg = b&amp;#39;&amp;#39;
        resp.encMsgTag = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;ERROR: Invalid sessionId: {}&amp;#34;.format(sessionId)) 
        send_message(resp)
        return spb.FAILURE

    # parse request
    if SESSIONS[msg.sessionId][&amp;#39;completed_challenge&amp;#39;] == False or &amp;#39;client_token&amp;#39; not in SESSIONS[msg.sessionId]:
        resp.status = spb.FAILURE
        resp.encMsg = b&amp;#39;&amp;#39;
        resp.encMsgTag = b&amp;#39;&amp;#39;
        logging.info(&amp;#34;ERROR: challenge not completed for this session&amp;#34;)
        send_message(resp)
        return spb.FAILURE

    token = SESSIONS[msg.sessionId][&amp;#39;client_token&amp;#39;]
    role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
    
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2) 

    if role == spb.ADMIN:
        plain = b&amp;#39;Congratulations - here is your flag: &amp;#39; &amp;#43; flag
    else:
        plain = b&amp;#39;Welcome USER!&amp;#39;

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    (cipher, tag) = a.encrypt_and_digest(plain)

    # send response    

    resp.status = spb.SUCCESS
    resp.encMsg = cipher
    resp.encMsgTag = tag
    logging.info(&amp;#34;SUCCESS: message sent&amp;#34;) 
    send_message(resp)

    return spb.SUCCESS

def register_user(USERS, name, pubkey, role = spb.USER):
    len_db = len(USERS)
    uid = len_db &amp;#43; 1
    USERS.append( {&amp;#34;name&amp;#34;: name, &amp;#34;pubkey&amp;#34;: pubkey, &amp;#34;uid&amp;#34;:uid, &amp;#34;role&amp;#34;: role} )
    logging.debug(&amp;#34;users = {}&amp;#34;.format(USERS))
    return uid

if __name__ == &amp;#34;__main__&amp;#34;:
    
    logging.debug(&amp;#34;creating sessions database&amp;#34;)
    # create session database
    SESSIONS = {}

    logging.debug(&amp;#34;creating admin user&amp;#34;)
    # create admin user
    server_ecdh = ECDH(curve=NIST256p)
    server_ecdh.generate_private_key()
    server_public_key = server_ecdh.get_public_key()
    spub = server_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)
    
    logging.debug(&amp;#34;creating user database&amp;#34;)
    # create user database
    USERS = []
    register_user(USERS, b&amp;#34;admin&amp;#34;, spub, role = spb.ADMIN)  


    logging.debug(&amp;#34;starting message loop&amp;#34;)
    while True:
       m  = recv_message()
       if m != None:
           if m.type == spb.MSG_REGISTER_REQUEST:
               handle_register_request(m)
               continue
           elif m.type == spb.MSG_LOGIN_REQUEST:
               ret = handle_login_request(SESSIONS, m)
               continue
           elif m.type == spb.MSG_LOGIN_CHALLENGE:
               ret = handle_login_challenge_request(SESSIONS, USERS, m)
               continue
           elif m.type == spb.MSG_MESSAGE_REQUEST:
               handle_message_request(SESSIONS, m)
               continue
           else:
               logging.error(&amp;#34;Unknown message type, exitting...&amp;#34;)
               exit(0)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;382547961&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;382547961&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;proto&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;server.proto&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-proto&#34; &gt;&lt;code&gt;
syntax = &amp;#34;proto2&amp;#34;;

package server;

enum MessageType {
	MSG_LOGIN_REQUEST=0;
	MSG_LOGIN_RESPONSE=1;
	MSG_LOGIN_CHALLENGE=2;
	MSG_LOGIN_CHALLENGE_RESPONSE=3;
	MSG_REGISTER_REQUEST=4;
	MSG_REGISTER_RESPONSE=5;
	MSG_MESSAGE_REQUEST=6;
	MSG_MESSAGE_RESPONSE=7;
}

enum Status {
		SUCCESS = 0;
		FAILURE = 1;
	}

enum Role {
		USER = 0;
		ADMIN = 1;
	}

message MessageHeader {
	required uint32 msglen = 1;
	required MessageType type = 2;
}

message RegisterRequest {
	required MessageType type = 1;
	required bytes name = 2;
	required bytes clientPublicKey = 3;
}

message RegisterResponse {
	required MessageType type = 1;
	required uint32 uid = 2;
	required Status status = 3;
}

message LoginRequest {
	required MessageType type = 1;
	required uint32 uid = 2;
}

message LoginResponse {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required bytes challenge = 3;
	required bytes ephemeralServerPublicKey = 4;
	required Status status = 5;
}

message LoginChallenge {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required bytes challengeResponse = 3;
	required bytes ephemeralClientPublicKey = 4;
}

message LoginChallengeResponse {
	required MessageType type = 1;
	required bytes sessionId = 2;
	required Status status = 3; 
}
	
message MessageRequest {
	required MessageType type = 1;
	required bytes sessionId = 3;
}

message MessageResponse {
	required MessageType type = 1;
	required Status status = 2;
	required bytes encMsg = 3;
	required bytes encMsgTag = 4;
}

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;We also need to run the command in the server file &lt;code&gt;protoc -I=. --python_out=. ./server.proto&lt;/code&gt;, to generate &lt;code&gt;server_pb2.py&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s a lot of code to go through, but I&amp;rsquo;ll try to explain the relevant parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The server handles registering new users and logging in.&lt;/li&gt;
&lt;li&gt;To register, the client provides a public key, which must be on the NIST256p curve, then the public key is stored alongside their user id (&lt;code&gt;uid&lt;/code&gt;), name and role.&lt;/li&gt;
&lt;li&gt;To login, there are two steps.
&lt;ul&gt;
&lt;li&gt;Firstly, the server generates a random challenge and public key, and sends it to us.&lt;/li&gt;
&lt;li&gt;Then we must sign the challenge with our public key and send the signature to the server, which checks if the signature is valid. If so, the server calculates the shared secret with its private key and our public key. The server then stores our info (shared secret, role, uid, session id) in a &lt;code&gt;token&lt;/code&gt;, and sends us our session id.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We can also request a message, providing a session id. The server retrieves the token corresponding to our session, and checks if we have the admin role. If we do, we get the flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don&amp;rsquo;t think there&amp;rsquo;s anything wrong with the procedures described above, but I noticed our info was being stored in the token in a very bad way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle_login_challenge_request&lt;/span&gt;(SESSION, USERS, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shared_secret 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(clientRole) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(uid) 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sessionId
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server then uses &lt;code&gt;|&lt;/code&gt; as a delimeter to seperate our info later on:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handle_message_request&lt;/span&gt;(SESSIONS, msg):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    token &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SESSIONS[msg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sessionId][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;client_token&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    role &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(token&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; role &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ADMIN:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Congratulations - here is your flag: &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; flag
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        plain &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Welcome USER!&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;bytes_to_long(token.split(b&#39;|&#39;)[1])&lt;/code&gt; retrieves the role by splitting with &lt;code&gt;|&lt;/code&gt; and getting the second element. This means if we can inject a &lt;code&gt;|&lt;/code&gt; character into the token somehow, we could trick it into thinking we have the admin role. However, it seems like we can&amp;rsquo;t control any info in the token, which are &lt;code&gt;shared_secret&lt;/code&gt;, &lt;code&gt;clientRole&lt;/code&gt;, &lt;code&gt;uid&lt;/code&gt; and &lt;code&gt;sessionId&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But it turns out, the admin role &lt;code&gt;spb.ADMIN&lt;/code&gt; is actually just the number &lt;code&gt;1&lt;/code&gt;, and since &lt;code&gt;shared_secret&lt;/code&gt; is essentially random bytes, there is a chance that it could contain the &lt;code&gt;|&lt;/code&gt; character.&lt;/p&gt;
&lt;p&gt;This is what &lt;code&gt;token&lt;/code&gt; usually looks like:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_secret   |role| uid| session id
...\xc3\x87\xf0|\x00|\x02|c8e9fd09-0cb1-4d6c-88d3-53596a98fccb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if &lt;code&gt;shared_secret&lt;/code&gt; happened to end with &lt;code&gt;|\x01&lt;/code&gt;?&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;shared_secret   |role| uid| session id
...\xc3\x87|\x01|\x00|\x02|c8e9fd09-0cb1-4d6c-88d3-53596a98fccb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the second element when splitting by &lt;code&gt;|&lt;/code&gt; is &lt;code&gt;\x01&lt;/code&gt;, the admin role!&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;shared_secret&lt;/code&gt; is basically random bytes, there is a 1 in $256^2$ which is 1 in 65536 chance that it ends with &lt;code&gt;|\x01&lt;/code&gt; in which the server thinks we&amp;rsquo;re admin, giving us the flag. This actually meant if you ran the client script, unmodified, enough times, you would get the flag. So I did pretty much that, with slight optimizations.&lt;/p&gt;
&lt;p&gt;65536 is not a lot, but probably not a good idea connecting to the server that many times. Luckily, we can create users and login multiple times over the same connection, so we didn&amp;rsquo;t have to open many connections.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; remote(host, port)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; create_user()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    uid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; register(s,e)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; tqdm(range(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (sessionId, chal, sepk) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; login(s, uid)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ceph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; login2(s, e, sessionId, chal)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# calculate shared secret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        server_ephemeral_public_key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; VerifyingKey&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;from_string(sepk, NIST256p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ceph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_received_public_key(server_ephemeral_public_key)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        shared_secret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ceph&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;generate_sharedsecret_bytes()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# if shared secret ends with |\x01 , request for the flag&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# (we aren&amp;#39;t explicitly checking for |\x01 because there is a chance&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# it could end with |\x00\x01 etc., which is still valid, slightly increasing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# our chances)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        token  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shared_secret
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        token &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; long_to_bytes(spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;USER)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        role &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_long(token&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;|&amp;#39;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; role &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; spb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ADMIN:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request_msg(s, sessionId, uid, ceph, sepk)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Got the flag: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;msg &lt;span style=&#34;color:#e6db74&#34;&gt;= }&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            exit()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After ~30 minutes and running multiple instances, we actually got the flag: &lt;code&gt;cybears{Wh1ch_pr0gr4m_d0_j3d1_us3_t0_op3n_PDF_f1l35?Ad0b3_W4n_K3n0b1!}&lt;/code&gt;&lt;/p&gt;

  &lt;img src=&#34;./img/got_the_fricking_flag.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;Full solve script:



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;467295183&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;467295183&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;remote_brute.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
&amp;#39;&amp;#39;&amp;#39;

python3 client.py -r arpeeceethree.chal.cybears.io:2323



&amp;#39;&amp;#39;&amp;#39;

from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey



def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ECDH(curve=NIST256p)
    client_ephemeral_ecdh.generate_private_key()
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    # log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    # log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    # log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

from tqdm import tqdm

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    logging.root.setLevel(logging.ERROR)

    while True:
        s = remote(host, port)
        e = create_user()
        uid = register(s,e)
        for i in tqdm(range(0, 1000)):
            (sessionId, chal, sepk) = login(s, uid)
            ceph = login2(s, e, sessionId, chal)

            # calculate shared secret
            server_ephemeral_public_key = VerifyingKey.from_string(sepk, NIST256p)
            ceph.load_received_public_key(server_ephemeral_public_key)
            shared_secret = ceph.generate_sharedsecret_bytes()

            # if shared secret ends with |\x01 , request for the flag
            # (we aren&amp;#39;t explicitly checking for |\x01 because there is a chance
            # it could end with |\x00\x01 etc., which is still valid, slightly increasing
            # our chances)
            token  = shared_secret
            token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
            role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
            if role == spb.ADMIN:
                msg = request_msg(s, sessionId, uid, ceph, sepk)
                print(f&amp;#34;Got the flag: {msg = }&amp;#34;)
                exit()
            else:
                continue

        s.close()


&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

&lt;/p&gt;
&lt;h3 id=&#34;a-better-solution&#34;&gt;A better solution&lt;/h3&gt;
&lt;p&gt;Even though it worked, I thought that brute forcing on remote was probably unintended, and there should&amp;rsquo;ve been some way to brute force locally, but I couldn&amp;rsquo;t see how. Turns out my reading comprehension failed me again - I thought that the server uses the our public key we provided when registering to calculate the shared secret, but actually we provide it with another, ephemeral public key for the session when logging in.&lt;/p&gt;
&lt;p&gt;Since the server provides us with its ephermeral public key alongside the challenge, we can generate private keys and calculate the shared secret locally. If the shared secret ends with &lt;code&gt;|\x01&lt;/code&gt;, we use that public key and send it to the server, which should compute the same shared secret, and give us the flag. This way, we don&amp;rsquo;t need to brute force remote and can get the flag quickly in just one attempt.&lt;/p&gt;
&lt;p&gt;Better solve script:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;532786419&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;532786419&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;code.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
&amp;#39;&amp;#39;&amp;#39;

python3 client.py -r arpeeceethree.chal.cybears.io:2323



&amp;#39;&amp;#39;&amp;#39;

from pwn import * 
from google.protobuf.internal.encoder import _VarintEncoder
from google.protobuf.internal.decoder import _DecodeVarint
import server_pb2 as spb
from google.protobuf.internal.decoder import _DecodeError
import sys 
import argparse

import Crypto.Cipher.AES as AES
import Crypto.Hash.SHA512 as SHA512
from Crypto.Protocol.KDF import HKDF
from Crypto.Util.number import long_to_bytes, bytes_to_long

from ecdsa import ECDH, NIST256p, VerifyingKey



def send_message(s, msg):
    &amp;#34;&amp;#34;&amp;#34; Send a message, prefixed with its size, to a TPC/IP socket &amp;#34;&amp;#34;&amp;#34;
    data = msg.SerializeToString()
    mh = spb.MessageHeader()
    mh.msglen = len(data)
    mh.type = msg.type
    s.send(mh.SerializeToString() &amp;#43; data)
    return 

def msg_type(msgtype):
    if msgtype == spb.MSG_LOGIN_REQUEST:
        return spb.LoginRequest()
    elif msgtype == spb.MSG_LOGIN_RESPONSE:
        return spb.LoginResponse()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE:
        return spb.LoginChallenge()
    elif msgtype == spb.MSG_LOGIN_CHALLENGE_RESPONSE:
        return spb.LoginChallengeResponse()
    elif msgtype == spb.MSG_REGISTER_REQUEST:
        return spb.RegisterRequest()
    elif msgtype == spb.MSG_REGISTER_RESPONSE:
        return spb.RegisterResponse()
    elif msgtype == spb.MSG_MESSAGE_REQUEST:
        return spb.MessageRequest()
    elif msgtype == spb.MSG_MESSAGE_RESPONSE:
        return spb.MessageResponse()
    else:
        return None


def check_fields(msg):
    result = True
    for field in msg.DESCRIPTOR.fields_by_name.keys():
        if msg.DESCRIPTOR.fields_by_name[field].label == msg.DESCRIPTOR.fields_by_name[field].LABEL_REQUIRED:
            result &amp;amp;= msg.HasField(field)
    return result

def recv_message(s):
    &amp;#34;&amp;#34;&amp;#34; Receive a message, prefixed with its size and type, from stdin &amp;#34;&amp;#34;&amp;#34;
    # Receive the size of the message data
    # expect [MessageHeader][Message of type]
    data = b&amp;#39;&amp;#39;
    header = spb.MessageHeader()
    while True:
        data&amp;#43;= s.recv(1)
        try:
            header.ParseFromString(data)
            if check_fields(header):
                break
        except _DecodeError as e:
            pass

    # Receive the message data
    data = s.recv(header.msglen)

    # Decode the message and validate all required fields are present
    msg = msg_type(header.type)
    if msg != None:
        try:
            msg.ParseFromString(data)
            if not check_fields(msg):
                return None
            return msg
        except _DecodeError:
            return None
    else:
        return None

def create_user():
    client_ecdh = ECDH(curve=NIST256p)
    client_ecdh.generate_private_key()
    return client_ecdh

def register(s, ecdh, name=b&amp;#39;bumblebear&amp;#39;, pubkey=b&amp;#39;&amp;#39;):
    ## REGISTER
    rr = spb.RegisterRequest()
    rr.type = spb.MSG_REGISTER_REQUEST
    rr.name = name
    if pubkey == b&amp;#39;&amp;#39;:
        rr.clientPublicKey = ecdh.get_public_key().to_string(encoding=&amp;#39;compressed&amp;#39;)
    else:
        rr.clientPublicKey = pubkey

    send_message(s, rr)

    ## REGISTER RESPONSE
    reg_resp = recv_message(s)
    if reg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(reg_resp))
    if reg_resp.status == spb.FAILURE:
        log.error(&amp;#34;failed to register&amp;#34;)
    uid = reg_resp.uid
    return uid

def login(s, uid):
    ## LOGIN
    l = spb.LoginRequest()
    l.type = spb.MSG_LOGIN_REQUEST
    l.uid = uid
    send_message(s, l)

    ## LOGIN RESPONSE
    login_resp = recv_message(s)
    if login_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(login_resp))
    
    return login_resp.sessionId, login_resp.challenge, login_resp.ephemeralServerPublicKey


def login2(s, ecdh, ephemeral_ecdh, sessionId, challenge):
    ## SIGN CHALLENGE
    sig = ecdh.private_key.sign_deterministic(challenge)

    ## GENERATE EPHEMERAL DH SESSION KEY
    client_ephemeral_ecdh = ephemeral_ecdh
    client_ephemeral_public_key = client_ephemeral_ecdh.get_public_key()

    send_chal = spb.LoginChallenge()
    send_chal.type = spb.MSG_LOGIN_CHALLENGE
    send_chal.sessionId = sessionId
    send_chal.ephemeralClientPublicKey = client_ephemeral_public_key.to_string(encoding=&amp;#39;compressed&amp;#39;)

    send_chal.challengeResponse = sig
    send_message(s, send_chal)

    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    return client_ephemeral_ecdh

def request_msg(s, sessionId, uid, client_ephemeral, server_ephemeral):
    ## REQUEST MESSAGE
    # log.info(&amp;#34;sending message request&amp;#34;)
    msg_req = spb.MessageRequest()
    msg_req.type = spb.MSG_MESSAGE_REQUEST
    msg_req.sessionId = sessionId

    send_message(s, msg_req)

    # log.info(&amp;#34;receiving message&amp;#34;)
    msg_resp = recv_message(s)
    if msg_resp != None:
        pass
        # log.info(&amp;#34;DEBUG: received {}&amp;#34;.format(msg_resp))

    ## DECRYPT MESSAGE
    server_ephemeral_public_key = VerifyingKey.from_string(server_ephemeral, NIST256p)

    client_ephemeral.load_received_public_key(server_ephemeral_public_key)
    shared_secret = client_ephemeral.generate_sharedsecret_bytes()

    token  = shared_secret
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(uid)
    token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; sessionId
    (aes_gcm_key, nonce) = HKDF(token, 16, &amp;#39;&amp;#39;, SHA512, num_keys=2)

    a = AES.new(aes_gcm_key, AES.MODE_GCM, nonce = nonce)
    message = a.decrypt_and_verify(msg_resp.encMsg, msg_resp.encMsgTag)

    # log.info(&amp;#34;message received: {}&amp;#34;.format(message))
    return message

from tqdm import tqdm

if __name__ == &amp;#34;__main__&amp;#34;:

    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;#39;-r&amp;#39;, &amp;#39;--remote&amp;#39;, help=&amp;#34;The address:port of the remote server hosting the challenge&amp;#34;, required=True)
    args = parser.parse_args()

    if args.remote != None:
        host = args.remote.split(&amp;#34;:&amp;#34;)[0]
        port = int(args.remote.split(&amp;#34;:&amp;#34;)[1])
    else:
        exit(0)

    logging.root.setLevel(logging.ERROR)

    s = remote(host, port)

    # register
    e = create_user()
    uid = register(s,e)

    # login step 1
    (sessionId, chal, sepk) = login(s, uid)
    server_ephemeral_ecdh_pubkey = VerifyingKey.from_string(sepk, NIST256p)

    # generate private keys until shared secret is what we want
    while True:
        client_ephemeral_ecdh = ECDH(curve=NIST256p)
        client_ephemeral_ecdh.generate_private_key()
        
        # calculate shared secret
        client_ephemeral_ecdh.load_received_public_key(server_ephemeral_ecdh_pubkey)
        shared_secret = client_ephemeral_ecdh.generate_sharedsecret_bytes()
        
        token = shared_secret
        token &amp;#43;= b&amp;#39;|&amp;#39; &amp;#43; long_to_bytes(spb.USER)
        role = bytes_to_long(token.split(b&amp;#39;|&amp;#39;)[1])
        if role == spb.ADMIN:
            break

    login2(s, e, client_ephemeral_ecdh, sessionId, chal)
    
    msg = request_msg(s, sessionId, uid, client_ephemeral_ecdh, sepk)
    print(f&amp;#34;Got the flag: {msg = }&amp;#34;)



&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;BSides Canberra 2024 was again, a great conference, and &lt;a href=&#34;https://x.com/cybearsctf&#34;&gt;Cybears&lt;/a&gt; hosted another fun CTF! I believe it&amp;rsquo;s truely one of the best conferences out there, and I&amp;rsquo;ll definitely be coming back next year!&lt;/p&gt;
&lt;p&gt;I was able to attend thanks to the &lt;a href=&#34;https://www.bsidesau.com.au/assistance.html&#34;&gt;Assistance Program&lt;/a&gt;, which covered my flights and hotel, so special thanks to Kylie, Silvio and Danielle for making this possible!&lt;/p&gt;
&lt;p&gt;For coming 2nd place, we won $500, and a Dungeons and Dragons lego set! We, alongside the other winning teams, skateboarding dogs and French Roomba, all decided to donate our prize money to the Assistance Program, and we hope this helps other people attend the conference in the future! We&amp;rsquo;re keeping the lego set though :P&lt;/p&gt;
&lt;p&gt;Btw, if you spotted any errors/typos in the blog, or have questions, feel free to DM/ping me on discord &lt;code&gt;thesavageteddy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;teddy / TheSavageTeddy&lt;/li&gt;
&lt;/ul&gt;

  &lt;img src=&#34;./img/conference.jpg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


</content>
    </item>
    
    <item>
      <title>Reversing Writeups - BSides Canberra CTF 2023</title>
      <link>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/</link>
      <pubDate>Sun, 01 Oct 2023 03:06:40 +1100</pubDate>
      
      <guid>https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;During the school holidays, I had the opportunity to attend BSides Canberra 2023, which was a 3 day conference held near the end of September, in the National Convention Center Canberra.&lt;/p&gt;
&lt;p&gt;Along with many great talks, it featured three &amp;lsquo;villages&amp;rsquo; including hardware, lockpicking and wireless. With 3000 people attending, this was the largest hacking conference that I had gone to, and it was a lot of fun!&lt;/p&gt;

  &lt;img src=&#34;./img/ctfing.jpg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;&lt;a href=&#34;https://twitter.com/cybearsCTF&#34;&gt;Cybears&lt;/a&gt; hosted this year&amp;rsquo;s CTF event with unique comic style graphics for the CTF site. They had some great challenges, and the competition hall was packed with 193 teams participating!&lt;/p&gt;</description>
      <content>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;During the school holidays, I had the opportunity to attend BSides Canberra 2023, which was a 3 day conference held near the end of September, in the National Convention Center Canberra.&lt;/p&gt;
&lt;p&gt;Along with many great talks, it featured three &amp;lsquo;villages&amp;rsquo; including hardware, lockpicking and wireless. With 3000 people attending, this was the largest hacking conference that I had gone to, and it was a lot of fun!&lt;/p&gt;

  &lt;img src=&#34;./img/ctfing.jpg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;&lt;a href=&#34;https://twitter.com/cybearsCTF&#34;&gt;Cybears&lt;/a&gt; hosted this year&amp;rsquo;s CTF event with unique comic style graphics for the CTF site. They had some great challenges, and the competition hall was packed with 193 teams participating!&lt;/p&gt;
&lt;p&gt;I played with &lt;a href=&#34;https://twitter.com/EmuExploit&#34;&gt;&lt;code&gt;Emu Exploit&lt;/code&gt;&lt;/a&gt; and overall we came 3rd in the CTF, and recieved a massive cardboard cheque of $250 and a medal - congrats to &lt;code&gt;skateboarding roomba&lt;/code&gt; and &lt;code&gt;Grassroots Indirection&lt;/code&gt; on 1st and 2nd!&lt;/p&gt;

  &lt;img src=&#34;./img/scoreboard.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px;&#34;  /&gt;


&lt;p&gt;In this blog post, I will provide an in-depth walkthough to &lt;code&gt;prnginko&lt;/code&gt;, a crypto/rev challenge which caused me a lot of pain, and a brief writeup of &lt;code&gt;useless&lt;/code&gt;, another rev challenge.&lt;/p&gt;
&lt;h1 id=&#34;challenge-overview&#34;&gt;Challenge Overview&lt;/h1&gt;
&lt;p&gt;I will mainly focus on &lt;code&gt;prnginko&lt;/code&gt;, as I want to detail the many roadblocks we faced along the way, instead of going straight to the solution.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Challenge&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Category&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;Solves&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/#prnginko-cryptorev---8-solves&#34;&gt;prnginko&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;crypto/rev&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/#useless-rev---9-solves&#34;&gt;useless&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;rev&lt;/td&gt;
          &lt;td&gt;9&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If you want to follow along or see the binary for yourself, download files here&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/files/prnginko&#34;&gt;&lt;code&gt;prnginko&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/files/useless&#34;&gt;&lt;code&gt;useless&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;prnginko-cryptorev---8-solves&#34;&gt;prnginko (crypto/rev) - 8 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Multi-bet with SportsBear!&lt;/p&gt;
&lt;p&gt;nc prnginko.chal.cybears.io 2323&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are given a binary &lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/files/prnginko&#34;&gt;&lt;code&gt;prnginko&lt;/code&gt;&lt;/a&gt; and a service to connect to. Upon running the binary, we are presented with the game and a message suggesting the goal to be getting a &amp;ldquo;perfect game&amp;rdquo;. The game includes a board consisting of pins and a ball which randomly bounces either left or right when it hits a pin, similar to the Plinko game.&lt;/p&gt;

  &lt;img src=&#34;./img/game_ex.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 70%&#34;  /&gt;


&lt;p&gt;We have two options - &lt;code&gt;g&lt;/code&gt; to play a game and earn points, or &lt;code&gt;p&lt;/code&gt; to practice. We can play 10 games in total and need to get the maximum score of &lt;code&gt;16&lt;/code&gt; each time to win.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;prng&amp;rdquo; in the challenge name suggests that we need to reverse engineer the program to find the PRNG it uses to determine if the ball will go left or right, and crack it to find what future game plays will yield. Then, by being able to predict the future, we can &lt;strong&gt;use the practice games to re-roll the PRNG&lt;/strong&gt; until we know the next game will yield a max score of 16, and then use one of our game rounds.&lt;/p&gt;
&lt;p&gt;A quick explanation of why we can do this - PRNGs (pseudo random number generator) usually use a &lt;em&gt;seed&lt;/em&gt; and some other parameters to generate the next &amp;ldquo;random&amp;rdquo; number using some math. If the same seed and same parameters are used, then the next random number it generates will be the same. Thus, if we are able to recover the seed and know the parameters, we can predict the values it will generate in the future.&lt;/p&gt;
&lt;p&gt;Hopping into &lt;a href=&#34;https://hex-rays.com/ida-free/&#34;&gt;IDA&lt;/a&gt;, we can see the &lt;code&gt;160&lt;/code&gt; points required to win, which is getting &lt;code&gt;16&lt;/code&gt; points ten times - a perfect game.&lt;/p&gt;

  &lt;img src=&#34;./img/ida_1.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;Note that function and variable names were stripped in the binary, so we had to go through and rename everything relevant as always.&lt;/p&gt;
&lt;p&gt;After some reverse engineering, we find a few functions that together form a PRNG based on the program&amp;rsquo;s current runtime.&lt;/p&gt;
&lt;p&gt;There are three functions:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get_timeseed()&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is only called once, at the start of the program&lt;/li&gt;
&lt;li&gt;Gets a value affected by time using &lt;code&gt;clock_gettime()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Sets &lt;code&gt;time_seed&lt;/code&gt; to the amount of seconds, plus &lt;code&gt;1000000000&lt;/code&gt; times the amount of &lt;strong&gt;nanoseconds&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_timeseed&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; timespec tp; &lt;span style=&#34;color:#75715e&#34;&gt;// [rsp+10h] [rbp-20h] BYREF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; v2; &lt;span style=&#34;color:#75715e&#34;&gt;// [rsp+28h] [rbp-8h]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  v2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__readfsqword&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x28u&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( &lt;span style=&#34;color:#a6e22e&#34;&gt;clock_gettime&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;tp) )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4294967293LL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  time_seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LODWORD&lt;/span&gt;(tp.tv_sec) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000000&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LODWORD&lt;/span&gt;(tp.tv_nsec);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0LL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;prng_subpart()&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does some math with &lt;code&gt;a_value&lt;/code&gt; and &lt;code&gt;time_seed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Changes &lt;code&gt;a_value&lt;/code&gt; (&lt;code&gt;HIDWORD&lt;/code&gt; gets the higher 32 bits, same as shifting right by 32 bits) and &lt;code&gt;time_seed&lt;/code&gt; based on the math calculation&lt;/li&gt;
&lt;li&gt;Returns the result of the math calculation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a_value&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; at the start of the program&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prng_subpart&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; var8; &lt;span style=&#34;color:#75715e&#34;&gt;// [rsp+0h] [rbp+0h]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var8 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)a_value &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xC5D8A3FF84711ALL&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)time_seed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  a_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HIDWORD&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var8 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  time_seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var8 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)time_seed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;prng_main()&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prng_main()&lt;/code&gt; calls &lt;code&gt;prng_subpart()&lt;/code&gt; only when &lt;code&gt;shift_r_value&lt;/code&gt; is below zero&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift_r_value&lt;/code&gt; is the amount that the &lt;code&gt;prng_output&lt;/code&gt; is right shifted&lt;/li&gt;
&lt;li&gt;The function returns the lowest bit of &lt;code&gt;prng_output &amp;gt;&amp;gt; shift_r_value&lt;/code&gt; (using &lt;code&gt;&amp;amp; 1&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift_r_value&lt;/code&gt; is initialized to &lt;code&gt;-1&lt;/code&gt; at the start, so &lt;code&gt;prng_output&lt;/code&gt; is called at the start&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prng_main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( shift_r_value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; )
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    shift_r_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    prng_output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prng_subpart&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)prng_output &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; shift_r_value&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As global variables, the initial values of &lt;code&gt;shift_r_value&lt;/code&gt; and &lt;code&gt;a_value&lt;/code&gt; were located in the &lt;code&gt;.data&lt;/code&gt; section, or just double click in IDA to find them.&lt;/p&gt;
&lt;p&gt;The main takeaway from these functions is that we know all of the values, &lt;strong&gt;except &lt;code&gt;time_seed&lt;/code&gt;&lt;/strong&gt;. &lt;code&gt;time_seed&lt;/code&gt; is the only value that is causing the output to not be identical - it&amp;rsquo;s the only value that changes &amp;ldquo;randomly&amp;rdquo; each time we run the program, so we need a way to recover it.&lt;/p&gt;
&lt;p&gt;Of course it is a horrible idea to seed a PRNG based on time, but it uses nanosecond precision which we cannot accurately predict on a remote instance.&lt;/p&gt;
&lt;p&gt;However, if we &lt;em&gt;did&lt;/em&gt; know the value of &lt;code&gt;time_seed&lt;/code&gt;, that&amp;rsquo;s all that&amp;rsquo;s left to input into our own PRNG and predict the future!&lt;/p&gt;
&lt;p&gt;To start off simple, let&amp;rsquo;s write out the PRNG functions in Python.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;prng.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
def get_timeseed():
    # we&amp;#39;ll figure out how to get this later ;)
    timeseed = int(input(&amp;#34;Enter timeseed: &amp;#34;))
    return timeseed

def prng_subpart():
    global time_seed, a_value

    output = a_value - 0xC5D8A3FF84711A * time_seed
    a_value = output &amp;gt;&amp;gt; 32
    time_seed = output
    return time_seed

def prng_main():
    global shift_r_value, prng_output

    if shift_r_value &amp;lt; 0:
        shift_r_value = 31
        prng_output = prng_subpart()
    output = (prng_output &amp;gt;&amp;gt; shift_r_value) &amp;amp; 1
    shift_r_value -= 1
    return output

prng_output = None
shift_r_value = -1
a_value = 1
time_seed = get_timeseed()

for i in range(8):
    print(f&amp;#34;Value of output {i}: {prng_main()}&amp;#34;)

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;But how do we know this is correct? (foreshadowing: it&amp;rsquo;s not quite&amp;hellip;)&lt;/p&gt;
&lt;p&gt;In IDA we can see &lt;code&gt;time_seed&lt;/code&gt; is stored in &lt;code&gt;.bss&lt;/code&gt;, so let&amp;rsquo;s test our PRNG replication by debugging and just grabbing the value directly.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;info file&lt;/code&gt; to locate address of &lt;code&gt;.bss&lt;/code&gt;, we dump &lt;code&gt;.bss&lt;/code&gt; to find &lt;code&gt;time_seed&lt;/code&gt;, which as an &lt;code&gt;unsigned int&lt;/code&gt; is a 4 byte value at offset &lt;code&gt;0x44&lt;/code&gt;, same as what IDA shows.&lt;/p&gt;

  &lt;img src=&#34;./img/prng_2.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;Next, we chuck this &lt;code&gt;time_seed&lt;/code&gt; value into our own PRNG and see if our outputs correlates with the game&amp;rsquo;s outputs.&lt;/p&gt;

  &lt;img src=&#34;./img/prng_work.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;It indeed does! &lt;code&gt;0&lt;/code&gt; indicates that the ball goes left, and &lt;code&gt;1&lt;/code&gt; indicates the ball goes right.&lt;/p&gt;
&lt;h4 id=&#34;a-roadblock&#34;&gt;A Roadblock&lt;/h4&gt;
&lt;p&gt;However, there is one flaw I would like to point out here - &lt;strong&gt;there is a mistake in our Python PRNG&lt;/strong&gt;. This subtle mistake cost hours of debugging and pain - I said that I would eat breakfast after solving the challenge. I ended up eating lunch instead.&lt;/p&gt;
&lt;p&gt;You may wonder, well, the PRNG seems to be giving the correct output though? It predicted 8 values correctly. That is true, until you go after 64 values.&lt;/p&gt;
&lt;p&gt;It turns out that &lt;strong&gt;we forgot to account for the C datatypes in python&lt;/strong&gt;! &lt;code&gt;output&lt;/code&gt; (&lt;code&gt;var8&lt;/code&gt;) is an &lt;code&gt;int64&lt;/code&gt;, which means if we go over &lt;code&gt;2**63&lt;/code&gt; or under &lt;code&gt;-2**63&lt;/code&gt;, it will wrap around, same as &lt;code&gt;mod 2**64&lt;/code&gt;. We didn&amp;rsquo;t account for this - thus eventually after two outputs of &lt;code&gt;prng_subpart&lt;/code&gt;, &lt;code&gt;time_seed&lt;/code&gt; became large enough to surpass this limit and provide incorrect outputs.&lt;/p&gt;
&lt;p&gt;To account for this we will add &lt;code&gt;output = output % (2**64)&lt;/code&gt; and &lt;code&gt;time_seed = output % (2**32)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The fixed code is now:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;prng.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
def get_timeseed():
    # we&amp;#39;ll figure out how to get this later ;)
    timeseed = int(input(&amp;#34;Enter timeseed: &amp;#34;))
    
    return timeseed

def prng_subpart():
    global time_seed, a_value

    output = a_value - 0xC5D8A3FF84711A * time_seed
    output = output % (2**64)
    a_value = output &amp;gt;&amp;gt; 32
    time_seed = output % (2**32)
    return time_seed

def prng_main():
    global shift_r_value, prng_output

    if shift_r_value &amp;lt; 0:
        shift_r_value = 31
        prng_output = prng_subpart()
    output = (prng_output &amp;gt;&amp;gt; shift_r_value) &amp;amp; 1
    shift_r_value -= 1
    return output

prng_output = None
shift_r_value = -1
a_value = 1
time_seed = get_timeseed()

for _ in range(10):
    for i in range(8):
        print(f&amp;#34;Value of output {i}: {prng_main()}&amp;#34;)
    print()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h4 id=&#34;back-to-the-challenge&#34;&gt;Back to the challenge&amp;hellip;&lt;/h4&gt;
&lt;p&gt;With that issue fixed, we can continue on with the challenge.&lt;/p&gt;
&lt;p&gt;We have successfully recreated the PRNG and can predict future outputs given &lt;code&gt;time_seed&lt;/code&gt;, now only one problem remains - how can we retrieve the value of &lt;code&gt;time_seed&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;As mentioned before, &lt;code&gt;time_seed&lt;/code&gt; is affected by time in nanoseconds, which would be close to impossible to simulate on a remote connection.&lt;/p&gt;
&lt;p&gt;Another idea is to brute force. As it is a &lt;code&gt;unsigned int32&lt;/code&gt;, we can try &lt;code&gt;2**32&lt;/code&gt; possible values for &lt;code&gt;time_seed&lt;/code&gt;, until our PRNG output seems to match up with the game&amp;rsquo;s output. However, this is also not possible since although &lt;code&gt;2**32&lt;/code&gt; is not too large, there is a timer set for 5 minutes, and with a quick test it would take way too long to brute force in under 5 minutes (at least in python).&lt;/p&gt;

  &lt;img src=&#34;./img/alarm.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;Our last option is to use an SMT solver, such as &lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;z3&lt;/a&gt;. We can simply get a bunch of outputs from the game, then tell z3 that it should try to find a value of &lt;code&gt;time_seed&lt;/code&gt; that causes our PRNG to output the same as the game.&lt;/p&gt;
&lt;p&gt;For example, if a round of our game outputs &lt;code&gt;LRRLRLLL&lt;/code&gt; where &lt;code&gt;L&lt;/code&gt; is left and &lt;code&gt;R&lt;/code&gt; is right, we can change it to &lt;code&gt;01101000&lt;/code&gt;, and tell z3 that the first output of our PRNG should be &lt;code&gt;0&lt;/code&gt;, the second should be &lt;code&gt;1&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;p&gt;First, we define &lt;code&gt;time_seed&lt;/code&gt; as a &lt;strong&gt;64-bit&lt;/strong&gt; value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time_seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BitVec(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;time_seed&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But wait - why should it be 64-bits when we know it is actually a 32-bit value?&lt;/p&gt;
&lt;p&gt;Well, if we look at the decompilation again, we can see &lt;code&gt;time_seed&lt;/code&gt; is being set to &lt;code&gt;var8&lt;/code&gt;, and &lt;code&gt;var8&lt;/code&gt; is 64 bits. This means that the first calculation can result in a 64 bit value, causing time_seed to be set to a value larger than 64 bits.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prng_subpart&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;__int64&lt;/span&gt; var8; &lt;span style=&#34;color:#75715e&#34;&gt;// [rsp+0h] [rbp+0h]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var8 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)a_value &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xC5D8A3FF84711ALL&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)time_seed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  a_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HIDWORD&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var8 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  time_seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var8 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)time_seed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This issue caused us a lot of pain as well.&lt;/p&gt;
&lt;p&gt;Anyways, we then collect the game&amp;rsquo;s PRNG outputs from the result of some practice rounds.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_game_output&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvuntil(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;gt; &amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sendline(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;p&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# play practice round&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    outputs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        game_output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decode()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; game_output[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;L&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            outputs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; game_output[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;R&amp;#34;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            outputs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recvline()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; outputs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trials &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;game_outputs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; trial &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(trials):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    game_outputs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;extend(get_game_output())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;game_outputs &lt;span style=&#34;color:#e6db74&#34;&gt;= }&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Doing 8 trials, which gets 64 bits from the game should be enough for z3 to compute a unique solution (you might imagine if we had only 1 trial, there could be many possible &lt;code&gt;time_seed&lt;/code&gt;s that can result in the same output).&lt;/p&gt;
&lt;p&gt;Then we simply tell z3 that these values should be equal, and also add that &lt;code&gt;time_seed&lt;/code&gt; should be within the 32 integer range.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;prng_output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;shift_r_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time_seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BitVec(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;time_seed&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time_seed_copy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; time_seed
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;context&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;binary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; elf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ELF(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./prnginko&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; process(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./prnginko&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;trials &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;game_outputs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; trial &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(trials):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    game_outputs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;extend(get_game_output())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Solver()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(time_seed &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(time_seed &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; bit &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; game_outputs:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(prng_main() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; bit)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;check() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; sat
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;model()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;correct_time_seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(m[time_seed_copy]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;as_long())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;correct_time_seed &lt;span style=&#34;color:#e6db74&#34;&gt;= }&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also note that above I have made a copy of &lt;code&gt;time_seed&lt;/code&gt; called &lt;code&gt;time_seed_copy&lt;/code&gt; as &lt;code&gt;time_seed&lt;/code&gt; was being overwritten in the PRNG functions, thus a Z3 declaration had to be retained to retrieve the time from the model.&lt;/p&gt;
&lt;h4 id=&#34;getting-the-flag&#34;&gt;Getting the flag&lt;/h4&gt;
&lt;p&gt;Now that our PRNG is working, and z3 gives us the correct &lt;code&gt;time_seed&lt;/code&gt;, we can finally get the flag. All we do is to count how many times we need to reroll the PRNG until it gives us all &lt;code&gt;0&lt;/code&gt;&amp;rsquo;s or all &lt;code&gt;1&lt;/code&gt;&amp;rsquo;s (which will give us the max points), then use a game round.&lt;/p&gt;
&lt;p&gt;Final code:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;solve.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from z3 import *
from pwn import *
# local file of our PRNG to avoid z3 symbolic values being used
import prng

def prng_subpart():
    global time_seed, a_value

    output = a_value - 0xC5D8A3FF84711A * time_seed
    output = output % (2**64)
    a_value = LShR(output, 32)
    time_seed = output % (2**32)
    return time_seed

def prng_main():
    global shift_r_value, prng_output

    if shift_r_value &amp;lt; 0:
        shift_r_value = 31
        prng_output = prng_subpart()
    output = LShR(prng_output, shift_r_value) &amp;amp; 1
    shift_r_value -= 1
    return output

def get_game_output():
    p.recvuntil(b&amp;#34;&amp;gt; &amp;#34;)
    p.sendline(b&amp;#34;p&amp;#34;) # play practice round
    
    outputs = []
    for i in range(8):
        game_output = p.recvline().decode()
        if game_output[0] == &amp;#34;L&amp;#34;:
            outputs.append(0)
        elif game_output[0] == &amp;#34;R&amp;#34;:
            outputs.append(1)
        p.recvline()
        p.recvline()
    return outputs

def play_game_round():
    p.recvuntil(b&amp;#34;&amp;gt;&amp;#34;)
    p.sendline(b&amp;#34;g&amp;#34;) # play game round

context.binary = elf = ELF(&amp;#34;./prnginko&amp;#34;)
# p = process(&amp;#34;./prnginko&amp;#34;)
p = remote(&amp;#34;prnginko.chal.cybears.io&amp;#34;, 2323)

game_rounds = 10

prng_output = None
shift_r_value = -1
a_value = 1
time_seed = BitVec(&amp;#39;time_seed&amp;#39;, 64)
time_seed_copy = time_seed

trials = 8
game_outputs = []
for trial in range(trials):
    game_outputs.extend(get_game_output())

s = Solver()
s.add(time_seed &amp;gt;= 0)
s.add(time_seed &amp;lt;= 2**32)
for bit in game_outputs:
    s.add(prng_main() == bit)

assert s.check() == sat
m = s.model()
correct_time_seed = int(m[time_seed_copy].as_long())
print(f&amp;#34;{correct_time_seed = }&amp;#34;)

prng.set_time_seed(correct_time_seed)

# need to fast forward our PRNG to match the game&amp;#39;s state
# as earlier we played 8 rounds to get the outputs.
# must times 8 because each round has 8 outputs
for trial in range(trials * 8):
    prng.prng_main()

for game_round in range(game_rounds):
    practice_round_count = 0
    while True:
        next_round_result = [prng.prng_main() for _ in range(8)]
        # check if all 1&amp;#39;s or all 0&amp;#39;s
        if len(set(next_round_result)) == 1:
            # send number of practice rounds we want to
            # play at same time to avoid taking too
            # long to recieve data
            p.send(b&amp;#34;p\n&amp;#34; * practice_round_count)
            play_game_round()
            break
        practice_round_count &amp;#43;= 1

p.interactive()

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;prng.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
def prng_subpart():
    global time_seed, a_value

    output = a_value - 0xC5D8A3FF84711A * time_seed
    output = output % (2**64)
    a_value = output &amp;gt;&amp;gt; 32
    time_seed = output % (2**32)
    return time_seed

def prng_main():
    global shift_r_value, prng_output

    if shift_r_value &amp;lt; 0:
        shift_r_value = 31
        prng_output = prng_subpart()
    output = (prng_output &amp;gt;&amp;gt; shift_r_value) &amp;amp; 1
    shift_r_value -= 1
    return output

def set_time_seed(_time_seed):
    global prng_output, shift_r_value, a_value, time_seed

    prng_output = None
    shift_r_value = -1
    a_value = 1
    time_seed = _time_seed
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;



  &lt;img src=&#34;./img/finally.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 80%&#34;  /&gt;


&lt;p&gt;&lt;code&gt;cybears{Pr3d1ctable_gam3_for_P3rf3ct_Gambl1ng}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Note that in the final solve script, I imported a separate python file named &lt;code&gt;prng&lt;/code&gt; with the same PRNG implementation for several reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In z3, &lt;code&gt;LShR&lt;/code&gt; should be used instead of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; to perform right shifts (more info &lt;a href=&#34;https://stackoverflow.com/questions/25532563/why-does-z3-say-that-this-equation-is-not-satisfiable-when-i-have-input-that-is&#34;&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Symbolic values were passed through the functions making it return another symbolic value when called. Basically I wanted it to return a number not an equation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I would like to thank &lt;a href=&#34;https://twitter.com/stacksparrow4&#34;&gt;&lt;code&gt;ssparrow&lt;/code&gt;&lt;/a&gt; for helping me debug the code and for finding the issues that stumped me for hours.&lt;/p&gt;
&lt;h4 id=&#34;a-much-simpler-solution&#34;&gt;A much simpler solution&lt;/h4&gt;
&lt;p&gt;After the CTF ended, I talked to &lt;code&gt;Neobeo&lt;/code&gt; who played for Skateboarding Roombas in this CTF about the challenge.&lt;/p&gt;
&lt;p&gt;He revealed a much easier solution that didn&amp;rsquo;t need any messing around in z3 - the PRNG was actually an LCG! In case you didn&amp;rsquo;t know, an LCG is in the form&lt;/p&gt;
&lt;p&gt;$$S_{n+1} = S_n \times a + b \bmod{m}$$&lt;/p&gt;
&lt;p&gt;where the next term is the current term &lt;code&gt;S_n&lt;/code&gt; times &lt;code&gt;a&lt;/code&gt; plus &lt;code&gt;b&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are constants. In this case &lt;code&gt;S_n&lt;/code&gt; was &lt;code&gt;time_seed&lt;/code&gt;, and the modulus &lt;code&gt;m&lt;/code&gt; was the 32 bit integer limit. Despite having done LCG challenges in the past, I somehow failed to recognise this!&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;main_prng&lt;/code&gt; was simply returning the MSB (first bit) of the PRNG output, and shifting it to return all bits of the output before retrieving a new random number. &lt;code&gt;prng_subpart&lt;/code&gt; was the actual PRNG, which was an LCG implementation.&lt;/p&gt;
&lt;p&gt;Recovering &lt;code&gt;time_seed&lt;/code&gt; was trivial now that we recognise it as a LCG - we simply need the whole random number returned by &lt;code&gt;prng_subpart&lt;/code&gt; which we can get by playing 4 practice rounds (as each round returns 8 bits).&lt;/p&gt;
&lt;p&gt;Now we simply solve for &lt;code&gt;time_seed&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;$$
S_{n+1} \equiv S_n \times a + b \pmod{2^{32}} \newline
S_n \equiv a^{-1}(S_{n+1} - b) \pmod{2^{32}}
$$&lt;/p&gt;
&lt;p&gt;where &lt;code&gt;S_n&lt;/code&gt; is &lt;code&gt;time_seed&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;a_value&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;-0xC5D8A3FF84711A&lt;/code&gt; and &lt;code&gt;S_n+1&lt;/code&gt; is the 32 bit value returned by playing 4 rounds.&lt;/p&gt;
&lt;p&gt;There is just a slight issue - since both &lt;code&gt;-0xC5D8A3FF84711A&lt;/code&gt; and &lt;code&gt;2**32&lt;/code&gt; are even, there is no modular inverse! We can get around this by dividing everything by two.&lt;/p&gt;
&lt;p&gt;$$
\frac{S_{n+1}}{2} \equiv S_n \times \frac{a}{2} + \frac{b}{2} \pmod{2^{32}} \newline
S_n = (\frac{a}{2})^{-1} \times \frac{S_{n+1} - b}{2} \pmod{2^{31}}
$$&lt;/p&gt;
&lt;p&gt;Thanks again to &lt;code&gt;Neobeo&lt;/code&gt; for showing me this trick.&lt;/p&gt;
&lt;p&gt;However, by doing this we are left with two possible values as we are now solving over &lt;code&gt;mod 2**31&lt;/code&gt; instead of &lt;code&gt;mod 2**32&lt;/code&gt;, so if &lt;code&gt;time_seed&lt;/code&gt; is over &lt;code&gt;2**31&lt;/code&gt; it will get cut off.&lt;/p&gt;
&lt;p&gt;We can verify which is correct by collecting another set of outputs, and seeding with both of the possible seeds. Alternatively, we can just use two sets of outputs to solve for a distinct value.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;python&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;alternative_solve.py&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-python&#34; &gt;&lt;code&gt;
from z3 import *
from pwn import *

def prng_subpart():
    global time_seed, a_value

    output = a_value - 0xC5D8A3FF84711A * time_seed
    output = output % (2**64)
    a_value = output &amp;gt;&amp;gt; 32
    time_seed = output % (2**32)
    return time_seed

def prng_main():
    global shift_r_value, prng_output

    if shift_r_value &amp;lt; 0:
        shift_r_value = 31
        prng_output = prng_subpart()
    output = (prng_output &amp;gt;&amp;gt; shift_r_value) &amp;amp; 1
    shift_r_value -= 1
    return output

def get_game_output():
    p.recvuntil(b&amp;#34;&amp;gt; &amp;#34;)
    p.sendline(b&amp;#34;p&amp;#34;) # play practice round
    
    outputs = []
    for i in range(8):
        game_output = p.recvline().decode()
        if game_output[0] == &amp;#34;L&amp;#34;:
            outputs.append(0)
        elif game_output[0] == &amp;#34;R&amp;#34;:
            outputs.append(1)
        p.recvline()
        p.recvline()
    return outputs

def play_game_round():
    p.recvuntil(b&amp;#34;&amp;gt;&amp;#34;)
    p.sendline(b&amp;#34;g&amp;#34;) # play game round

context.binary = elf = ELF(&amp;#34;./prnginko&amp;#34;)
p = process(&amp;#34;./prnginko&amp;#34;)
# p = gdb.debug(&amp;#34;./prnginko&amp;#34;)
# p = remote(&amp;#34;prnginko.chal.cybears.io&amp;#34;, 2323)

game_rounds = 10
modulus = 2**32

trials = 4 # get the whole 32-bit value
game_outputs = []
for trial in range(trials):
    game_outputs.extend(get_game_output())

print(f&amp;#34;{game_outputs = }&amp;#34;)

S_n1 = 0
for i, game_output in enumerate(game_outputs[::-1]):
    S_n1 &amp;#43;= game_output * (2**i)

calculated_time_seed = pow(-0xC5D8A3FF84711A//2, -1, modulus//2) * ((S_n1 - 1) // 2)
calculated_time_seed %= modulus // 2

possible_seed_1 = calculated_time_seed
possible_seed_2 = calculated_time_seed &amp;#43; modulus//2

# get 2nd set of outputs
game_outputs = []
for trial in range(trials):
    game_outputs.extend(get_game_output())

correct_seed = None
#try our first seed
try:
    time_seed = possible_seed_1
    prng_output = None
    shift_r_value = -1
    a_value = 1
    
    #fast forward to game&amp;#39;s 2nd set of outputs
    for _ in range(trials * 8):
        prng_main()

    for game_output in game_outputs:
        assert prng_main() == game_output
    correct_seed = possible_seed_1
except AssertionError:
    time_seed = possible_seed_2
    prng_output = None
    shift_r_value = -1
    a_value = 1

    #fast forward to game&amp;#39;s 2nd set of outputs
    for _ in range(trials * 8):
        prng_main()

    for game_output in game_outputs:
        # just to double check we&amp;#39;re correct
        assert prng_main() == game_output
    correct_seed = possible_seed_2

time_seed = correct_seed
prng_output = None
shift_r_value = -1
a_value = 1

# fast forward to same PRNG state as the game
for _ in range(trials*8 * 2):
    prng_main()

for game_round in range(game_rounds):
    practice_round_count = 0
    while True:
        next_round_result = [prng_main() for _ in range(8)]
        # check if all 1&amp;#39;s or all 0&amp;#39;s
        if len(set(next_round_result)) == 1:
            # send number of practice rounds we want to
            # play at same time to avoid taking too
            # long to recieve data
            p.send(b&amp;#34;p\n&amp;#34; * practice_round_count)
            play_game_round()
            break
        practice_round_count &amp;#43;= 1

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h1 id=&#34;useless-rev---9-solves&#34;&gt;useless (rev) - 9 solves&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There&amp;rsquo;s a weird file recovered from a forensic analysis of the MAYHEM mainframe&amp;hellip; but it doesn&amp;rsquo;t seem to do anything?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We are provided with a binary file &lt;a href=&#34;https://TheSavageTeddy.github.io/featured/bsides-canberra-ctf-2023/files/useless&#34;&gt;&lt;code&gt;useless&lt;/code&gt;&lt;/a&gt; which when ran, as the name suggests, seemingly does nothing.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(teddykaliteddykali)-[~//on premise/Bsides Canberra 2023/rev/useless]
$ ./useless    
                                                                                                                                                
(teddykaliteddykali)-[~//on premise/Bsides Canberra 2023/rev/useless]
$ 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Decompiling the binary doesn&amp;rsquo;t offer much either - there appear to be thousands of functions named &lt;code&gt;continue_x&lt;/code&gt; which just calls the next one. An interesting thing is that some numbers are skipped (e.g &lt;code&gt;continue_1&lt;/code&gt;) however this didn&amp;rsquo;t seem to help either.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//----- (0000000000401000) ----------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; __noreturn &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;continue_0&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//----- (0000000000401019) ----------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; __noreturn &lt;span style=&#34;color:#a6e22e&#34;&gt;continue_0&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;continue_2&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//----- (000000000040103B) ----------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; __noreturn &lt;span style=&#34;color:#a6e22e&#34;&gt;continue_2&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;continue_3&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// this repeats until continue_2024() !
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The decompilation is rendering useless - looks like we&amp;rsquo;ll need to dig deeper.&lt;/p&gt;
&lt;p&gt;After loading the binary into gdb (with the &lt;a href=&#34;https://github.com/pwndbg/pwndbg&#34;&gt;pwndbg&lt;/a&gt; extension), we use &lt;code&gt;starti&lt;/code&gt; to start running the binary but immediantly breaking, as otherwise the program would just exit.&lt;/p&gt;
&lt;p&gt;Next, stepping through instruction with &lt;code&gt;si&lt;/code&gt; , I noticed an unusual value in the &lt;code&gt;rax&lt;/code&gt; register, which turned out to be a printable character.&lt;/p&gt;

  &lt;img src=&#34;./img/gdb_1.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;Using &lt;code&gt;watch $rax&lt;/code&gt; to watch the value of &lt;code&gt;rax&lt;/code&gt; and break every time the value of &lt;code&gt;rax&lt;/code&gt; changes, we slowly retrieve a stream of printable characters: &lt;code&gt;SW4gdGhlIHJ&lt;/code&gt;&lt;/p&gt;

  &lt;img src=&#34;./img/gdb_2.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;It looks like base64 - and decoding &lt;code&gt;SW4gdGhlIHJ&lt;/code&gt; from base64 yields &lt;code&gt;In the r&lt;/code&gt;. Not the flag, but probably the right track!&lt;/p&gt;
&lt;p&gt;Given there are over 2000 functions, we probably don&amp;rsquo;t want to do this manually. &lt;code&gt;gdb&lt;/code&gt; supports scripting with python, so lets automate it!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;starti&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gdb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;watch $rax&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    gdb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;execute(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;continue&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gdb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parse_and_eval(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$rax&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;cast(gdb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lookup_type(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;long&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(value)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flag &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; chr(value)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;flag &lt;span style=&#34;color:#e6db74&#34;&gt;= }&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running our script with &lt;code&gt;source gdb_script.py&lt;/code&gt; prints out a very long base64 encoded string.&lt;/p&gt;

  &lt;img src=&#34;./img/gdb_3.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;Adjusting some base64 offsets (sometimes there can be consecutive base64 characters, in which case &lt;code&gt;rax&lt;/code&gt; doesn&amp;rsquo;t change, resulting in some characters being missed - thanks to &lt;a href=&#34;https://twitter.com/JJJollyjim&#34;&gt;Jamie&lt;/a&gt; for correcting me on this!) and decoding from base64 in &lt;a href=&#34;https://gchq.github.io/CyberChef/#recipe=From_Base64%28%27A-Za-z0-9%2B/%3D%27,true,false%29&amp;amp;input=NGdkR2hsSUhKbFlXeHRJRzltSUdOdlpHVWdZVzVrSUd0bGVYTXNJR0VnWTJoYkd4bGJtZGxJR1pzWVdjZ2RXNW1kWEpzY3l3S1FTQmpjbmx3ZEdsaklHbHVkbWwwWVhScGIyNGdkRzhnZEdWemRDQjBhR1VnYzJoY25CbGMzUWdiV2x1WkhNZ2IyWWdkR2hsSUhkdmNteGtMZ3BCSUVOVVJpZHpJR1Z0WW14bGJTd2dhVzRnZEdobElHUnBaMmwwWVd3Z1pHOXRZV2x1SUdsMElHWnNhV1Z6TEFwQklIQjFlbnBzWlNCbWIzSWdkR2hsSUdOMWNtbHZkWE1zSUdFZ2NISnBlbVVnWm05eUlIUm9aU0IzYVhObExnb0tTWFJ6SUdOdmJHOXljeUJoY21WdUozUWdZM0pwYlhOdmJpd2dibTl5SUhOMGNtbHdaWE1nYjJZZ2NtVmtJR0Z1WkNCM2FHbDBaU3dLUW5WMElHRWdjR2w0Wld4aGRHVmtJSFJoY0dWemRISjVMQ0JoSUcxaGRISnBlQ0J2WmlCaWVYUmxjeUJwYmlCemFXZG9kQzRLU1c0Z1ltbHVZWEo1SUdKeWFXeHNhV0Z1WTJVc0lHbDBJR0psWTJ0dmJuTWdkMmwwYUNCaElHZHNiM2NzQ2tFZ2FHRmphMlZ5SjNNZ2NYVmxjM1FzSUhkb1pYSmxJR2hwWkdSbGJpQnJibTkzYkdWa1oyVWdiV0Y1SUdac2IzY3VDZ3BKYmlCMGFHVWdZbWx1WVhKNUlHSnlaV1Y2WlN3Z2FYUWdabXgxZEhSbGNuTWdiR2xyWlNCaElHUnBaMmwwWVd3Z1pISmxZVzBzQ2tFZ2RISmxZWE4xY21VZ2JXRndJRzltSUdKcGRITWdZVzVrSUdKNWRHVnpMQ0JwYmlCMGFHVWdZM2xpWlhJZ2MzUnlaV0Z0TGdwRllXTm9JR05vWVd4c1pXNW5aU0JtYkdGbkxDQmhJR05wY0dobGNtVmtJSFJoYkdVZ2RHOGdZbVVnZFc1MGIyeGtMQXBHYjNJZ2RHaHZjMlVnZDJodklHUmhjbVVnZEc4Z2RtVnVkSFZ5WlN3Z1ptOXlJSFJvWlNCaWNtRjJaU0JoYm1RZ2RHaGxJR0p2YkdRdUNncFVhR1VnWm14aFp5QnBjeUJqZVdKbFlYSnplMVUxTTJ3ek5UVmZZblYwWHpWME1XeHNYMmN3ZEY5MGFETmZabXhBWjMwdUNncFhhWFJvYVc0Z2FYUnpJR1Z1YVdkdFlTd2dkR2hsY21VZ2JHbGN5QmhJR2hwWkdSbGJpQnJaWGtzQ2tFZ2NtbGtaR3hsSUhSdklHSmxJSE52YkhabFpDd2dZU0JrYjI5eUlIUnZJSE5sZENCdGFXNWtjeUJtY21WbExncEdjbTl0SUhOMFpXZGhibTluY21Gd2FHbGpJSE5sWTNKbGRITWdkRzhnWTNKNWNIUnBZeUJqYkhWbGN5QmpiMjVqWldGc1pXUXNDbFJvWlNCRFZFWWdZMmhiR3hsYm1kbElHWnNZV2NzSUdFZ2NIVjZlbXhsSjNNZ1ptRjBaU0J5WlhabFlXeGxaQzRLQ2tFZ2JXRjZaU0J2WmlCaGJHZHZjbWwwYUcxekxDQmhJR3hoWW5seWFXNTBhQ0J2WmlCamIyUmxMQXBKYmlCMGFHbHpJR1JwWjJsMFlXd2dkMmxzWkdWeWJtVnpjeXdnWW5KaGRtVWdhSFZ1ZEdWeWN5QmxjbTlrWlM0S1ZHaGxhWElnYldsdVpITW5JSFJsY25KaGFXNHNJSGRwZEdnYkc5bmFXTW5jeUIwYjNKamFDQnBiaUJvWVc1a0xBcFVhR1Y1SUdwdmRYSnVaWGtnZEdoeWIzVm5hQ0IwYUdVZ1lubDBaWE1zSUhSb1pYa2diV0Z3SUhSb1pTQmthV2RwZEdGc0lHeGhibVF1Q2dwWGFYUm9JR1ZoWTJnWW5sMFpTQmtaV05wY0dobGNtVmtMQ0IzYVhSb0lHVmhZMmdZbmwwWlNCMWJuWmxhV3hsWkN3S1ZHaGxJR05vWVd4c1pXNW5aU0JtYkdGbklHUnlZWGR6SUc1bFlYSmxjaXdnYVhSeklHMTVjM1JsY25rZ2RXNXpaV0ZzWldRdUNrRnVaQ0IzYUdWdUlIUm9aU0JtYVc1aGJDQmpiMlJsSUdaaGJHeHpJR2x1ZEc4Z2FYUnpJSEJzWVdObExBcEJJSFpwY25SMVlXd2dkbWxqZEc5eWVTd2dZU0IwY21sMWJYQm9ZVzUwSUdWdFluSmhZMlV1Q2dwVGJ5d2djMkZzZFhSbElIUm9aU0JqYUdGc2JHVnVaMlVnWm14aFp5QnBiaUIwYUdVZ2NtVmhiRzBnYjJZZ1lubDBaWE1nWVc1a0lHdGxlWE1zQ2xkb1pYSmxJR2hZMnRsY25NZ1lXNWtJR052WkdWaWNtVmhhMlZ5Y3lCelpXVnJJSFJvWlNCaGJuTjNaWEp6SUdsMElHWnlaV1Z6TGdwSmJpQjBhR1VnZDI5eWJHUWdiMllnUTFSR0xDQjNhR1Z5WlNCdGFXNWtjeUJoY21VZ2MyVjBJSFJ2SUhOaGFXd3NDbFJvWlNCamFHRnNiR1Z1WjJVZ1pteGhaeUJ6ZEdGdVpITWdkR0ZzYkN3Z1lTQmthV2RwZEdGc0lHaHZiSGtnWjNKaGFXd3U8&#34;&gt;CyberChef&lt;/a&gt;, we get the flag!&lt;/p&gt;

  &lt;img src=&#34;./img/cyberchef.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;&lt;code&gt;cybears{U53l355_but_5t1ll_g0t_th3_fl@g}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Although we already got the flag, let&amp;rsquo;s take a deeper look into what was going on.&lt;/p&gt;
&lt;p&gt;A quick look at the disassembly shows &lt;code&gt;ebx&lt;/code&gt; (lower 32 bits of &lt;code&gt;rbx&lt;/code&gt;) being set to &lt;code&gt;0x6a0&lt;/code&gt;, and &lt;code&gt;rax&lt;/code&gt; is set to the value at address &lt;code&gt;rbx + 0x40a000&lt;/code&gt;.&lt;/p&gt;

  &lt;img src=&#34;./img/gdb_4.png&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


&lt;p&gt;That means that &lt;code&gt;rax&lt;/code&gt; was just being set to some data pointed at by &lt;code&gt;rbx&lt;/code&gt; (plus an offset of &lt;code&gt;0x40a000&lt;/code&gt;). However, the value &lt;code&gt;rbx&lt;/code&gt; is set to seems to not be constant for each function, so watching the value of &lt;code&gt;rax&lt;/code&gt; is probably still the best solution.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This was the first time I had gone to BSides Canberra, and it was by far the best and largest conference I had been to!&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&#34;https://twitter.com/cybearsCTF&#34;&gt;Cybears&lt;/a&gt; for making some neat challenges, and also &lt;a href=&#34;https://twitter.com/infosectcbr&#34;&gt;Infosect&lt;/a&gt; for covering the cost of my flights and hotel through their &lt;a href=&#34;https://www.bsidesau.com.au/assistance.html&#34;&gt;Assistance Program&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;It was great fun meeting everyone, from skateboarding dogs to DownUnder CTF organisers, and I look forward to next year&amp;rsquo;s conference!&lt;/p&gt;
&lt;p&gt;Thanks for reading :)&lt;/p&gt;
&lt;p&gt;Feel free to DM me on Discord &lt;code&gt;thesavageteddy&lt;/code&gt; or Twitter &lt;a href=&#34;https://twitter.com/teddyctf&#34;&gt;&lt;code&gt;teddyctf&lt;/code&gt;&lt;/a&gt; if you have any questions, corrections, or just want to chat!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;teddy / TheSavageTeddy&lt;/li&gt;
&lt;/ul&gt;

  &lt;img src=&#34;./img/group_photo.jpeg&#34;  class=&#34;center&#34;  style=&#34;border-radius: 5px; width: 100%&#34;  /&gt;


</content>
    </item>
    
  </channel>
</rss>
